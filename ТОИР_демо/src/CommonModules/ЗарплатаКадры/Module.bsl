#Область ПрограммныйИнтерфейс

// Выполняет действия в форме Организации, связанные с зарплатно-кадровой спецификой. 
// Вызов процедуры необходимо выполнять в обработчике ПриСозданииНаСервере
// формы организации.
//
// Параметры:
//  Форма - УправляемаяФорма - форма.
Процедура ОрганизацииФормаЭлементаПриСозданииНаСервере(Форма) Экспорт
	
КонецПроцедуры

// Выполняет действия в форме Организации, связанные с зарплатно-кадровой спецификой. 
// Вызов процедуры необходимо выполнять в обработчике ПриЧтенииНаСервере
// формы организации.
//
// Параметры:
//  Форма - УправляемаяФорма - форма.
Процедура ОрганизацииФормаЭлементаПриЧтенииНаСервере(Форма) Экспорт
	
	ПрочитатьПериодическиеСведенияОрганизации(Форма);
	
КонецПроцедуры

// Выполняет действия в форме Организации, связанные с зарплатно-кадровой спецификой.
// Вызов процедуры необходимо выполнять в обработчике ПриЗаписиНаСервере
// формы организации.
//
// Параметры:
//  Форма - УправляемаяФорма - форма.
Процедура ОрганизацииФормаЭлементаПриЗаписиНаСервере(Форма) Экспорт
	
	ЗаписатьПериодическиеСведенияОрганизации(Форма);
	
КонецПроцедуры

// Выполняет действия в форме Организации, связанные с зарплатно-кадровой спецификой. 
// Вызов процедуры необходимо выполнять в обработчике ПослеЗаписиНаСервере
// формы организации.
//
// Параметры:
//  Форма - УправляемаяФорма - форма.
Процедура ОрганизацииФормаЭлементаПослеЗаписиНаСервере(Форма) Экспорт
	
	ПрочитатьПериодическиеСведенияОрганизации(Форма);
	
КонецПроцедуры

// Выполняет действия в форме Организации, связанные с зарплатно-кадровой спецификой. 
// Вызов процедуры необходимо выполнять в обработчике ОбработкаПроверкиЗаполненияНаСервере
// формы организации.
//
// Параметры:
//  Форма - УправляемаяФорма - форма.
//  Отказ - Булево - отказ.
Процедура ОрганизацииФормаЭлементаОбработкаПроверкиЗаполненияНаСервере(Форма, Отказ) Экспорт

КонецПроцедуры

// Процедура регистрирует факт оплаты ведомостей
//
// Параметры:
//		ПлатежныйДокумент	- ДокументОбъект - платежный документ (документ-объект)
//		Организация			- СправочниСсылка.Организации - организация документа
//		Ведомости			- Массив - массив ссылок на ведомости (типа ДокументСсылка.ВедомостьНаВыплатуЗарплатыВКассу,
//								ДокументСсылка.ВедомостьНаВыплатуЗарплатыВБанк)
//		ФизическиеЛица		- Массив - массив ссылок на физические лица
//		Оплаченные			- Булево - описывает учет статуса оплаты:
//									истина - только оплаченные
//									ложь - неоплаченные
//									неопределено - состояние оплаты не учитывается
//		Отказ				- Булево - признак отказа выполнения операции.
// 						Обработка ошибочных ситуаций
//							выдается сообщение, признак «Отказ» выставляется в Истина.
//
Процедура ЗарегистрироватьОплатуВедомостей(ПлатежныйДокумент, Организация, Ведомости, ФизическиеЛица = Неопределено, Оплаченные = Ложь, Отказ = Ложь) Экспорт
		
КонецПроцедуры

// Обработчик, вызываемый при окончании стандартного формирования словаря замен
// по очередному файлу общих данных.
//
// Параметры:
//  СловарьЗамен - ТаблицаЗначений - колонки
//    * Тип - Тип - Тип значения заменяемой ссылки
//    * СоответствиеСсылок - Соответствие - соответствие новой ссылки исходной
//    * Ключ - Ссылка - Новая ссылка (на которую требуется заменить)
//    * Значение - Ссылка - Исходная ссылка (требующая замены)
//  ИмяФайлаОбщихДанных - Строка - имя текущего обрабатываемого файла выгрузки
//   общих данных.
//
Процедура ДополнитьСловарьЗаменПоОбщимДанным(Знач СловарьЗамен, Знач ИмяФайлаОбщихДанных) Экспорт
	
	ИмяВременногоФайла = ПолучитьИмяВременногоФайла("xml");
	
	ЗаписьТаблицы = Новый ЗаписьXML;
	ЗаписьТаблицы.ОткрытьФайл(ИмяВременногоФайла);
	
	Преобразование = ОбщегоНазначенияПовтИсп.ПолучитьПреобразованиеXSLИзОбщегоМакета("ИзвлечениеИдентификаторовОбъектовОбщихДанных");
	Преобразование.ПреобразоватьИзФайла(ИмяФайлаОбщихДанных, ЗаписьТаблицы);
	
	ЗаписьТаблицы.Закрыть();
	
	Чтение = Новый ЧтениеXML;
	Чтение.ОткрытьФайл(ИмяВременногоФайла);
	Чтение.ПерейтиКСодержимому();
	
	Если Чтение.ТипУзла <> ТипУзлаXML.НачалоЭлемента
		ИЛИ Чтение.Имя <> "Data" Тогда
		
		ВызватьИсключение(НСтр("ru = 'Ошибка чтения XML. Неверный формат файла. Ожидается начало элемента Data.'"));
	КонецЕсли;
	
	Если НЕ Чтение.Прочитать() Тогда
		ВызватьИсключение(НСтр("ru = 'Ошибка чтения XML. Обнаружено завершение файла.'"));
	КонецЕсли;
	
	ТаблицаКодов = СериализаторXDTO.ПрочитатьXML(Чтение);
	
	Чтение.Закрыть();
	
	Попытка
		УдалитьФайлы(ИмяВременногоФайла);
	Исключение
		
	КонецПопытки;
	
	ТекстЗапросаСозданияТаблицыКодов =
	"ВЫБРАТЬ
	|	Коды.Ссылка КАК Ссылка,
	|	Коды.ИдентификаторОбъекта КАК ИдентификаторОбъекта
	|ПОМЕСТИТЬ Идентификаторы
	|ИЗ
	|	&Идентификаторы КАК Коды
	|
	|ИНДЕКСИРОВАТЬ ПО
	|	Ссылка";
	МенеджерВТ = Новый МенеджерВременныхТаблиц;
	
	Запрос = Новый Запрос;
	Запрос.МенеджерВременныхТаблиц = МенеджерВТ;
	Запрос.Текст = ТекстЗапросаСозданияТаблицыКодов;
	Запрос.УстановитьПараметр("Идентификаторы", ТаблицаКодов);
	Запрос.Выполнить();
	
	// Для этих типов при сопоставлении используется не код, а ИдентификаторОбъекта
	МассивТипов = Новый Массив;
	ТипыОбщихДанныхСопоставляемыхПоИдентификаторуОбъекта(МассивТипов);
	
	Для каждого ТипЗамены Из МассивТипов Цикл
		МетаданныеОбщегоТипа = Метаданные.НайтиПоТипу(ТипЗамены);
		
		ТекстЗапроса = 
		"ВЫБРАТЬ
		|	Идентификаторы.Ссылка КАК ИсходнаяСсылка,
		|	Идентификаторы.ИдентификаторОбъекта КАК ИдентификаторОбъекта
		|ИЗ
		|	Идентификаторы КАК Идентификаторы
		|ГДЕ
		|	Идентификаторы.Ссылка ССЫЛКА " + МетаданныеОбщегоТипа.ПолноеИмя();
			
		Запрос.Текст = ТекстЗапроса;
		Результат = Запрос.Выполнить();
		
		СтрокаТипа = СловарьЗамен.Найти(ТипЗамены, "Тип");
		Если СтрокаТипа = Неопределено Тогда
			СтрокаТипа = СловарьЗамен.Добавить();
			СтрокаТипа.Тип = ТипЗамены;
			СтрокаТипа.СоответствиеСсылок = Новый Соответствие;
		КонецЕсли;
		СоответствиеСсылок = СтрокаТипа.СоответствиеСсылок;
		
		Выборка = Результат.Выбрать();
		Пока Выборка.Следующий() Цикл
			ОбщаяСсылка = ОбщегоНазначенияКлиентСервер.ПредопределенныйЭлемент(МетаданныеОбщегоТипа.ПолноеИмя() + "." + Выборка.ИдентификаторОбъекта);
			СоответствиеСсылок.Вставить(
				ОбщаяСсылка.УникальныйИдентификатор(),
				Выборка.ИсходнаяСсылка.УникальныйИдентификатор());
		КонецЦикла;
	КонецЦикла;
		
КонецПроцедуры

// Заполняет массив типов неразделенных данных. Он используется при обновлении ссылок 
// при загрузке-выгрузке конфигурации.
// 
// Параметры:
//  МассивТипов - Массив - массив типов.
//
Процедура ТипыОбщихДанных(Знач МассивТипов) Экспорт
КонецПроцедуры

#КонецОбласти

#Область СлужебныйПрограммныйИнтерфейс

////////////////////////////////////////////////////////////////////////////////
// СЛУЖЕБНЫЙ ПРОГРАММНЫЙ ИНТЕРФЕЙС

// Выполняет заполнение первоначальных значений при создании новых 
// объектов или открытии иных форм
// Параметры:
//		Форма - УправляемаяФорма - форма, реквизиты которой необходимо заполнить
//		ЗапрашиваемыеЗначения - Структура - структура с запрашиваемыми значениями
//			Имя элемента структуры идентифицирует значение, которое 
//				необходимо заполнить
//			Значение элемента структуры - путь к реквизиту формы, значение
//				которого необходимо заполнить
//			Список поддерживаемых значений см. в описании ПолучитьЗначенияПоУмолчанию.
//
Процедура ЗаполнитьПервоначальныеЗначенияВФорме(Форма, ЗапрашиваемыеЗначения) Экспорт
	
	ФиксированныеЗначения = Новый Массив;
	Для Каждого ЗапрашиваемоеЗначение Из ЗапрашиваемыеЗначения Цикл
		Если ЗначениеЗаполнено(ОбщегоНазначенияКлиентСервер.ПолучитьРеквизитФормыПоПути(Форма, ЗапрашиваемоеЗначение.Значение)) Тогда
			ФиксированныеЗначения.Добавить(ЗапрашиваемоеЗначение.Ключ)
		КонецЕсли	
	КонецЦикла;

	ЗаполнитьЗначенияВФорме(Форма, ЗапрашиваемыеЗначения, ФиксированныеЗначения);
	
КонецПроцедуры

// Выполняет заполнение значений в форме на основании значений по умолчанию 
// 
// Параметры:
//		Форма - УправляемаяФорма - форма, реквизиты которой необходимо заполнить
//		ЗапрашиваемыеЗначения - Структура - структура с запрашиваемыми значениями
//			Имя элемента структуры идентифицирует значение, которое 
//				необходимо заполнить
//			Значение элемента структуры - путь к реквизиту формы, значение
//				которого необходимо заполнить
//			Список поддерживаемых значений см. в описании ПолучитьЗначенияПоУмолчанию.
//
//		ФиксированныеЗначения - Массив - (необязательный) 
//				Содержит идентификаторы значений, 
//				которое не должны быть изменены при заполнении.
//
Процедура ЗаполнитьЗначенияВФорме(Форма, ЗапрашиваемыеЗначения, ФиксированныеЗначения = Неопределено) Экспорт
	
	Если ФиксированныеЗначения = Неопределено Тогда
		ФиксированныеЗначения = Новый Массив
	КонецЕсли;
	
	ЗаполняемыеЗначения = Новый Структура;
	Для Каждого ЗапрашиваемоеЗначение Из ЗапрашиваемыеЗначения Цикл
		Если ФиксированныеЗначения.Найти(ЗапрашиваемоеЗначение.Ключ) = Неопределено Тогда
			ЗначениеРеквизита = НеОпределено;
		Иначе
			ЗначениеРеквизита = ОбщегоНазначенияКлиентСервер.ПолучитьРеквизитФормыПоПути(Форма, ЗапрашиваемоеЗначение.Значение)
		КонецЕсли;	
		ЗаполняемыеЗначения.Вставить(ЗапрашиваемоеЗначение.Ключ, ЗначениеРеквизита);
	КонецЦикла;
	
	ПолучитьЗначенияПоУмолчанию(ЗаполняемыеЗначения);
	
	// Заполняем значения
	Для Каждого ЗапрашиваемоеЗначение Из ЗапрашиваемыеЗначения Цикл
		Если ФиксированныеЗначения.Найти(ЗапрашиваемоеЗначение.Ключ) = Неопределено Тогда
			ЗначениеРеквизита = НеОпределено;
			ЗаполняемыеЗначения.Свойство(ЗапрашиваемоеЗначение.Ключ, ЗначениеРеквизита);
			ОбщегоНазначенияКлиентСервер.УстановитьРеквизитФормыПоПути(Форма, ЗапрашиваемоеЗначение.Значение, ЗначениеРеквизита);
		КонецЕсли
	КонецЦикла;
	
КонецПроцедуры

// Получает значения по умолчанию
// Параметры:
//		ЗаполняемыеЗначения - Структура - структура, 
//				Ключи структуры - идентификаторы запрашиваемых значений, 
//				Значения полей структуры заполняются процедурой приведены ниже.
//
//				Процедура поддерживает получение значений по умолчанию, которые 
//				зависят от других значений.
//				Например, для получения значения ДолжностьРуководителя для 
//				конкретной организации можно передать структуру с полями Организация и 
//				ДолжностьРуководителя, причем поле Организация заполнить конкретным значением
//				В результате выполнения процедуры поле ДолжностьРуководителя
//				будет заполнено значением по умолчанию.
//
//				Допустимые идентификаторы запрашиваемых значений:
//					Год	
//					Месяц	
//					ПредыдущийГод	
//					ПредыдущийМесяц	
//					ПредыдущийКвартал
//					Ответственный
//					НаименованиеПФР
//					НаименованиеТерриториальногоОрганаФСС
//					-----------------
//					Организация
//					Руководитель
//					ГлавныйБухгалтер
//					ДолжностьРуководителя
//					Подразделение.
//
Процедура ПолучитьЗначенияПоУмолчанию(ЗаполняемыеЗначения) Экспорт
		
КонецПроцедуры

// Процедура получает ссылочные значений, имеющиеся в базе в единственном экземпляре.
// Допущения реализации.
//	1. Если в переданной структуре находятся 2 элемента одинакового типа
// 		и этот тип является типом владельца подбираемого значения,
//		то в качестве владельца всегда будет использоваться первый заполненный элемент.
//  2. Не учитываются возможные связи параметров выбора.
//
// Параметры:
//		ЗаполняемыеЗначения - Структура - структура, 
//				Ключи структуры - идентификаторы запрашиваемых значений, 
//				Значения полей должны быть заполнены, как минимум пустой ссылкой(для ссылочных полей).
//
Процедура ПолучитьЕдинственныеЗначенияТипов(ЗаполняемыеЗначения) Экспорт

	Запрос = Новый Запрос;
	ТекстОсновногоЗапроса  = "";
	
	СтрокаЗаменыОбъединить  = "
	|
	|ОБЪЕДИНИТЬ ВСЕ
	|";
	
	СтрокаЗаменыРазрешенные = "РАЗРЕШЕННЫЕ";
	
	НомерПараметра = 0;
	
	Для каждого ЗаполняемоеЗначение Из ЗаполняемыеЗначения Цикл
		Если ЗначениеЗаполнено(ЗаполняемоеЗначение.Значение) ИЛИ ЗаполняемоеЗначение.Значение = Неопределено Тогда
			Продолжить;	
		КонецЕсли;
		
		Тип = ТипЗнч(ЗаполняемоеЗначение.Значение);
		Если НЕ ОбщегоНазначения.ЭтоСсылка(Тип) Тогда
			Продолжить;
		КонецЕсли; 
		
		МетаданныеТипа = Метаданные.НайтиПоТипу(Тип);
		
		ТекстОсновногоЗапроса = СтрЗаменить(ТекстОсновногоЗапроса, "#ОБЪЕДИНИТЬ#", СтрокаЗаменыОбъединить);
		
		ТекстОсновногоЗапроса = ТекстОсновногоЗапроса + "ВЫБРАТЬ #РАЗРЕШЕННЫЕ# ПЕРВЫЕ 2 """ + ЗаполняемоеЗначение.Ключ + """ КАК Поле,
		|	" + МетаданныеТипа.Имя + ".Ссылка КАК Ссылка
		| из " + МетаданныеТипа.ПолноеИмя() + " КАК " + МетаданныеТипа.Имя + "    
		|#ОБЪЕДИНИТЬ#";
		
		ТекстОсновногоЗапроса = СтрЗаменить(ТекстОсновногоЗапроса, "#РАЗРЕШЕННЫЕ#", СтрокаЗаменыРазрешенные);
		СтрокаЗаменыРазрешенные = "";
	КонецЦикла;
	
	ТекстОсновногоЗапроса = СтрЗаменить(ТекстОсновногоЗапроса, "#ОБЪЕДИНИТЬ#", "
	|ИТОГИ ПО
	| Поле");
	
	Если НЕ ПустаяСтрока(ТекстОсновногоЗапроса) Тогда
		Запрос.Текст = ТекстОсновногоЗапроса;
		Результат = Запрос.Выполнить();
		Если Не Результат.Пустой() Тогда
			Выборка = Результат.Выбрать(ОбходРезультатаЗапроса.ПоГруппировкам);
			Пока Выборка.Следующий() Цикл
				ВыборкаПоПолю = Выборка.Выбрать();
				Если ВыборкаПоПолю.Количество() = 1 Тогда
					ВыборкаПоПолю.Следующий();
					ЗаполняемыеЗначения[ВыборкаПоПолю.Поле] = ВыборкаПоПолю.Ссылка;
				КонецЕсли;
			КонецЦикла;	
		КонецЕсли;
	КонецЕсли;
КонецПроцедуры

// Выполняет формирование таблицы с набором значений доступа объекта (документа), 
// содержащего ссылки на организацию и сотрудника (сотрудников)
// Вызывается из процедуры ЗаполнитьНаборыЗначенийДоступа, реализованной в модуле таких 
// документов, доступ к которым выполняется через наборы значений доступа.
//
// Параметры:
//		Объект - Объект - объект.
//		Таблица - ТаблицаЗначений - переданная таблица значений
//		ПутьОрганизация - Строка - строка с именем реквизита, содержащего организацию
//		ПутьФизическоеЛицо - Строка - строка с именем реквизита, содержащего физическое лицо
//			Может быть идентификатором реквизита объекта (например, "ФизическоеЛицо") или
//			путем к реквизиту табличной части в 
//			формате <ИмяТабличнойЧасти>.<ИмяРеквизита> 
//			(например, "ФизическиеЛица.ФизическоеЛицо").
//		НомерНабора - Число - номер набора.
//
Процедура ЗаполнитьНаборыПоОрганизацииИФизическимЛицам(Объект, Таблица, ПутьОрганизация, ПутьФизическоеЛицо, НомерНабора = 0) Экспорт
	
	// Логика ограничения:
	// объект доступен, если доступна организация и все физические лица.
	
	СтрокаТаб = Таблица.Добавить();
	СтрокаТаб.ЗначениеДоступа = Объект[ПутьОрганизация];
	СтрокаТаб.НомерНабора = НомерНабора;
	
	СтрокиПутиФизическогоЛица = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(ПутьФизическоеЛицо, ".");
	Если СтрокиПутиФизическогоЛица.Количество() = 1 Тогда
		СтрокаТаб = Таблица.Добавить();
		СтрокаТаб.ЗначениеДоступа		= Объект[ПутьФизическоеЛицо];
		СтрокаТаб.НомерНабора = НомерНабора;
		
	Иначе
		Для Каждого СтрокаТаблицы Из Объект[СтрокиПутиФизическогоЛица[0]] Цикл
			СтрокаТаб = Таблица.Добавить();
			СтрокаТаб.ЗначениеДоступа	= СтрокаТаблицы[СтрокиПутиФизическогоЛица[1]];
			СтрокаТаб.НомерНабора = НомерНабора;
		КонецЦикла;
		
	КонецЕсли;
	
КонецПроцедуры

// Функция определяет является ли организация юридическим лицом 
// "по правилам" регламентированной отчетности.
//
// Параметры:
//		Организация - СправочникСсылка.Организации - Организация.
Функция ЭтоЮридическоеЛицо(Организация) Экспорт
	
КонецФункции

// Возвращает структуру с параметрами формирования таблицы "записей", "среза последних" для процедур 
// СоздатьПоВременнойТаблицеВТИмяРегистра, СоздатьПоВременнойТаблицеВТИмяРегистраСрез. 
//
// Параметры:
//		МенеджерВременныхТаблиц - МенеджерВременныхТаблиц - менеджер временных таблиц.
//		ИмяВТИзмеренияДаты - Строка - имя временной таблицы - "фильтра"
//		ИзмеренияРегистра - Строка - строка с именами измерений регистра, разделенных символом ",",
//							по которым будет осуществляться фильтрация.
//
// Возвращаемое значение:
//		Структура - с полями
//			МенеджерВременныхТаблиц
//			ИмяВТИзмеренияДаты - имя временной таблицы с параметрами среза.
//			Измерения - 		 массив с именами измерений, по которым будет получен "Срез последних"
//								 Может содержать колонки с именами, совпадающими с именами 
//								 измерений регистра сведений.		
Функция ПараметрыДляСоздатьПоВременнойТаблицеВТИмяРегистра(МенеджерВременныхТаблиц, ИмяВТИзмеренияДаты, ИзмеренияРегистра) Экспорт
	
	МассивИзмерений = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(ИзмеренияРегистра, ",");
	
	ОписаниеПараметров = Новый Структура;
	ОписаниеПараметров.Вставить("МенеджерВременныхТаблиц", МенеджерВременныхТаблиц);
	ОписаниеПараметров.Вставить("ИмяВТИзмеренияДаты", ИмяВТИзмеренияДаты);
	ОписаниеПараметров.Вставить("Измерения", МассивИзмерений);
	
	Возврат ОписаниеПараметров;
	
КонецФункции 	

// Формирует временную таблицу с последними значениями ресурсов заданного регистра сведений.
//
// Создает в МенеджерВременныхТаблиц временную таблицу. 
// Поля временной таблицы
//	- Период
//	- Все измерения (не только переданные в качестве фильтра, а все)
//	- Все ресурсы без постфикса ПоОкончании
//	- Все реквизиты.
//
// Параметры:
//		МенеджерВременныхТаблиц - МенеджерВременныхТаблиц - менеджер временных таблиц.
//		ТолькоРазрешенные - Булево - если истина, выбираются только разрешенные записи.
//		ИмяРегистра - Строка - имя регистра сведений (не полное).
//
//		ИзмеренияДаты - ТаблицаЗначений - таблица значений.
//			Должна обязательно содержать колонку "Период"
//			Может содержать колонки с именами, совпадающими с именами 
//			измерений регистра сведений.
//
//			Используется как фильтр - переданные в ней значения измерений "фильтруют" регистр.
//			В зависимости от значения параметра ВсеЗаписи строки ИзмеренияДаты используются 
//			не только как фильтр, но и как набор значений для дополнения результирующей 
//			временной таблицы.
//			Содержит даты получения последних значений ресурсов.
//			В предельном случае, когда нет колонок таблицы, соответствующих измерениям, 
//			(т.е. фильтрация по измерениям не выполняется), в таблице содержится одна строка 
//			с датой на которую нужно получить значения ресурсов.
//
//		Отбор - Коллекция - коллекция условий отбора, соединяемых по "И" и применяемых к регистру сведений.
//			Коллекция строки которой имеют поля
//				ЛевоеЗначение - строка, имя поля регистра сведений
//				ВидСравнения - строка, вид сравнения, допустимый в языке запросов
//				ПравоеЗначение - значение для сравнения с полем ЛевоеЗначение.
//
//		ВсеЗаписи - Булево - Если Истина, то в результирующей временной таблице
//			должно быть столько же записей, сколько передано в параметре ИзмеренияДаты
//			Если Ложь, то временная таблица содержит записи только для тех 
//			значений измерений, для которых существуют данные в регистре.
//			По умолчанию - Ложь.
//		
//		ВключаяГраницу - Булево - Если Истина, то записи на дату формирования среза учитываются
//			Если Ложь, то записи на дату формирования среза не учитываются
//			По умолчанию - Истина.  
//
//		ИмяРезультирующейТаблицы - Строка - имя временной таблицы в которую должен быть помещен результат.
//			Если имя не задано, то создается временная таблица с именем 
//			ВТ<ИмяРегистра>СрезПоследних, например: ВТПлановыеНачисленияСрезПоследних.
//
Процедура СоздатьПоТаблицеЗначенийВТИмяРегистраСрезПоследних(МенеджерВременныхТаблиц, ТолькоРазрешенные, ИмяРегистра, ИзмеренияДаты, Отбор = Неопределено, ВсеЗаписи = Ложь, ВключаяГраницу = Истина, ИмяРезультирующейТаблицы = "") Экспорт
	СоздатьПоТаблицеЗначенийВТИмяРегистраСрез(МенеджерВременныхТаблиц, ТолькоРазрешенные, ИмяРегистра, ИзмеренияДаты, Отбор, ВсеЗаписи, ВключаяГраницу, Истина, ИмяРезультирующейТаблицы);
КонецПроцедуры

// Формирует временную таблицу с первыми значениями ресурсов заданного регистра сведений, описание 
// параметров см. СоздатьПоТаблицеЗначенийВТИмяРегистраСрезПоследних.
//
Процедура СоздатьПоТаблицеЗначенийВТИмяРегистраСрезПервых(МенеджерВременныхТаблиц, ТолькоРазрешенные, ИмяРегистра, ИзмеренияДаты, Отбор = Неопределено, ВсеЗаписи = Ложь, ВключаяГраницу = Истина, ИмяРезультирующейТаблицы = "") Экспорт
	СоздатьПоТаблицеЗначенийВТИмяРегистраСрез(МенеджерВременныхТаблиц, ТолькоРазрешенные, ИмяРегистра, ИзмеренияДаты, Отбор, ВсеЗаписи, ВключаяГраницу, Ложь, ИмяРезультирующейТаблицы);
КонецПроцедуры

// Формирует временную таблицу с последними значениями ресурсов заданного регистра сведений.
//
// Создает в МенеджерВременныхТаблиц временную таблицу.
// Поля временной таблицы
//	- Период
//	- Все измерения (не только переданные в качестве фильтра, а все)
//	- Все ресурсы без постфикса ПоОкончании
//	- Все реквизиты.
//
// Параметры:
//
//		ПараметрыСреза - структура полученная функцией ПараметрыСрезаПоследних.
//			Содержит следующие поля:
//							МенеджерВременныхТаблиц
//							ИмяВТИзмеренияДаты - имя временной таблицы с параметрами среза.
//												 Должна обязательно поле "Период"
//												 Используется как фильтр - переданные в ней значения измерений "фильтруют" регистр.
//												 В зависимости от значения параметра ВсеЗаписи строки ИзмеренияДаты используются 
//												 не только как фильтр, но и как набор значений для дополнения результирующей 
//												 временной таблицы.
//												 Содержит даты получения последних значений ресурсов.
//												 В предельном случае, когда нет колонок таблицы, соответствующих измерениям, 
//												 (т.е. фильтрация по измерениям не выполняется), в таблице содержится одна строка 
//												 с датой на которую нужно получить значения ресурсов.
//							Измерения - массив с именами измерений, по которым будет получен "Срез последних".
//										Может содержать колонки с именами, совпадающими с именами 
//										измерений регистра сведений.
//
//		ТолькоРазрешенные - если истина, выбираются только разрешенные записи.
//
//		ИмяРегистра - имя регистра сведений (не полное).
//			
//		Отбор - коллекция условий отбора, соединяемых по "И" и применяемых к регистру сведений.
//			Коллекция строки которой имеют поля
//				ЛевоеЗначение - строка, имя поля регистра сведений
//				ВидСравнения - строка, вид сравнения, допустимый в языке запросов
//				ПравоеЗначение - значение для сравнения с полем ЛевоеЗначение.
//
//		ВсеЗаписи - булево значение. 
//			Если Истина, то в результирующей временной таблице
//			должно быть столько же записей, сколько передано в параметре ИзмеренияДаты.
//			Если Ложь, то временная таблица содержит записи только для тех 
//			значений измерений, для которых существуют данные в регистре.
//			По умолчанию - Ложь.
//		
//		ВключаяГраницу - булево значение.	
//			Если Истина, то записи на дату формирования среза учитываются
//			Если Ложь, то записи на дату формирования среза не учитываются
//			По умолчанию - Истина.  
//
//		ИмяРезультирующейТаблицы - имя временной таблицы в которую должен быть помещен результат
//			Если имя не задано, то создается временная таблица с именем 
//			ВТ<ИмяРегистра>СрезПоследних, например: ВТПлановыеНачисленияСрезПоследних.
//
Процедура СоздатьПоВременнойТаблицеВТИмяРегистраСрезПоследних(ПараметрыСреза, ТолькоРазрешенные, ИмяРегистра, Отбор = Неопределено, ВсеЗаписи = Ложь, ВключаяГраницу = Истина, ИмяРезультирующейТаблицы = "") Экспорт
	СоздатьПоВременнойТаблицеВТИмяРегистраСрез(ПараметрыСреза, ТолькоРазрешенные,  ИмяРегистра, Отбор, ВсеЗаписи, ВключаяГраницу, Истина, ИмяРезультирующейТаблицы)
КонецПроцедуры

// Формирует временную таблицу с первыми значениями ресурсов заданного регистра сведений, описание 
// параметров см. СоздатьПоВременнойТаблицеВТИмяРегистраСрезПоследних.
//
Процедура СоздатьПоВременнойТаблицеВТИмяРегистраСрезПервых(ПараметрыСреза, ТолькоРазрешенные, ИмяРегистра, Отбор = Неопределено, ВсеЗаписи = Ложь, ВключаяГраницу = Истина, ИмяРезультирующейТаблицы = "") Экспорт
	СоздатьПоВременнойТаблицеВТИмяРегистраСрез(ПараметрыСреза, ТолькоРазрешенные,  ИмяРегистра, Отбор, ВсеЗаписи, ВключаяГраницу, Ложь, ИмяРезультирующейТаблицы)
КонецПроцедуры

// Формирует временную таблицу с записями заданного регистра сведений.
//
// Создает в МенеджерВременныхТаблиц временную таблицу с именем ВТ<ИмяРегистра>.
// Например: ВТПлановыеНачисления
// Поля временной таблицы
//	- Период
//	- Все измерения 
//	- Все ресурсы 
//	- Все реквизиты
//	- Все стандартные реквизиты.
//
// Параметры:
//		МенеджерВременныхТаблиц - МенеджерВременныхТаблиц - менеджер временных таблиц.
//		ТолькоРазрешенные - Булево - если истина, выбираются только разрешенные записи.
//		ИмяРегистра - Строка - имя регистра сведений (не полное).
//
//		ИзмеренияДаты - ТаблицаЗначений - таблица.
//			Должна обязательно содержать колонки "ДатаНачала" и "ДатаОкончания"
//			Может содержать колонки с именами, совпадающими с именами 
//			измерений регистра сведений
//			Используется как фильтр - переданные в ней значения измерений "фильтруют" регистр.
//
//		Отбор - Коллекция - коллекция условий отбора, соединяемых по "И" и применяемых к регистру сведений.
//			Коллекция строки которой имеют поля
//				ЛевоеЗначение - строка, имя поля регистра сведений
//				ВидСравнения - строка, вид сравнения, допустимый в языке запросов
//				ПравоеЗначение - значение для сравнения с полем ЛевоеЗначение.
//
//			
Процедура СоздатьПоТаблицеЗначенийВТИмяРегистра(МенеджерВременныхТаблиц, ТолькоРазрешенные, ИмяРегистра, ИзмеренияДаты, Отбор = Неопределено) Экспорт
	
	МассивИзмерений = Новый Массив;
	Для Каждого Колонка Из ИзмеренияДаты.Колонки Цикл
		МассивИзмерений.Добавить(Колонка.Имя);		
	КонецЦикла;	
	
	КоллекцииПолей = КоллекцииПолейДляПодготовкиТекстаЗапроса(ИмяРегистра, МассивИзмерений);
	
	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("ИзмеренияДаты", ИзмеренияДаты);
	Запрос.МенеджерВременныхТаблиц = МенеджерВременныхТаблиц;
	
	ИмяВТИзмеренияДаты = УникальноеИмяВременнойТаблицы("ВТИзмеренияДаты");
	
	ТекстЗапроса = 
	"ВЫБРАТЬ";
	Для Каждого Измерение Из КоллекцииПолей.ИзмеренияФильтра Цикл
		ТекстЗапроса = ТекстЗапроса + "
		|	ИзмеренияДаты." + Измерение + ",";
	КонецЦикла;
	
	ТекстЗапроса = ТекстЗапроса + "
	|	ИзмеренияДаты.ДатаНачала,
	|	ИзмеренияДаты.ДатаОкончания,";
	
	ТекстЗапроса = Лев(ТекстЗапроса, СтрДлина(ТекстЗапроса) - 1);
	
	ТекстЗапроса = ТекстЗапроса + "
	|ПОМЕСТИТЬ " + ИмяВТИзмеренияДаты + "
	|ИЗ
	|	&ИзмеренияДаты КАК ИзмеренияДаты";
	
	Запрос.Текст = ТекстЗапроса;
	Запрос.Выполнить();
	
	ЗапросВТИмяРегистра = ЗапросВТИмяРегистра(ТолькоРазрешенные, КоллекцииПолей, ИмяРегистра, ИмяВТИзмеренияДаты, "", Отбор);
	ЗапросВТИмяРегистра.МенеджерВременныхТаблиц = Запрос.МенеджерВременныхТаблиц;
	
	ДобавитьТекстУдаленияВременнойТаблицы(ЗапросВТИмяРегистра.Текст, ИмяВТИзмеренияДаты);
	
	ЗапросВТИмяРегистра.Выполнить();
	
КонецПроцедуры

// Формирует временную таблицу с записями заданного регистра сведений.
//
// Создает в МенеджерВременныхТаблиц временную таблицу с именем ВТ<ИмяРегистра>.
// Например: ВТПлановыеНачисления
// Поля временной таблицы
//	- Период
//	- Все измерения
//	- Все ресурсы
//	- Все реквизиты
//	- Все стандартные реквизиты.
//
// Параметры:
//
//		ПараметрыЗапроса - Структура - полученная функцией ПараметрыДляСоздатьПоВременнойТаблицеВТИмяРегистра.
//			Содержит следующие поля:
//							ИмяВТИзмеренияДаты - имя временной таблицы с параметрами среза.
//												 Должна обязательно поле "Период".
//												 Используется как фильтр - переданные в ней значения измерений "фильтруют" регистр.
//												 В зависимости от значения параметра ВсеЗаписи строки ИзмеренияДаты используются 
//												 не только как фильтр, но и как набор значений для дополнения результирующей 
//												 временной таблицы.
//												 Содержит даты получения последних значений ресурсов.
//												 В предельном случае, когда нет колонок таблицы, соответствующих измерениям, 
//												 (т.е. фильтрация по измерениям не выполняется), в таблице содержится одна строка 
//												 с датой на которую нужно получить значения ресурсов.
//							Измерения - массив с именами измерений, по которым будет получен "Срез последних".
//										Может содержать колонки с именами, совпадающими с именами 
//										измерений регистра сведений.
//							МенеджерВременныхТаблиц - менеджер-получатель таблицы ВТ<ИмяРегистра>.
//
//		ТолькоРазрешенные - Булево - если истина, выбираются только разрешенные записи.
//
//		ИмяРегистра - Строка - имя регистра сведений (не полное).
//
//		Отбор - Коллекция - коллекция условий отбора, соединяемых по "И" и применяемых к регистру сведений.
//			Коллекция строки которой имеют поля
//				ЛевоеЗначение - строка, имя поля регистра сведений
//				ВидСравнения - строка, вид сравнения, допустимый в языке запросов
//				ПравоеЗначение - значение для сравнения с полем ЛевоеЗначение.
//
//			
Процедура СоздатьПоВременнойТаблицеВТИмяРегистра(ПараметрыЗапроса, ТолькоРазрешенные,  ИмяРегистра, Отбор = Неопределено) Экспорт
	
	КоллекцииПолей = КоллекцииПолейДляПодготовкиТекстаЗапроса(ИмяРегистра, ПараметрыЗапроса.Измерения);
	
	ЗапросВТИмяРегистра = ЗапросВТИмяРегистра(ТолькоРазрешенные, КоллекцииПолей, ИмяРегистра, ПараметрыЗапроса.ИмяВТИзмеренияДаты, "", Отбор);
	ЗапросВТИмяРегистра.МенеджерВременныхТаблиц = ПараметрыЗапроса.МенеджерВременныхТаблиц;
	
	ЗапросВТИмяРегистра.Выполнить();
	
КонецПроцедуры

// Помещает в переданный массив имена реквизитов формы.
// Параметры:
//		Форма - УправляемаяФорма - форма.
//		МассивИменРеквизитовФормы - Массив  массив имен реквизитов формы.
//    ПутьКДанным - Строка - путь к данным.
//
Процедура ЗаполнитьМассивИменРеквизитовФормы(Форма, МассивИменРеквизитовФормы,  ПутьКДанным = "") Экспорт
	
	Если ЗначениеЗаполнено(ПутьКДанным) Тогда
		МассивРеквизитовФормы = Форма.ПолучитьРеквизиты(ПутьКДанным);
	Иначе
		МассивРеквизитовФормы = Форма.ПолучитьРеквизиты();
	КонецЕсли;
	
	Для Каждого Реквизит Из МассивРеквизитовФормы Цикл
		МассивИменРеквизитовФормы.Добавить(?(ЗначениеЗаполнено(ПутьКДанным), ПутьКДанным + ".", "") + Реквизит.Имя);	
	КонецЦикла;
	
КонецПроцедуры

Процедура ИзменитьРеквизитыФормы(Форма, ДобавляемыеРеквизиты, СуществующиеРеквизиты, УдаляемыеРеквизиты = Неопределено) Экспорт
	
	Если УдаляемыеРеквизиты = Неопределено Тогда 
		УдаляемыеРеквизиты = Новый Массив;
	КонецЕсли;
	
	Для Каждого Реквизит Из ДобавляемыеРеквизиты Цикл
		Если СуществующиеРеквизиты.Найти(?(ЗначениеЗаполнено(Реквизит.Путь), Реквизит.Путь + ".", "") + Реквизит.Имя) <> Неопределено 
			И УдаляемыеРеквизиты.Найти(?(ЗначениеЗаполнено(Реквизит.Путь), Реквизит.Путь + ".", "") + Реквизит.Имя) = Неопределено Тогда
			УдаляемыеРеквизиты.Добавить(?(ЗначениеЗаполнено(Реквизит.Путь), Реквизит.Путь + ".", "") + Реквизит.Имя);
		КонецЕсли;					
	КонецЦикла;		
	
	Форма.ИзменитьРеквизиты(ДобавляемыеРеквизиты, УдаляемыеРеквизиты);
	
КонецПроцедуры

Процедура УдалитьПодчиненныеЭлементыГруппы(Форма, ГруппаФормы) Экспорт 
	
	ЭлементыДляУдаления = Новый Массив;
	Для Каждого Элемент Из ГруппаФормы.ПодчиненныеЭлементы Цикл
		ЭлементыДляУдаления.Добавить(Элемент);
	КонецЦикла;
	
	Для Каждого Элемент Из ЭлементыДляУдаления Цикл
		Форма.Элементы.Удалить(Элемент);
	КонецЦикла;
	
КонецПроцедуры

// Предназначена для использования в ОбщегоНазначенияПереопределяемый.ЗаполнитьТаблицуПереименованияОбъектовМетаданных.
//
// Заполняет переименования тех объектов метаданных, которые невозможно
// автоматически найти по типу, но ссылки на которые требуется сохранять
// в базе данных (например: подсистемы, роли).
//
// Подробнее: см. ОбщегоНазначения.ДобавитьПереименование().
//
Процедура ЗаполнитьТаблицуПереименованияОбъектовМетаданных(Итог) Экспорт
	
	
КонецПроцедуры

Процедура ЗаполнитьПользовательскиеПоляВариантаОтчета(КлючВарианта, КоллекцияПользовательскихПолей) Экспорт
	
		
КонецПроцедуры

Процедура УстановитьОтборВариантаОтчета(КлючВарианта, НастройкиОтчета) Экспорт
	
КонецПроцедуры

Процедура ПроверитьВозможностьСменыГоловнойОрганизации(Организация, Отказ) Экспорт
	
КонецПроцедуры

///////////////////////////////////////////////////////////////////////////////
// Идентифицируемые объекты

// Возвращает представление объекта метаданных
// Поддерживается получение следующих видов представлений 
//		РасширенноеПредставлениеОбъекта
//		ПредставлениеОбъекта
//		РасширенноеПредставлениеСписка
//		ПредставлениеСписка
Функция ПредставлениеМетаданных(ОбъектМетаданных, ВидПредставления) Экспорт
	Если ВидПредставления = "РасширенноеПредставлениеОбъекта" Тогда
		Если ЗначениеЗаполнено(ОбъектМетаданных.РасширенноеПредставлениеОбъекта) Тогда
			Возврат ОбъектМетаданных.РасширенноеПредставлениеОбъекта;
		ИначеЕсли ЗначениеЗаполнено(ОбъектМетаданных.ПредставлениеОбъекта) Тогда
			Возврат ОбъектМетаданных.ПредставлениеОбъекта;
		Иначе
			Возврат ОбъектМетаданных.Синоним;
		КонецЕсли;
	ИначеЕсли ВидПредставления = "ПредставлениеОбъекта" Тогда
		Если ЗначениеЗаполнено(ОбъектМетаданных.ПредставлениеОбъекта) Тогда
			Возврат ОбъектМетаданных.ПредставлениеОбъекта;
		Иначе
			Возврат ОбъектМетаданных.Синоним;
		КонецЕсли;
	ИначеЕсли ВидПредставления = "РасширенноеПредставлениеСписка" Тогда
		Если ЗначениеЗаполнено(ОбъектМетаданных.РасширенноеПредставлениеСписка) Тогда
			Возврат ОбъектМетаданных.РасширенноеПредставлениеСписка;
		ИначеЕсли ЗначениеЗаполнено(ОбъектМетаданных.ПредставлениеСписка) Тогда
			Возврат ОбъектМетаданных.ПредставлениеСписка;
		Иначе
			Возврат ОбъектМетаданных.Синоним;
		КонецЕсли;
	ИначеЕсли ВидПредставления = "ПредставлениеСписка" Тогда
		Если ЗначениеЗаполнено(ОбъектМетаданных.ПредставлениеСписка) Тогда
			Возврат ОбъектМетаданных.ПредставлениеСписка;
		Иначе
			Возврат ОбъектМетаданных.Синоним;
		КонецЕсли;
	Иначе
		Возврат ОбъектМетаданных.Синоним;
	КонецЕсли;
				
КонецФункции

/////////////////////////////////////
// Работа с потоками XML

// Создает и возвращает объект ЗаписьXML, для создания XML документа
Функция СоздатьПотокXML(ИмяФайла = Неопределено, Кодировка  = "windows-1251") Экспорт	
	ПотокXML = Новый ЗаписьXML();
	
	ПотокXML.УстановитьСтроку(Кодировка);
	ПотокXML.Отступ = Истина;
	Если ИмяФайла <> Неопределено Тогда
		ПотокXML.ОткрытьФайл(ИмяФайла, Кодировка);
	КонецЕсли;
	
	ПотокXML.ЗаписатьОбъявлениеXML();
	
	Возврат ПотокXML;
	
КонецФункции

// Сохраняет документ XML  на диск и закрывает запись XML
Функция ЗаписатьПотокXML(ПотокXML) Экспорт
	Возврат ПотокXML.Закрыть();	
КонецФункции

/////////////////////////////////////
// Работа с деревом XML

// КОМПОЗИЦИЯ ДЕРЕВА

// Создает объект дерево значений, представляющее XML файл
Функция СоздатьДеревоXML() Экспорт	
	НовоеДеревоXML = Новый ДеревоЗначений;
	НовоеДеревоXML.Колонки.Добавить("Имя",      Новый ОписаниеТипов("Строка"));
	НовоеДеревоXML.Колонки.Добавить("Значение", Новый ОписаниеТипов("Строка"));
	
	Возврат НовоеДеревоXML;
	
КонецФункции

Функция ДобавитьУзелВДеревоXML(Ветка, Имя, Значение, СписокАтрибутов = Неопределено, ТипДанных = "", ЗначениеЗаписи = Неопределено) Экспорт
	ПустаяДата = Дата(1,1,1);
	
	НовыйУзел = Ветка.Строки.Добавить();
	НовыйУзел.Имя = Имя;
	НовыйУзел.Значение = Значение;
	
	Если СписокАтрибутов <> Неопределено Тогда
		ВеткаАтрибутов = НовыйУзел.Строки.Добавить();
		ВеткаАтрибутов.Имя = "АтрибутыXMLУзла";
		ВеткаАтрибутов.Значение = Неопределено;
		
		Для Каждого ЭлементСпискаАтрибутов Из СписокАтрибутов Цикл
			ЛистАтрибутов = ВеткаАтрибутов.Строки.Добавить();
			ЛистАтрибутов.Имя = ЭлементСпискаАтрибутов.Ключ;
			// доделать до правильного преобразования
			ЛистАтрибутов.Значение = Строка(ЭлементСпискаАтрибутов.Значение);
		КонецЦикла;
		
	КонецЕсли;
	
	Если ТипДанных = "СТРОКА" И ЗначениеЗаписи <> Неопределено Тогда
		ЗначениеЗаписи = "";
	ИначеЕсли ТипДанных = "ЧИСЛО" И ЗначениеЗаписи <> Неопределено Тогда
		Если ТипЗнч(ЗначениеЗаписи) = Тип("Число") Тогда
			ЗначениеЗаписи = 0;	
		Иначе
			ЗначениеЗаписи = "";
		КонецЕсли;	
	ИначеЕсли ТипДанных = "ДАТА" И ЗначениеЗаписи <> Неопределено Тогда
		ЗначениеЗаписи = ПустаяДата;	
	КонецЕсли;	
	
	Возврат НовыйУзел;
	
КонецФункции

// записывает значения из дерева значение в поток связанный с файлом XML
Процедура ЗаписатьУзелДереваXMLВXML(СтрокаДерева, ПотокXML, ПрефиксПространстваИмен = Неопределено, URIПространстваИмен = Неопределено) Экспорт	
	Если ТипЗнч(СтрокаДерева) = Тип("СтрокаДереваЗначений") Тогда
		
		Если НЕ ПустаяСтрока(СтрокаДерева.Имя) Тогда
			
			ПотокXML.ЗаписатьНачалоЭлемента(СтрЗаменить(СтрокаДерева.Имя,"__","-"));
			Если ПрефиксПространстваИмен <> Неопределено И URIПространстваИмен <> Неопределено Тогда
				ПотокXML.ЗаписатьСоответствиеПространстваИмен(ПрефиксПространстваИмен, URIПространстваИмен);
			КонецЕсли;
			СписокАтрибутов = СтрокаДерева.Строки.Найти("АтрибутыXMLУзла", "Имя", Ложь);
			
			Если СписокАтрибутов <> Неопределено Тогда
				Для каждого СтрокаСАтрибутом Из СписокАтрибутов.Строки Цикл
					ПотокXML.ЗаписатьАтрибут(СтрокаСАтрибутом.Имя, СтрокаСАтрибутом.Значение);
				КонецЦикла;
			КонецЕсли;
			
			ПотокXML.ЗаписатьТекст(?(СтрокаДерева.Значение = "00.00.0000", "", СтрокаДерева.Значение));
			
		КонецЕсли;
		
	КонецЕсли;
	
	Для каждого Лист из СтрокаДерева.Строки Цикл
		Если Лист.Имя = "АтрибутыXMLУзла" Тогда
			Продолжить;
		КонецЕсли;
		ЗаписатьУзелДереваXMLВXML(Лист, ПотокXML, ПрефиксПространстваИмен, URIПространстваИмен);
	КонецЦикла;
	
	Если ТипЗнч(СтрокаДерева) = Тип("СтрокаДереваЗначений") Тогда
		Если НЕ ПустаяСтрока(СтрокаДерева.Имя) Тогда
			ПотокXML.ЗаписатьКонецЭлемента();
		КонецЕсли;
	КонецЕсли;
	
КонецПроцедуры

// ИМПОРТ / ЭКСПОРТ ДЕРЕВА

Функция ЗагрузитьXMLВДокументDOM(ТекстXML) Экспорт
	ЧтениеXML = Новый ЧтениеXML;
	ЧтениеXML.УстановитьСтроку(ТекстXML);
	
	ПостроительDOM = Новый ПостроительDOM;
	
	ДокументDOM = ПостроительDOM.Прочитать(ЧтениеXML);
	
	Возврат ДокументDOM;
КонецФункции	

Функция ЗагрузитьФорматНабораЗаписей(Знач ДеревоФормата, Знач ИмяНабораЗаписей, НомерВыбираемогоЭлемента = 1) Экспорт	
	ФорматНабора = Новый Структура();
	
	УзлыФормата = ДеревоФормата.ДочерниеУзлы[0].ПолучитьЭлементыПоИмени(ИмяНабораЗаписей)[0].ДочерниеУзлы;
	
	Для Каждого УзелФормата Из УзлыФормата Цикл
		
		ФорматЗаписи = Новый Структура("ТипДанных, Размер, РазрядностьДробнойЧасти, Поля, Значение, ЭлементНеОбязателен, ТипЭлемента, НеВыводитьВФайл");
		
		// имя записи хранится в 4 колонке
		ИмяЗаписи =  УзелФормата.ДочерниеУзлы[3].ТекстовоеСодержимое;
		
		// тип данных хранится во 2 колонке
		ТипДанных = ВРег(УзелФормата.ДочерниеУзлы[1].ТекстовоеСодержимое);
		
		// Признак обязательности элемента хранится в 5-й колонке	
		ЭлементНеОбязателен = (ВРег(УзелФормата.ДочерниеУзлы[4].ТекстовоеСодержимое) = "НЕ ОБЯЗАТЕЛЬНО" Или ВРег(УзелФормата.ДочерниеУзлы[4].ТекстовоеСодержимое) = "Н");
		
		Если УзелФормата.ДочерниеУзлы.Количество() = 7 И УзелФормата.ДочерниеУзлы[6].ИмяУзла = "ТипЭлемента" Тогда
			ТипЭлемента = ВРег(УзелФормата.ДочерниеУзлы[6].ТекстовоеСодержимое);
		Иначе
			ТипЭлемента = "С";
		КонецЕсли;	
		
		Если ТипДанных = "" Тогда// Если тип данных не задан, то встретили строку - группировку
			Продолжить;
		КонецЕсли; 
		
		ПозицияРазделителя = Найти(ТипДанных,"/");
		Если ПозицияРазделителя <> 0 Тогда
			ТипДанных = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(ТипДанных, "/")[НомерВыбираемогоЭлемента-1];
		КонецЕсли;
		
		ПозицияРазделителя = Найти(ИмяЗаписи,"/");
		Если ПозицияРазделителя <> 0 Тогда
			ИмяЗаписи = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(ИмяЗаписи, "/")[НомерВыбираемогоЭлемента-1];
		КонецЕсли;
		
		ФорматЗаписи.ТипДанных =  ТипДанных;
		ФорматЗаписи.ЭлементНеОбязателен = ЭлементНеОбязателен;
		ФорматЗаписи.ТипЭлемента = ТипЭлемента;
		ФорматЗаписи.НеВыводитьВФайл = Ложь;
		// размер хранится в 3 колонке
		СтрРазмерПоля =  УзелФормата.ДочерниеУзлы[2].ТекстовоеСодержимое;
		
		Если ФорматЗаписи.ТипДанных = "КОНСТАНТА" Тогда
			
			// в колонке "размер" должно указываться значение константы
			ФорматЗаписи.Значение = СтрРазмерПоля;
			
		ИначеЕсли ФорматЗаписи.ТипДанных = "ЧИСЛО" Тогда
			
			ПозицияТочки = Найти(СтрРазмерПоля,".");
			Если ПозицияТочки<>0 Тогда
				ФорматЗаписи.Размер = Число(Лев(СтрРазмерПоля,ПозицияТочки-1));
				ФорматЗаписи.РазрядностьДробнойЧасти = Число(Сред(СтрРазмерПоля,ПозицияТочки+1));
			Иначе	
				ФорматЗаписи.Размер = Число(СтрРазмерПоля);
				ФорматЗаписи.РазрядностьДробнойЧасти = 0;
			КонецЕсли;	 
			
			ФорматЗаписи.Значение = 0;
			
		ИначеЕсли ФорматЗаписи.ТипДанных = "СТРОКА" Тогда
			
			ФорматЗаписи.Размер = Число(СтрРазмерПоля);
			
			ФорматЗаписи.Значение = "";
			
		ИначеЕсли ФорматЗаписи.ТипДанных = "ДАТА" Тогда
			
			ФорматЗаписи.Значение = Дата('00010101');
			
		ИначеЕсли ФорматЗаписи.ТипДанных = "ТАБЛИЦА" Тогда	
			
			// Имя области-описания формата полей таблицы или структуры хранится в колонке размер.
			ФорматЗаписи.Поля = ПолучитьФорматЗаписиИзДереваФормата(ДеревоФормата, СтрРазмерПоля);
			ФорматЗаписи.Значение = Новый ТаблицаЗначений;
			
			Для каждого Поле Из ФорматЗаписи.Поля Цикл
				
				Если Поле.ТипДанных = "ЧИСЛО" Тогда
					ОписаниеТиповПоля = Новый ОписаниеТипов("Число", Новый КвалификаторыЧисла(Поле.Размер, Поле.РазрядностьДробнойЧасти));
				ИначеЕсли Поле.ТипДанных = "СТРОКА" Тогда
					ОписаниеТиповПоля = Новый ОписаниеТипов("Строка", , Новый КвалификаторыСтроки(Поле.Размер));
				ИначеЕсли Поле.ТипДанных = "ДАТА" Тогда
					ОписаниеТиповПоля = Новый ОписаниеТипов("Дата", , , Новый КвалификаторыДаты(ЧастиДаты.Дата));
				КонецЕсли; 
				ФорматЗаписи.Значение.Колонки.Добавить(Поле.ИмяПоля, ОписаниеТиповПоля);
				
			КонецЦикла; 
				
		ИначеЕсли ФорматЗаписи.ТипДанных = "СТРУКТУРА" Тогда	
			
			ПозицияРазделителя = Найти(ИмяЗаписи,"/");
			Если ПозицияРазделителя <> 0 Тогда
				ИмяЗаписи = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(ИмяЗаписи, "/")[НомерВыбираемогоЭлемента-1]
			КонецЕсли;
			ПозицияРазделителя = Найти(СтрРазмерПоля,"/");
			Если ПозицияРазделителя <> 0 Тогда
				СтрРазмерПоля = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(СтрРазмерПоля, "/")[НомерВыбираемогоЭлемента-1]
			КонецЕсли;
			
			// Имя области-описания формата полей таблицы или структуры хранится в колонке размер.
			ФорматЗаписи.Поля = ПолучитьФорматЗаписиИзДереваФормата(ДеревоФормата, СтрРазмерПоля);
			ФорматЗаписи.Значение = Новый Структура;
			Для каждого Поле Из ФорматЗаписи.Поля Цикл
				
				ПустоеЗначениеПоля = Неопределено;
				Если Поле.ТипДанных = "ЧИСЛО" Тогда
					ПустоеЗначениеПоля = 0;
				ИначеЕсли Поле.ТипДанных = "ДАТА" Тогда
					ПустоеЗначениеПоля = Дата('00010101');
				Иначе
					ПустоеЗначениеПоля = "";
				КонецЕсли; 
				
				ФорматЗаписи.Значение.Вставить(Поле.ИмяПоля, ПустоеЗначениеПоля);
				
			КонецЦикла; 
			
		ИначеЕсли ФорматЗаписи.ТипДанных = "НАБОРЗАПИСЕЙ" Тогда
			
			// Имя набора записей хранится в третьей колонке
			ИмяНабора = УзелФормата.ДочерниеУзлы[2].ТекстовоеСодержимое;
			ПозицияРазделителя = Найти(ИмяНабора,"/");
			Если ПозицияРазделителя <> 0 Тогда
				ИмяНабора = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(ИмяНабора, "/")[НомерВыбираемогоЭлемента-1]
			КонецЕсли;
			ПозицияРазделителя = Найти(ИмяЗаписи,"/");
			Если ПозицияРазделителя <> 0 Тогда
				ИмяЗаписи = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(ИмяЗаписи, "/")[НомерВыбираемогоЭлемента-1]
			КонецЕсли;
			ФорматЗаписи.Значение = ЗагрузитьФорматНабораЗаписей(ДеревоФормата, ИмяНабора, НомерВыбираемогоЭлемента);
			
		КонецЕсли;	
		
		ФорматНабора.Вставить(ИмяЗаписи, ФорматЗаписи);
		
	КонецЦикла;	
	
	Возврат ФорматНабора;
		
КонецФункции

// добавляет реквизит в дерево значений, представляющее XML файл
Процедура ДобавитьИнформациюВДерево(ДеревоВыгрузки, НаборЗаписей) Экспорт	
		
	ПустаяДата = Дата(1,1,1);
	
	Для каждого ЭлементНабора Из НаборЗаписей Цикл
		ИмяЗаписи = ЭлементНабора.Ключ;
				
		Запись = ЭлементНабора.Значение;
		
		Если Запись.НеВыводитьВФайл Тогда 
			Запись.НеВыводитьВФайл = Ложь;
			Продолжить;
		КонецЕсли;	
	
		ТипДанных = Запись.ТипДанных;
		Если ТипДанных = "КОНСТАНТА" Тогда
			
			ДобавитьУзелВДеревоXML(ДеревоВыгрузки, ИмяЗаписи, Запись.Значение, , ТипДанных, Запись.Значение);
			
		ИначеЕсли ТипДанных = "ЧИСЛО" Тогда
			
			// Для проверок
			// Запись.Размер 
			// Запись.РазрядностьДробнойЧасти.
			ДобавитьУзелВДеревоXML(ДеревоВыгрузки, ИмяЗаписи, Формат(Запись.Значение,"ЧЦ=" + Запись.Размер + "; ЧДЦ=" + Запись.РазрядностьДробнойЧасти + "; ЧРД=.; ЧН=; ЧГ=0"), , ТипДанных, Запись.Значение);
			Запись.НеВыводитьВФайл = Ложь;
		ИначеЕсли ТипДанных = "СТРОКА" Тогда
			
			// Для проверок
			// Запись.Размер. 
			
			ДобавитьУзелВДеревоXML(ДеревоВыгрузки, ИмяЗаписи, Запись.Значение, ,ТипДанных, Запись.Значение);
			
		ИначеЕсли ТипДанных = "ДАТА" Тогда
			
			ДобавитьУзелВДеревоXML(ДеревоВыгрузки, ИмяЗаписи, ?(Запись.Значение = ПустаяДата,"00.00.0000", Формат(Запись.Значение,"ДФ=dd.MM.yyyy")), ,ТипДанных, Запись.Значение);
			
		ИначеЕсли ТипДанных = "ТАБЛИЦА" Тогда	
			
			ПроверятьНеобязательныеПоля = Ложь;
			Для каждого Поле Из Запись.Поля Цикл
				ПроверятьНеобязательныеПоля = Поле.ЭлементНеОбязателен;
				Если ПроверятьНеобязательныеПоля Тогда
					Прервать;
				КонецЕсли;
			КонецЦикла; 
			
			Для каждого СтрокаТЗ Из Запись.Значение Цикл
				
				
				ВыводитьНеобязательныеПоля = Ложь;
				Если ПроверятьНеобязательныеПоля Тогда
					Для каждого Поле Из Запись.Поля Цикл
						Если Поле.ЭлементНеОбязателен Тогда
							ВыводитьНеобязательныеПоля = ЗначениеЗаполнено(СтрокаТЗ[Поле.ИмяПоля]);
							Если ВыводитьНеобязательныеПоля Тогда
								Прервать;
							КонецЕсли;
						КонецЕсли;
					КонецЦикла; 
				КонецЕсли;
				
				Атрибуты = Новый Структура;
				Для каждого Поле Из Запись.Поля Цикл
					
					Если Поле.ЭлементНеОбязателен И Не ВыводитьНеобязательныеПоля Тогда
						Продолжить;
					КонецЕсли;
					
					Данные = СтрокаТЗ[Поле.ИмяПоля];
					
					Если Поле.ТипДанных = "ЧИСЛО" Тогда
						Данные = Формат(Данные,"ЧЦ=" + Поле.Размер + "; ЧДЦ=" + Поле.РазрядностьДробнойЧасти + "; ЧРД=.; ЧН=; ЧГ=0")
					ИначеЕсли Поле.ТипДанных = "ДАТА" Тогда
						Если Не ЗначениеЗаполнено(Данные) Тогда
							Данные = ""
						Иначе
							Данные = Формат(Данные,"ДФ=dd.MM.yyyy");
						КонецЕсли;
					КонецЕсли;
					
					Если Поле.ТипЭлемента = "А" И НЕ Поле.НеВыводитьВФайл Тогда
						Атрибуты.Вставить(Поле.ИмяПоля, Данные);
					КонецЕсли;
					
				КонецЦикла;
				
				ВеткаСтрокиТЗ = ДобавитьУзелВДеревоXML(ДеревоВыгрузки, ИмяЗаписи, "", Атрибуты);
				
				Для каждого Поле Из Запись.Поля Цикл
					
					Если Поле.ТипЭлемента = "А" Тогда
						Поле.НеВыводитьВФайл = Ложь;
						Продолжить;
					КонецЕсли;
					
					Если Поле.НеВыводитьВФайл Тогда
						Поле.НеВыводитьВФайл = Ложь;
						Продолжить;
					КонецЕсли;	
					
					Если Поле.ЭлементНеОбязателен И Не ВыводитьНеобязательныеПоля Тогда
						Продолжить;
					КонецЕсли;
					
					ДобавитьИнформациюВДерево(ВеткаСтрокиТЗ, СтрокаТЗ[Поле.ИмяПоля])
					
				КонецЦикла;
				
			КонецЦикла; 
			
		ИначеЕсли ТипДанных = "СТРУКТУРА" Тогда	
			МассивДанных = Новый Массив;
			Атрибуты = Новый Структура;
			Для каждого Поле Из Запись.Поля Цикл
				
				Данные = Запись.Значение[Поле.ИмяПоля];
				
				Если Поле.ЭлементНеОбязателен И Не ЗначениеЗаполнено(Данные) Тогда
					Продолжить;
				КонецЕсли;
				
				ПустоеЗначение = "";
				Если Поле.ТипДанных = "ЧИСЛО" Тогда
					Если ТипЗнч(Данные) = Тип("Число") Тогда
						ПустоеЗначение = 0;	
					КонецЕсли;	
					Данные = Формат(Данные,"ЧЦ=" + Поле.Размер + "; ЧДЦ=" + Поле.РазрядностьДробнойЧасти + "; ЧРД=.; ЧН=; ЧГ=0");
				ИначеЕсли Поле.ТипДанных = "ДАТА" Тогда
					Если Не ЗначениеЗаполнено(Данные) Тогда
						Данные = ""
					Иначе
						Данные = Формат(Данные,"ДФ=dd.MM.yyyy");
						ПустоеЗначение = '00010101';
					КонецЕсли;
				КонецЕсли;
				
				Если Поле.ТипЭлемента = "А" И НЕ Поле.НеВыводитьВФайл  Тогда
					Атрибуты.Вставить(Поле.ИмяПоля, Данные);
				ИначеЕсли НЕ Поле.НеВыводитьВФайл Тогда 
					СтруктураДанных = Новый Структура("ИмяПоля, Значение, Данные, ТипДанных", Поле.ИмяПоля, Запись.Значение[Поле.ИмяПоля], Данные, Поле.ТипДанных);
					МассивДанных.Добавить(СтруктураДанных);
				КонецЕсли;
				Поле.НеВыводитьВФайл = Ложь;
				Запись.Значение[Поле.ИмяПоля] = ПустоеЗначение;	
			КонецЦикла; 
				
			ВеткаСтруктуры = ДобавитьУзелВДеревоXML(ДеревоВыгрузки, ИмяЗаписи, "", Атрибуты);
			
			Для Каждого Поле Из МассивДанных Цикл
				ДобавитьУзелВДеревоXML(ВеткаСтруктуры, Поле.ИмяПоля, Поле.Данные, ,Поле.ТипДанных, Поле.Данные);
            КонецЦикла;

		ИначеЕсли ТипДанных = "НАБОРЗАПИСЕЙ" Тогда
			
			Значение = Запись.Значение;
			
			Атрибуты = Новый Структура;
			Для каждого Поле Из Значение Цикл
				Если Поле.Значение.ТипЭлемента = "А" И НЕ Поле.Значение.НеВыводитьВФайл  Тогда
					Данные = Поле.Значение.Значение;
					Если Поле.Значение.ТипДанных = "ЧИСЛО" Тогда
						Данные = Формат(Данные,"ЧЦ=" + Поле.Значение.Размер + "; ЧДЦ=" + Поле.Значение.РазрядностьДробнойЧасти + "; ЧРД=.; ЧН=; ЧГ=0")
					ИначеЕсли Поле.Значение.ТипДанных = "ДАТА" Тогда
						Если Не ЗначениеЗаполнено(Данные) Тогда
							Данные = ""
						Иначе
							Данные = Формат(Данные,"ДФ=dd.MM.yyyy");
						КонецЕсли;
					КонецЕсли;
					Атрибуты.Вставить(Поле.Ключ, Данные);
					Значение.Удалить(Поле.Ключ);
				КонецЕсли;
			КонецЦикла;
			
			ДобавитьИнформациюВДерево(ДобавитьУзелВДеревоXML(ДеревоВыгрузки, ИмяЗаписи, "", Атрибуты), Значение);
			
		КонецЕсли;	
		
	КонецЦикла; 
	
КонецПроцедуры


////////////////////////////////////////////////////////////////////////////////
// Процедуры и функции работы с отчетами

// Функция возвращает текст запроса временной таблицы периодов с заданной периодичностью.
//
// Параметры:
//		ОписаниеНачалаИнтервала - Строка - имя параметра в тексте запроса ("&НачалоПериода", "ДАТАВРЕМЯ(2013, 1, 1)")
//							- Дата, начальная дата интервала, за который формируются периоды.
//		ОписаниеОкончанияИнтервала - Строка - имя параметра в тексте запроса,
//							- Дата, конечная дата интервала, за который формируются периоды.
//		Периодичность - Строка - периодичность, на которую будет разбиваться интервал.
//			По умолчанию <МЕСЯЦ>. Может принимать значения:	ГОД, КВАРТАЛ, МЕСЯЦ, ДЕНЬ.
//		ИмяПоляПериод - наименование колонки во временной таблице периодов. 
//			По умолчанию <Период>.
//		ИмяВТ - Строка - наименование временной таблицы периодов, по умолчанию <ВТПериоды>.
//		ИспользоватьКонецПериода - Булево - необязательный, по умолчанию - Ложь. 
//			Определяет необходимость использовать в качестве значения последнюю секунду периода. 
//			То есть если Истина, то для периодичности месяц, 
//			временная таблица будет заполнена датами конца каждого месяца, 
//			и если ложь, то - датами начала.
//
Функция ТекстЗапросаВТПериоды(Знач ОписаниеНачалаИнтервала, Знач ОписаниеОкончанияИнтервала, Периодичность = "МЕСЯЦ", ИмяПоляПериод = "Период", ИмяВТ = "ВТПериоды", ИспользоватьКонецПериода = Ложь) Экспорт
	
	ТекстЗапроса =
	"ВЫБРАТЬ
	|	0 КАК Цифра
	|ПОМЕСТИТЬ Цифры
	|
	|ОБЪЕДИНИТЬ ВСЕ
	|
	|ВЫБРАТЬ
	|	1
	|
	|ОБЪЕДИНИТЬ ВСЕ
	|
	|ВЫБРАТЬ
	|	2
	|
	|ОБЪЕДИНИТЬ ВСЕ
	|
	|ВЫБРАТЬ
	|	3
	|
	|ОБЪЕДИНИТЬ ВСЕ
	|
	|ВЫБРАТЬ
	|	4
	|
	|ОБЪЕДИНИТЬ ВСЕ
	|
	|ВЫБРАТЬ
	|	5
	|
	|ОБЪЕДИНИТЬ ВСЕ
	|
	|ВЫБРАТЬ
	|	6
	|
	|ОБЪЕДИНИТЬ ВСЕ
	|
	|ВЫБРАТЬ
	|	7
	|
	|ОБЪЕДИНИТЬ ВСЕ
	|
	|ВЫБРАТЬ
	|	8
	|
	|ОБЪЕДИНИТЬ ВСЕ
	|
	|ВЫБРАТЬ
	|	9
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	ВЫБОР
	|		КОГДА &НачалоПериодаИнтервала <> ДАТАВРЕМЯ(1, 1, 1)
	|			ТОГДА НАЧАЛОПЕРИОДА(ДОБАВИТЬКДАТЕ(&НачалоПериодаИнтервала, ЧАС, Цифры.Цифра + ЕСТЬNULL(Цифры10.Цифра, 0) * 10 + ЕСТЬNULL(Цифры100.Цифра, 0) * 100 + ЕСТЬNULL(Цифры1000.Цифра, 0) * 1000 + ЕСТЬNULL(Цифры10000.Цифра, 0) * 10000 + ЕСТЬNULL(Цифры100000.Цифра, 0) * 100000), ЧАС)
	|		ИНАЧЕ НАЧАЛОПЕРИОДА(ДОБАВИТЬКДАТЕ(ДАТАВРЕМЯ(1980, 1, 1), ЧАС, Цифры.Цифра + ЕСТЬNULL(Цифры10.Цифра, 0) * 10 + ЕСТЬNULL(Цифры100.Цифра, 0) * 100 + ЕСТЬNULL(Цифры1000.Цифра, 0) * 1000 + ЕСТЬNULL(Цифры10000.Цифра, 0) * 10000 + ЕСТЬNULL(Цифры100000.Цифра, 0) * 100000), ЧАС)
	|	КОНЕЦ КАК ИмяПоляПериод
	|ПОМЕСТИТЬ ИмяВТ
	|ИЗ
	|	Цифры КАК Цифры
	|		ЛЕВОЕ СОЕДИНЕНИЕ Цифры КАК Цифры10
	|		ПО (РАЗНОСТЬДАТ(&НачалоПериодаИнтервала, &ОкончаниеПериодаИнтервала, ЧАС) > 9)
	|		ЛЕВОЕ СОЕДИНЕНИЕ Цифры КАК Цифры100
	|		ПО (РАЗНОСТЬДАТ(&НачалоПериодаИнтервала, &ОкончаниеПериодаИнтервала, ЧАС) > 99)
	|		ЛЕВОЕ СОЕДИНЕНИЕ Цифры КАК Цифры1000
	|		ПО (РАЗНОСТЬДАТ(&НачалоПериодаИнтервала, &ОкончаниеПериодаИнтервала, ЧАС) > 999)
	|		ЛЕВОЕ СОЕДИНЕНИЕ Цифры КАК Цифры10000
	|		ПО (РАЗНОСТЬДАТ(&НачалоПериодаИнтервала, &ОкончаниеПериодаИнтервала, ЧАС) > 9999)
	|		ЛЕВОЕ СОЕДИНЕНИЕ Цифры КАК Цифры100000
	|		ПО (РАЗНОСТЬДАТ(&НачалоПериодаИнтервала, &ОкончаниеПериодаИнтервала, ЧАС) > 99999)
	|ГДЕ
	|	ВЫБОР
	|			КОГДА &НачалоПериодаИнтервала <> ДАТАВРЕМЯ(1, 1, 1)
	|				ТОГДА НАЧАЛОПЕРИОДА(ДОБАВИТЬКДАТЕ(&НачалоПериодаИнтервала, ЧАС, Цифры.Цифра + ЕСТЬNULL(Цифры10.Цифра, 0) * 10 + ЕСТЬNULL(Цифры100.Цифра, 0) * 100 + ЕСТЬNULL(Цифры1000.Цифра, 0) * 1000 + ЕСТЬNULL(Цифры10000.Цифра, 0) * 10000 + ЕСТЬNULL(Цифры100000.Цифра, 0) * 100000), ЧАС)
	|			ИНАЧЕ НАЧАЛОПЕРИОДА(ДОБАВИТЬКДАТЕ(ДАТАВРЕМЯ(1980, 1, 1), ЧАС, Цифры.Цифра + ЕСТЬNULL(Цифры10.Цифра, 0) * 10 + ЕСТЬNULL(Цифры100.Цифра, 0) * 100 + ЕСТЬNULL(Цифры1000.Цифра, 0) * 1000 + ЕСТЬNULL(Цифры10000.Цифра, 0) * 10000 + ЕСТЬNULL(Цифры100000.Цифра, 0) * 100000), ЧАС)
	|		КОНЕЦ МЕЖДУ &НачалоИнтервала И &ОкончаниеИнтервала
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|УНИЧТОЖИТЬ Цифры";
	
	Если ВРег(Периодичность) <> "ГОД"
		И ВРег(Периодичность) <> "КВАРТАЛ"
		И ВРег(Периодичность) <> "МЕСЯЦ"
		И ВРег(Периодичность) <> "ДЕНЬ" Тогда
		
		ВызватьИсключение НСтр("ru='Невозможно сформировать запрос с переданными параметрами.'");
		
	КонецЕсли;
	
	Если ИспользоватьКонецПериода Тогда
		ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "НАЧАЛОПЕРИОДА", "КОНЕЦПЕРИОДА");
	КонецЕсли;
	
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "ЧАС", Периодичность);
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "ПОМЕСТИТЬ ИмяВТ", "ПОМЕСТИТЬ " + ИмяВТ);
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "КАК ИмяПоляПериод", "КАК " + ИмяПоляПериод);
	
	Если ИспользоватьКонецПериода Тогда
		НачалоПериодаИнтервалаПредставление = "КОНЕЦПЕРИОДА(&НачалоИнтервала, " + ВРег(Периодичность) + ")";
		ОкончаниеПериодаИнтервалаПредставление = "КОНЕЦПЕРИОДА(&ОкончаниеИнтервала, " + ВРег(Периодичность) + ")";
	Иначе
		НачалоПериодаИнтервалаПредставление = "НАЧАЛОПЕРИОДА(&НачалоИнтервала, " + ВРег(Периодичность) + ")";
		ОкончаниеПериодаИнтервалаПредставление = "НАЧАЛОПЕРИОДА(&ОкончаниеИнтервала, " + ВРег(Периодичность) + ")";
	КонецЕсли;
	
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&НачалоПериодаИнтервала", НачалоПериодаИнтервалаПредставление);
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&ОкончаниеПериодаИнтервала", ОкончаниеПериодаИнтервалаПредставление);
	
	
	Если ТипЗнч(ОписаниеНачалаИнтервала) = Тип("Строка") Тогда
		НачалоИнтервалаПредставление = ОписаниеНачалаИнтервала;
	Иначе
		НачалоИнтервалаПредставление = "ДАТАВРЕМЯ(" + Формат(ОписаниеНачалаИнтервала, "ДФ='гггг, М, д, Ч, м, с'; ДП=") + ")";
	КонецЕсли;
	
	Если ТипЗнч(ОписаниеОкончанияИнтервала) = Тип("Строка") Тогда
		ОкончаниеИнтервалаПредставление = ОписаниеОкончанияИнтервала;
	Иначе
		ОкончаниеИнтервалаПредставление = "ДАТАВРЕМЯ(" + Формат(ОписаниеОкончанияИнтервала, "ДФ='гггг, М, д, Ч, м, с'; ДП=") + ")";
	КонецЕсли;
	
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&НачалоИнтервала", НачалоИнтервалаПредставление);
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&ОкончаниеИнтервала", ОкончаниеИнтервалаПредставление);
	
	Возврат ТекстЗапроса;
	
КонецФункции

// Формирует временную таблицу периодов с заданной периодичностью и текстом запроса,
// описание которого находится в Функции <ТекстЗапросаВТПериоды>.
// Создает в МенеджерВременныхТаблиц временную таблицу с именем <ИмяВТ> 
// и периодичностью <Периодичность>	
// за интервал с <НачалоИнтервала> по <ОкончаниеИнтервала>.
//
Процедура СоздатьВТПериоды(МенеджерВременныхТаблиц, НачалоИнтервала, ОкончаниеИнтервала, Периодичность = "МЕСЯЦ", ИмяПоляПериод = "Период", ИмяВТ = "ВТПериоды", ИспользоватьКонецПериода = Ложь) Экспорт
	
	Если НачалоИнтервала > ОкончаниеИнтервала Тогда
		ВызватьИсключение НСтр("ru='Дата окончания не может быть меньше даты начала.'")
	КонецЕсли;
	
	Запрос = Новый Запрос;
	Запрос.МенеджерВременныхТаблиц = МенеджерВременныхТаблиц;
	Запрос.Текст = ТекстЗапросаВТПериоды(НачалоИнтервала, ОкончаниеИнтервала, Периодичность, ИмяПоляПериод, ИмяВТ, ИспользоватьКонецПериода);
	Запрос.Выполнить();
	
КонецПроцедуры

Функция СоответствиеПользовательскихПолей(ЭлементыПользовательскихПолей) Экспорт
	
	СоответствиеПользовательскихПолей = Новый Соответствие;
	
	Для каждого Элемент Из ЭлементыПользовательскихПолей Цикл
		СоответствиеПользовательскихПолей.Вставить(Элемент.Заголовок, СтрЗаменить(Элемент.ПутьКДанным,".",""));
	КонецЦикла;
	
	Возврат СоответствиеПользовательскихПолей;
	
КонецФункции

Процедура ЗаполнитьПараметрыПользовательскихПолей(Макет, Данные, СоответствиеПользовательскихПолей, ИменаЗаполняемыхПолей = "") Экспорт
	
	ЗаполняемыеПоля = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(ИменаЗаполняемыхПолей);
	
	СтруктураДанных = Новый Структура;
	Для каждого СоответствиеПользовательскогоПоля Из СоответствиеПользовательскихПолей Цикл
		
		Если ЗаполняемыеПоля.Количество() > 0
			И ЗаполняемыеПоля.Найти(СоответствиеПользовательскогоПоля.Ключ) = Неопределено Тогда
			Продолжить;
		КонецЕсли; 
		
		СтруктураДанных.Вставить(СоответствиеПользовательскогоПоля.Значение);
		
	КонецЦикла;
	
	ЗаполнитьЗначенияСвойств(СтруктураДанных, Данные);
	
	СтруктураЗначенийПользовательскихПолей = Новый Структура;
	Для каждого СоответствиеПользовательскогоПоля Из СоответствиеПользовательскихПолей Цикл
		
		Если ЗаполняемыеПоля.Количество() > 0
			И ЗаполняемыеПоля.Найти(СоответствиеПользовательскогоПоля.Ключ) = Неопределено Тогда
			Продолжить;
		КонецЕсли; 
		
		СтруктураЗначенийПользовательскихПолей.Вставить(СоответствиеПользовательскогоПоля.Ключ, СтруктураДанных[СоответствиеПользовательскогоПоля.Значение]);
		
	КонецЦикла;
	
	ЗаполнитьЗначенияСвойств(Макет.Параметры, СтруктураЗначенийПользовательскихПолей);
	
КонецПроцедуры

// Содержит настройки размещения вариантов отчетов в панели отчетов.
// Описание см. ВариантыОтчетовПереопределяемый.НастроитьВариантыОтчетов.
//
Процедура НастроитьВариантыОтчетов(Настройки) Экспорт
	
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// Процедуры и функции работы с файлами ПФР

// Процедура создает и записывает файл, содержащий сведения для отправки в ПФР.
// Параметры:
//  ИмяФайла
//  ТекстФайла.
//
Функция ЗаписатьФайлПФРНаДиск(ИмяФайла, ТекстФайла, РасширениеЗаглавнымиБуквами = Истина) Экспорт
	
	ТекстовыйДокумент = Новый ТекстовыйДокумент;
	ТекстовыйДокумент.УстановитьТекст(ТекстФайла);
	
	Если РасширениеЗаглавнымиБуквами Тогда
		ПолноеИмяФайла = ПолучитьИмяВременногоФайла("XML");
	Иначе 
		ПолноеИмяФайла = ПолучитьИмяВременногоФайла("xml");
	КонецЕсли;	
	
	ТекстовыйДокумент.Записать(ПолноеИмяФайла, КодировкаТекста.ANSI);
	
	Возврат ПолноеИмяФайла;
КонецФункции	

Процедура ЗаписатьФайлВАрхив(ВладелецФайла, Знач ИмяФайла, ТекстФайла, РасширениеЗаглавнымиБуквами = Истина) Экспорт
	УстановитьПривилегированныйРежим(Истина);
	
	ИмяОбъекта = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(ВладелецФайла.Метаданные().ПолноеИмя(), ".")[1];
	
	ПолноеИмяФайла = ЗаписатьФайлПФРНаДиск(ИмяФайла, ТекстФайла);
	
	Файл = Новый Файл(ПолноеИмяФайла);
	
	ДвоичныеДанныеФайла = Новый ДвоичныеДанные(ПолноеИмяФайла);
	
	АдресВременногоХранилищаФайла = ПоместитьВоВременноеХранилище(ДвоичныеДанныеФайла);
	
	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("ВладелецФайла", ВладелецФайла);
	
	Запрос.Текст = 
	"ВЫБРАТЬ
	|	ПрисоединенныеФайлы.Ссылка
	|ИЗ
	|	ИсточникДанных КАК ПрисоединенныеФайлы
	|ГДЕ
	|	ПрисоединенныеФайлы.ВладелецФайла = &ВладелецФайла";
	
	Запрос.Текст = СтрЗаменить(Запрос.Текст, "ИсточникДанных", "Справочник." + ИмяОбъекта + "ПрисоединенныеФайлы"); 
	
	Выборка = Запрос.Выполнить().Выбрать();
	
	Если Выборка.Следующий() Тогда 
		Если РасширениеЗаглавнымиБуквами Тогда
			Расширение = ВРег(Прав(Файл.Расширение, СтрДлина(Файл.Расширение)-1));
		Иначе
			Расширение = Прав(Файл.Расширение, СтрДлина(Файл.Расширение)-1);
		КонецЕсли;	
		
		ИнформацияОФайле = Новый Структура("ДатаМодификацииУниверсальная, АдресФайлаВоВременномХранилище, АдресВременногоХранилищаТекста, Расширение",
										Файл.ПолучитьУниверсальноеВремяИзменения(),
										АдресВременногоХранилищаФайла,
										"",
										Прав(Файл.Расширение, СтрДлина(Файл.Расширение)-1));

		
		ПрисоединенныеФайлы.ОбновитьПрисоединенныйФайл(Выборка.Ссылка, ИнформацияОФайле);	
		
		ФайлОбъект = Выборка.Ссылка.ПолучитьОбъект();
		ФайлОбъект.Наименование = Лев(ИмяФайла, СтрДлина(ИмяФайла) - 4);
		ФайлОбъект.Записать();
	Иначе
		
		Если РасширениеЗаглавнымиБуквами Тогда
			Расширение = ВРег(ОбщегоНазначенияКлиентСервер.РасширениеБезТочки(Файл.Расширение));
		Иначе
			Расширение = ОбщегоНазначенияКлиентСервер.РасширениеБезТочки(Файл.Расширение);
		КонецЕсли;	
		
		ВремяИзменения = ТекущаяДатаСеанса();
		ВремяИзмененияУниверсальное = Файл.ПолучитьУниверсальноеВремяИзменения();
				
		ПараметрыФайла = Новый Структура();
		ПараметрыФайла.Вставить("Автор", Пользователи.ТекущийПользователь());
		ПараметрыФайла.Вставить("ВладелецФайлов", ВладелецФайла);
		ПараметрыФайла.Вставить("ИмяБезРасширения", Лев(ИмяФайла, СтрДлина(ИмяФайла) - 4));
		ПараметрыФайла.Вставить("РасширениеБезТочки", Расширение);
		ПараметрыФайла.Вставить("ВремяИзмененияУниверсальное",ВремяИзмененияУниверсальное);
			
		ПрисоединенныйФайл = ПрисоединенныеФайлы.ДобавитьПрисоединенныйФайл(ПараметрыФайла, АдресВременногоХранилищаФайла, "");

	КонецЕсли;	
	
	УдалитьФайлы(ПолноеИмяФайла);
		
КонецПроцедуры

Функция ПолучитьДанныеФайла(СсылкаНаОбъект, УникальныйИдентификатор = Неопределено, ПолучатьСсылкуНаДвоичныеДанные = Истина) Экспорт
	ИмяОбъекта = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(СсылкаНаОбъект.Метаданные().ПолноеИмя(), ".")[1];
	
	УстановитьПривилегированныйРежим(Истина);
	
	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("Ссылка", СсылкаНаОбъект);
	
	Запрос.Текст = 
	"ВЫБРАТЬ
	|	ПрисоединенныеФайлы.Ссылка
	|ИЗ
	|	ИсточникДанных КАК ПрисоединенныеФайлы
	|ГДЕ
	|	ПрисоединенныеФайлы.ВладелецФайла = &Ссылка";
	
	Запрос.Текст = СтрЗаменить(Запрос.Текст, "ИсточникДанных", "Справочник." + ИмяОбъекта + "ПрисоединенныеФайлы"); 
	
	Выборка = Запрос.Выполнить().Выбрать();
	
	Если Выборка.Следующий() Тогда
		СсылкаНаФайл = Выборка.Ссылка;
	Иначе
		Возврат Неопределено;
	КонецЕсли;	
			
	Возврат ПрисоединенныеФайлы.ПолучитьДанныеФайла(СсылкаНаФайл, УникальныйИдентификатор, ПолучатьСсылкуНаДвоичныеДанные);	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Процедуры и функции работы с данными физических лиц

Процедура СоздатьВТФИООтветственныхЛиц(МенеджерВременныхТаблиц, ТолькоРазрешенные, ИменаПолейОтветственныхЛиц, ИмяВременнойТаблицыДанныхДокумента) Экспорт
	
	Запрос = Новый Запрос;
	Запрос.МенеджерВременныхТаблиц = МенеджерВременныхТаблиц;

	ЭтоПервоеПолеОтветственного = Истина;
	Для Каждого ИмяПоляОтветственногоЛица Из ИменаПолейОтветственныхЛиц Цикл
		
		Если Не ЭтоПервоеПолеОтветственного Тогда 
			Запрос.Текст = Запрос.Текст + "
										  |ОБЪЕДИНИТЬ ВСЕ
										  |ВЫБРАТЬ РАЗЛИЧНЫЕ";
		Иначе
										  
			Запрос.Текст = Запрос.Текст + "ВЫБРАТЬ " + ?(ТолькоРазрешенные, "РАЗРЕШЕННЫЕ", "") + " РАЗЛИЧНЫЕ";
		КонецЕсли;										  
		
		Запрос.Текст = Запрос.Текст + "
		                              |	ДанныеДокумента.ИмяПоляОтветственногоЛица КАК ФизическоеЛицо,
		                              |	ДанныеДокумента.Дата КАК Период,
									  |	ДанныеДокумента.Ссылка" + ?(ЭтоПервоеПолеОтветственного, "
									  |ПОМЕСТИТЬ ВТСотрудники", "") + "
		                              |ИЗ
		                              |	ДанныеДокумента КАК ДанныеДокумента";	
		Запрос.Текст = СтрЗаменить(Запрос.Текст, "ИмяПоляОтветственногоЛица", ИмяПоляОтветственногоЛица);
		
		ЭтоПервоеПолеОтветственного = Ложь;	
		
	КонецЦикла;		
	
	Запрос.Текст = СтрЗаменить(Запрос.Текст, "ДанныеДокумента", ИмяВременнойТаблицыДанныхДокумента);
	Запрос.Выполнить();
	
	ОписательВременныхТаблиц = КадровыйУчет.ОписательВременныхТаблицДляСоздатьВТКадровыеДанныеФизическихЛиц(
		МенеджерВременныхТаблиц, "ВТСотрудники");
		
	КадровыйУчет.СоздатьВТКадровыеДанныеФизическихЛиц(ОписательВременныхТаблиц, ТолькоРазрешенные, "Фамилия,Имя,Отчество");
	
	Запрос.Текст = 
	"ВЫБРАТЬ РАЗРЕШЕННЫЕ РАЗЛИЧНЫЕ
	|	ДанныеДокументов.ФизическоеЛицо,
	|	ДанныеДокументов.Период КАК Дата,
	|	ДанныеДокументов.Ссылка,
	|	ВТКадровыеДанныеФизЛиц.Фамилия,
	|	ВТКадровыеДанныеФизЛиц.Имя,
	|	ВТКадровыеДанныеФизЛиц.Отчество
	|ПОМЕСТИТЬ ВТФИООтветственныхЛиц
	|ИЗ
	|	ВТСотрудники КАК ДанныеДокументов
	|		ЛЕВОЕ СОЕДИНЕНИЕ ВТКадровыеДанныеФизическихЛиц КАК ВТКадровыеДанныеФизЛиц
	|		ПО ДанныеДокументов.ФизическоеЛицо = ВТКадровыеДанныеФизЛиц.ФизическоеЛицо
	|			И ДанныеДокументов.Период = ВТКадровыеДанныеФизЛиц.Период";
				   
	Если НЕ ТолькоРазрешенные Тогда
		Запрос.Текст = СтрЗаменить(Запрос.Текст, "ВЫБРАТЬ РАЗРЕШЕННЫЕ", "ВЫБРАТЬ");
	КонецЕсли;	

	Запрос.Выполнить();			   
	
КонецПроцедуры	

// Возвращает соответствие Физлицо - ФИО на дату
// относящихся к персональным.
//
// Параметры:
//		ДатаАктуальности - дата, на которую определяется ФИО:
//		МассивФизЛиц - массив ссылок типа СправочникСсылка.ФизическиеЛица.
//
// Возвращаемое значение:
//		соответствие	
//			ключ - СправочникСсылка.ФизическиеЛица
//			значение - строка ФИО.
//
//
Функция СоответствиеФИОФизЛицСсылкам(ДатаАктуальности, МассивФизЛиц) Экспорт 
	
	МассивНеобходимыхПолей = Новый Массив;
	МассивНеобходимыхПолей.Добавить("Фамилия");
	МассивНеобходимыхПолей.Добавить("Имя");
	МассивНеобходимыхПолей.Добавить("Отчество");
	
	Запрос = Новый Запрос;
	Запрос.МенеджерВременныхТаблиц = Новый МенеджерВременныхТаблиц;
	КадровыйУчет.СоздатьНаДатуВТКадровыеДанныеФизическихЛиц(Запрос.МенеджерВременныхТаблиц, Истина, МассивФизЛиц, МассивНеобходимыхПолей, ДатаАктуальности);
	
	Запрос.Текст = 
	"ВЫБРАТЬ
	|	КадровыеДанныеФизЛиц.ФизическоеЛицо,
	|	КадровыеДанныеФизЛиц.Фамилия,
	|	КадровыеДанныеФизЛиц.Имя,
	|	КадровыеДанныеФизЛиц.Отчество
	|ИЗ
	|	ВТКадровыеДанныеФизическихЛиц КАК КадровыеДанныеФизЛиц";
	
	Выборка = Запрос.Выполнить().Выбрать();
	
	СоответствиеФИОФизЛицСсылкам = Новый Соответствие;
	
	Пока Выборка.Следующий() Цикл
		ФИО = Новый Структура("Фамилия, Имя, Отчество");
		ЗаполнитьЗначенияСвойств(ФИО, Выборка);
		СоответствиеФИОФизЛицСсылкам.Вставить(Выборка.ФизическоеЛицо, ФИО);		
	КонецЦикла;	
	
	Возврат СоответствиеФИОФизЛицСсылкам;
	
КонецФункции	

///////////////////////////////////////////////////////////////////////////////
// Проверка персональных данных физических лиц

Процедура ПроверитьПерсональныеДанныеСотрудника(Ссылка, ДанныеДляПроверки, ПроверяемыеРеквизиты, МассивНепроверяемыхРеквизитов, Дата = '00010101', ВыводитьСообщения = Ложь, Отказ = Ложь, ВыполнятьПолнуюПроверку = Истина) Экспорт	
	МенеджерОбъекта = ОбщегоНазначения.МенеджерОбъектаПоСсылке(Ссылка);
	
	МассивНеПроверяемыхРеквизитов.Очистить();
	
	СтруктураПроверяемыхДанных = МенеджерОбъекта.ПолучитьСтруктуруПроверяемыхДанных();
	
	СтруктураПроверяемыхДокументов = Новый Структура("ВидДокумента,  СерияДокумента, НомерДокумента, ДатаВыдачи, КемВыдан");
	ЗаполнитьЗначенияСвойств(СтруктураПроверяемыхДокументов, ДанныеДляПроверки);
	
	ПредставленияПроверяемыхРеквизитов = МенеджерОбъекта.ПолучитьПредставленияПроверяемыхРеквизитов();
		
	СоответствиеРеквизитовФормеОбъекта = МенеджерОбъекта.ПолучитьСоответствиеРеквизитовФормеОбъекта(ДанныеДляПроверки);
		
	СоответствиеРеквизитовПутиВФормеОбъекта = МенеджерОбъекта.ПолучитьСоответствиеРеквизитовПутиВФормеОбъекта();
	
	СоответствиеРеквизитовОткрываемымОбъектам = МенеджерОбъекта.ПолучитьСоответствиеПроверяемыхРеквизитовОткрываемымОбъектам(Ссылка, ДанныеДляПроверки);
	
	Для Каждого КлючЗначение Из СтруктураПроверяемыхДанных Цикл
		СтруктураПроверяемыхДанных[КлючЗначение.Ключ] = Неопределено;
	КонецЦикла;
	
	СоответствиеПутейИИменПроверяемыхРеквизитов = Новый Структура;
	
	Для Каждого ИмяРеквизита Из ПроверяемыеРеквизиты Цикл
		ПутьКРеквизиту = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(ИмяРеквизита, ".");	
		
		СоответствиеПутейИИменПроверяемыхРеквизитов.Вставить(ПутьКРеквизиту[ПутьКРеквизиту.Количество() - 1], ИмяРеквизита);
	КонецЦикла;	
	
	ЗаполнитьЗначенияСвойств(СтруктураПроверяемыхДанных, ДанныеДляПроверки);

	ПроверитьОбязательныеПоля(Ссылка, СтруктураПроверяемыхДанных, ДанныеДляПроверки, СоответствиеПутейИИменПроверяемыхРеквизитов, СоответствиеРеквизитовФормеОбъекта, СоответствиеРеквизитовПутиВФормеОбъекта, СоответствиеРеквизитовОткрываемымОбъектам, ПредставленияПроверяемыхРеквизитов, МассивНепроверяемыхРеквизитов, ВыводитьСообщения, Отказ);
	
	Если ВыполнятьПолнуюПроверку Тогда
		ПроверитьЗаполнениеСтраховыхНомеровПФР(СтруктураПроверяемыхДанных, СоответствиеРеквизитовОткрываемымОбъектам, ДанныеДляПроверки, ВыводитьСообщения, Отказ);
	КонецЕсли;	
	
	Если ВыполнятьПолнуюПроверку Тогда
		ПроверитьМестоРождения(СтруктураПроверяемыхДанных, СоответствиеРеквизитовОткрываемымОбъектам, ДанныеДляПроверки, ВыводитьСообщения, Отказ);
	КонецЕсли;	
	
	Если ВыполнятьПолнуюПроверку Тогда
		ПроверитьДанныеУдостоверенийЛичности(Ссылка, Дата, СтруктураПроверяемыхДокументов, ДанныеДляПроверки, СоответствиеПутейИИменПроверяемыхРеквизитов, СоответствиеРеквизитовФормеОбъекта, СоответствиеРеквизитовПутиВФормеОбъекта, ПредставленияПроверяемыхРеквизитов, СоответствиеРеквизитовОткрываемымОбъектам, МассивНепроверяемыхРеквизитов, ВыводитьСообщения, Отказ);
	КонецЕсли;	
	
	Если ВыполнятьПолнуюПроверку Тогда
		ПроверитьЗаполнениеАдресов(СтруктураПроверяемыхДанных, СоответствиеРеквизитовОткрываемымОбъектам, ДанныеДляПроверки, ВыводитьСообщения, Отказ);
	КонецЕсли;	

	ПроверитьДатыРождения(Дата, СтруктураПроверяемыхДанных, СоответствиеРеквизитовОткрываемымОбъектам, ДанныеДляПроверки, ВыводитьСообщения, Отказ);
	
	Если ВыполнятьПолнуюПроверку Тогда
		ПроверитьЗаполнениеИНН(СтруктураПроверяемыхДанных, СоответствиеРеквизитовОткрываемымОбъектам, ДанныеДляПроверки, ВыводитьСообщения, Отказ);
	КонецЕсли;	
			
КонецПроцедуры	

///////////////////////////////////////////////////////////////////////////////
// Защита персональных данных

// Процедура обеспечивает сбор сведений о хранении данных, 
// относящихся к персональным.
//
// Параметры:
//		ТаблицаСведений - таблица значений с полями:
//			Объект 			- строка, содержащая полное имя объекта метаданных,
//			ПоляРегистрации - строка, в которой перечислены имена полей регистрации, 
//								отдельные поля регистрации отделяются запятой,
//								альтернативные - символом "|",
//			ПоляДоступа		- строка, в которой перечислены через запятую имена полей доступа
//			ОбластьДанных	- строка с идентификатором области данных, необязательно для заполнения.
//
Процедура ЗаполнитьСведенияОПерсональныхДанных(ТаблицаСведений) Экспорт
	
	
КонецПроцедуры

// Процедура обеспечивает составление коллекции областей персональных данных
//
// Параметры:
//		ОбластиПерсональныхДанных - таблица значений с полями:
//			Имя - идентификатор области данных
//			Представление - пользовательское представление области данных
//			Родитель - идентификатор родительской области данных.
//
Процедура ЗаполнитьОбластиПерсональныхДанных(ОбластиПерсональныхДанных) Экспорт
	
	
	
КонецПроцедуры

///////////////////////////////////////////////////////////////////////////////
// Выгрузка/загрузка данных

// Заполняет массив типов неразделенных данных, 
// для которых при выгрузке/загрузке используется сопоставление не по коду, 
// а по реквизиту ИдентификаторОбъекта.
// 
// Параметры:
//  МассивТипов - массив.
//
Процедура ТипыОбщихДанныхСопоставляемыхПоИдентификаторуОбъекта(Знач МассивТипов) Экспорт
КонецПроцедуры

///////////////////////////////////////////////////////////////////////////////
// Общие процедуры и функции ЗАРПЛАТА И КАДРЫ

// Заполняет документ по основанию сотрудник, осуществляет проверку корректности ввода документа.
// В случае , когда проверка не проходит вызывает исключение.
//
// Параметры:
//		ДокументОбъект - ДокументОбъект - документ.
//		ДанныеЗаполнения - СправочникСсылка.Сотрудники - сотрудник.
//		ПроверкаОформленностиНаРаботу - Булево - когда Истина вызывает исключение, если сотрудник уже принят на работу,
//										Ложь - если сотрудник еще не принят
//		ОтключитьПроверкуЗанятости - Булево - отключает проверку принятости сотрудника.
//
// Возвращаемое значение:
//		Булево - Истина - ДанныеЗаполнения заполнен имеют тип 
//							СправочникСсылка.Сотрудники, Ложь - если 
//						   ДанныеЗаполнения содержат значение другого типа.
//
Процедура ЗаполнитьПоОснованиюСотрудником(ДокументОбъект, ДанныеЗаполнения, ПроверкаОформленностиНаРаботу = Ложь, ОтключитьПроверкуЗанятости = Ложь) Экспорт
	
	КадровыеДанные =  КадровыйУчет.КадровыеДанныеСотрудников(Истина, ДанныеЗаполнения, "ГоловнаяОрганизация,Организация,ФизическоеЛицо,ДатаПриема,ОформленПриемНаРаботу,ДатаУвольнения");
	Если КадровыеДанные.Количество() > 0 Тогда
		
		СтрокаДанных = КадровыеДанные[0];
		
		Если НЕ ОтключитьПроверкуЗанятости Тогда
			
			Если ПроверкаОформленностиНаРаботу Тогда
				
				Если СтрокаДанных.ОформленПриемНаРаботу Тогда
					
					Если ЗначениеЗаполнено(СтрокаДанных.ДатаУвольнения) Тогда
						
						ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
							НСтр("ru = 'Сотрудник ""%1"" был оформлен на работу с %2, уволен %3'"),
							ДанныеЗаполнения,
							Формат(СтрокаДанных.ДатаПриема, "ДЛФ=DD"),
							Формат(СтрокаДанных.ДатаУвольнения, "ДЛФ=DD"));
						
					Иначе
						
						Если ЗначениеЗаполнено(СтрокаДанных.ДатаПриема) Тогда
							
							ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
								НСтр("ru = 'Сотрудник ""%1"" уже оформлен на работу с %2'"),
								ДанныеЗаполнения,
								Формат(СтрокаДанных.ДатаПриема, "ДЛФ=DD"));
							
						Иначе
								
							ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
								НСтр("ru = 'Сотрудник ""%1"" уже оформлен на работу'"),
								ДанныеЗаполнения);
							
						КонецЕсли;
						
					КонецЕсли;
					
				КонецЕсли; 
					
			Иначе
				Если НЕ ЗначениеЗаполнено(СтрокаДанных.ГоловнаяОрганизация) Тогда
					
					ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
						НСтр("ru = 'Сотрудник ""%1"" не оформлен на работу'"),
						ДанныеЗаполнения);
					
				ИначеЕсли ЗначениеЗаполнено(СтрокаДанных.ДатаУвольнения) Тогда
						
					ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
						НСтр("ru = 'Сотрудник ""%1"" уволен %2'"),
						ДанныеЗаполнения,
						Формат(СтрокаДанных.ДатаУвольнения, "ДЛФ=DD"));
					
				КонецЕсли;
					
			КонецЕсли;
			
		КонецЕсли; 
		
		Если ЗначениеЗаполнено(СтрокаДанных.Организация) Тогда
			ДокументОбъект.Организация = СтрокаДанных.Организация;
		Иначе
			ДокументОбъект.Организация = СтрокаДанных.ГоловнаяОрганизация;
		КонецЕсли;
		
		МетаданныеДокумента = ДокументОбъект.Метаданные();
		
		Если МетаданныеДокумента.Реквизиты.Найти("Сотрудник") <> Неопределено Тогда
			
			ДокументОбъект.Сотрудник 		= СтрокаДанных.Сотрудник;
			
		КонецЕсли; 
		
		Если МетаданныеДокумента.Реквизиты.Найти("ФизическоеЛицо") <> Неопределено Тогда
			
			ДокументОбъект.ФизическоеЛицо 	= СтрокаДанных.ФизическоеЛицо;
			
		КонецЕсли; 
		
	КонецЕсли;
	
КонецПроцедуры

Процедура ПолучитьПрефиксообразующиеРеквизиты(Объекты) Экспорт
КонецПроцедуры

Процедура ЗаполнитьИсточникиДанныхДляПроверкиЗапретаИзменения(ИсточникиДанных) Экспорт
КонецПроцедуры

Процедура ПередПроверкойЗапретаИзменения(Объект, ПроверкаЗапретаИзменения, УзелПроверкиЗапретаЗагрузки, СообщитьОЗапрете) Экспорт
	
	Если Объект.ДополнительныеСвойства.Свойство("ОтключитьПроверкуДатыЗапретаИзменения")
		И Объект.ДополнительныеСвойства.ОтключитьПроверкуДатыЗапретаИзменения Тогда
		
		ПроверкаЗапретаИзменения = Ложь;
		СообщитьОЗапрете = Ложь;
		
	КонецЕсли; 	
	
КонецПроцедуры

// Возвращает структуру с полями
//	ИзмеренияФильтра - массив имен измерений по которым выполняется отбор
//	Измерения - массив имен всех измерений регистра
//	Ресурсы - массив имен ресурсов, которые не имеют "пары" ...ПоОкончании, кроме ДействуетДо
//	ВозвратныеРесурсы - массив имен ресурсов, которые имеют "пару" с именем ...ПоОкончании
//	Реквизиты - массив имен всех реквизитов
//  СтандартныеРеквизиты - массив имен стандартных реквизитов.
Функция КоллекцииПолейДляПодготовкиТекстаЗапроса(ИмяРегистра, МассивИзмерений) Экспорт
	// Измерения для отбора
	ИзмеренияФильтра = Новый Массив;
	Для Каждого Измерение Из МассивИзмерений Цикл
		Если 	ВРег(Измерение) = ВРег("Период") Или 
				ВРег(Измерение) = ВРег("ДатаНачала") Или 
				ВРег(Измерение) = ВРег("ДатаОкончания") Тогда
			Продолжить;
		КонецЕсли;
		ИзмеренияФильтра.Добавить(Измерение);
	КонецЦикла;
	
	РегистрСведенийМетаданные = Метаданные.РегистрыСведений[ИмяРегистра];
	
	// Все измерения
	Измерения = Новый Массив;
	Для Каждого Измерение Из РегистрСведенийМетаданные.Измерения Цикл
		Измерения.Добавить(Измерение.Имя);
	КонецЦикла;
	
	ЕстьВозвратныеСобытия = Ложь;
	
	// Ресурсы
	Ресурсы = Новый Массив;
	ВозвратныеРесурсы = Новый Массив;
	Для Каждого Ресурс Из РегистрСведенийМетаданные.Ресурсы Цикл
		Если ВРег(Ресурс.Имя) = ВРег("ДействуетДо") Тогда
			ЕстьВозвратныеСобытия = Истина;
			Продолжить; // не включаем ресурс ДействуетДо в список получаемых ресурсов
		КонецЕсли;	
		Если ВРег(Прав(Ресурс.Имя, 11)) <> ВРег("ПоОкончании") Тогда
			Ресурсы.Добавить(Ресурс.Имя);
		Иначе	
			ВозвратныеРесурсы.Добавить(Лев(Ресурс.Имя, СтрДлина(Ресурс.Имя) - 11));
		КонецЕсли;	
	КонецЦикла;
	
	// Удалим из списка "простых" ресурсов те, которые являются "возвратными"
	Для Каждого Ресурс Из ВозвратныеРесурсы Цикл
		ИндексРесурса = Ресурсы.Найти(Ресурс);
		Если ИндексРесурса <> Неопределено Тогда
			Ресурсы.Удалить(ИндексРесурса);
		КонецЕсли;			
	КонецЦикла;
	
	// Реквизиты
	Реквизиты = Новый Массив;
	Для Каждого Реквизит Из РегистрСведенийМетаданные.Реквизиты Цикл
		Реквизиты.Добавить(Реквизит.Имя);
	КонецЦикла;
	
	// СтандартныеРеквизиты
	СтандартныеРеквизиты = Новый Массив;
	Для Каждого СтандартныйРеквизит Из РегистрСведенийМетаданные.СтандартныеРеквизиты Цикл
		Если СтандартныйРеквизит.Имя <> "Период" Тогда
			СтандартныеРеквизиты.Добавить(СтандартныйРеквизит.Имя);
		КонецЕсли;
	КонецЦикла;
	
	Возврат Новый Структура("ИзмеренияФильтра,Измерения,ВозвратныеРесурсы,Ресурсы,Реквизиты,СтандартныеРеквизиты",
							ИзмеренияФильтра, Измерения, ВозвратныеРесурсы, Ресурсы, Реквизиты, СтандартныеРеквизиты);
	
КонецФункции

// Возвращает признак необходимости отключения бизнес логики при записи объекта
//
// Параметры:
//  Объект - прикладной объект, например СправочникОбъект - объект для которого
//   требуется проверить необходимость отключения бизнес логики при записи.
//
// Возвращаемое значение:
//  Булево - признак необходимости отключения бизнес логики при записи объекта.
//
Функция ОтключитьБизнесЛогикуПриЗаписи(Знач Объект) Экспорт
	
	Возврат Объект.ОбменДанными.Загрузка И (НЕ Объект.ДополнительныеСвойства.Свойство("ПроверятьБизнесЛогикуПриЗаписи")); 
		
КонецФункции

// Преобразовывает переданные массивы сотрудников и физических лиц в строку 
// вида <Фамилия И.О., Фамилия И.О...>
// Используется для заполнения краткого состава документов.
//
// Параметры:
//	- Сотрудники - массив элементов типа СправочникСсылка.Сотрудники,
//	- ДатаАктуальности - дата для получения фамилии, имени и отчества
//	- Физлица - необязательный, массив элементов типа СправочникСсылка.ФизическиеЛица
//	- ФизлицаСотрудников - соответствие Сотрудник - Физическое лицо.
//
Функция КраткийСоставСотрудников(Сотрудники, ДатаАктуальности, Физлица = Неопределено, ФизлицаСотрудников = Неопределено) Экспорт
	
	Если ФизлицаСотрудников = Неопределено Тогда
		ФизлицаСотрудников = ОбщегоНазначения.ЗначениеРеквизитаОбъектов(Сотрудники, "ФизическоеЛицо");
	КонецЕсли;
	
	// Первые N человек и M символов
	МаксимальноеКоличествоФизическихЛиц = 10;
	МаксимальнаяДлинаСтроки = 100;

	Счетчик = 0;
	ПервыеФизлица = Новый Массив;
	УникальныеФизлица = Новый Соответствие;
	Для Каждого Сотрудник Из Сотрудники Цикл
		Если Счетчик = МаксимальноеКоличествоФизическихЛиц Тогда
			Прервать;
		КонецЕсли;
		Физлицо = ФизлицаСотрудников[Сотрудник];
		Если Не ЗначениеЗаполнено(Физлицо) 
			Или УникальныеФизлица[Физлицо] <> Неопределено Тогда
			Продолжить;	
		КонецЕсли;
		ПервыеФизлица.Добавить(Физлицо);
		УникальныеФизлица.Вставить(Физлицо, Истина);
		Счетчик = Счетчик + 1;
	КонецЦикла;
	
	// Если физлиц сотрудников не достаточно, 
	// добавляем данные табличных частей, где непосредственно Физические лица.
	Если Счетчик < МаксимальноеКоличествоФизическихЛиц И Физлица <> Неопределено Тогда
		Для Каждого Физлицо Из Физлица Цикл
			Если Счетчик = МаксимальноеКоличествоФизическихЛиц Тогда
				Прервать;
			КонецЕсли;
			Если Не ЗначениеЗаполнено(Физлицо) 
				Или УникальныеФизлица[Физлицо] <> Неопределено Тогда
				Продолжить;	
			КонецЕсли;
			ПервыеФизлица.Добавить(Физлицо);
			УникальныеФизлица.Вставить(Физлицо, Истина);
			Счетчик = Счетчик + 1;
		КонецЦикла;
	КонецЕсли;
	
	ИменаФизлиц = СоответствиеФИОФизЛицСсылкам(ДатаАктуальности, ПервыеФизлица);
	
	КраткийСостав = "";
	Для Каждого Физлицо Из ПервыеФизлица Цикл
		Если Не ПустаяСтрока(КраткийСостав) Тогда
			КраткийСостав = КраткийСостав + ", ";
		КонецЕсли;
		ФИО = ИменаФизлиц[Физлицо];
		КраткийСостав = КраткийСостав + ФизическиеЛицаКлиентСервер.ФамилияИнициалы(ФИО.Фамилия+" "+ФИО.Имя+" "+ФИО.Отчество);
	КонецЦикла;
	Если СтрДлина(КраткийСостав) > МаксимальнаяДлинаСтроки Тогда
		КраткийСостав = Лев(КраткийСостав, МаксимальнаяДлинаСтроки - 3) + "...";
	КонецЕсли;
	
	Возврат КраткийСостав;

КонецФункции

/////////////////////////////////////////////////////////////////////////////////////////
// Особенные математические функции подгонки сумм

Процедура ОкруглитьСлагаемыеПоСумме(Данные, ИмяКолонки, Сумма, Точность = 0, ИмяКлюча = "ФизическоеЛицо") Экспорт 
	
	ВременнаяТаблица = Данные.Скопировать(, ИмяКлюча + "," + ИмяКолонки);
	ВременнаяТаблица.Колонки.Добавить(ИмяКолонки + "Окр");
	Для каждого СтрокаТЗ Из ВременнаяТаблица Цикл
		СтрокаТЗ[ИмяКолонки + "Окр"] = Окр(СтрокаТЗ[ИмяКолонки],Точность)
	КонецЦикла;
	Данные.ЗагрузитьКолонку(ВременнаяТаблица.ВыгрузитьКолонку(ИмяКолонки + "Окр"),ИмяКолонки);
	
	СуммаСлагаемых = ВременнаяТаблица.Итог(ИмяКолонки + "Окр");
	Если СуммаСлагаемых <> Сумма Тогда
		Шаг = Pow(10, -Точность);
		РасхождениеСуммы = Сумма - СуммаСлагаемых;
		Приращение = ?(РасхождениеСуммы > 0, Шаг, -Шаг);
		ВсегоПриращений = Мин(РасхождениеСуммы / Приращение, ВременнаяТаблица.Количество());
		ВременнаяТаблица.Колонки.Добавить(ИмяКолонки + "Расхождение");
		ВременнаяТаблица.Колонки.Добавить(ИмяКолонки + "Изменение");
		Для каждого СтрокаТЗ Из ВременнаяТаблица Цикл
			СтрокаТЗ[ИмяКолонки + "Расхождение"] = ?(СтрокаТЗ[ИмяКолонки + "Окр"] < СтрокаТЗ[ИмяКолонки], СтрокаТЗ[ИмяКолонки] - СтрокаТЗ[ИмяКолонки + "Окр"], СтрокаТЗ[ИмяКолонки + "Окр"] - СтрокаТЗ[ИмяКолонки]);
			СтрокаТЗ[ИмяКолонки + "Изменение"] = ?(СтрокаТЗ[ИмяКолонки + "Окр"] < СтрокаТЗ[ИмяКолонки], - Шаг, Шаг);
		КонецЦикла;
		ВременнаяТаблица.Сортировать(ИмяКолонки + "Изменение" + ?(Приращение > 0,""," Убыв") + ", " + ИмяКолонки + "Расхождение Убыв");
		СтруктураПоиска = Новый Структура(ИмяКлюча); 
		Для Сч = 1 По ВсегоПриращений Цикл
			Если ВременнаяТаблица[Сч-1][ИмяКолонки + "Изменение"] <> Приращение Тогда
				ЗаполнитьЗначенияСвойств(СтруктураПоиска, ВременнаяТаблица[Сч-1]);
				Данные.НайтиСтроки(СтруктураПоиска)[0][ИмяКолонки] = ВременнаяТаблица[Сч-1][ИмяКолонки + "Окр"] + Приращение;
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;

КонецПроцедуры

Процедура ОкруглитьДваСлагаемыхПоСумме(ПервоеСлагаемое, ВтороеСлагаемое, Сумма, Точность = 0) Экспорт

	Если Окр(ПервоеСлагаемое,Точность) + Окр(ВтороеСлагаемое,Точность) = Сумма Тогда
		ПервоеСлагаемое = Окр(ПервоеСлагаемое,Точность);
		ВтороеСлагаемое = Окр(ВтороеСлагаемое,Точность);
	Иначе
		РасхождениеСуммы = Сумма - Окр(ПервоеСлагаемое,Точность) - Окр(ВтороеСлагаемое,Точность);
		ПервоеРасхождение = ?(Окр(ПервоеСлагаемое,Точность) < ПервоеСлагаемое, ПервоеСлагаемое - Окр(ПервоеСлагаемое,Точность), Окр(ПервоеСлагаемое,Точность) - ПервоеСлагаемое);
		ВтороеРасхождение = ?(Окр(ВтороеСлагаемое,Точность) < ВтороеСлагаемое, ВтороеСлагаемое - Окр(ВтороеСлагаемое,Точность), Окр(ВтороеСлагаемое,Точность) - ВтороеСлагаемое);
		ПервоеСлагаемое = Окр(ПервоеСлагаемое,Точность);
		ВтороеСлагаемое = Окр(ВтороеСлагаемое,Точность);
		Если ПервоеРасхождение <= ВтороеРасхождение Тогда
			ВтороеСлагаемое = ВтороеСлагаемое + РасхождениеСуммы; 
		Иначе
			ПервоеСлагаемое = ПервоеСлагаемое + РасхождениеСуммы; 
		КонецЕсли;
	КонецЕсли;

КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////////////////////////
// Работа с личными данными физических лиц

Процедура ОбработатьЗаписьНабораФИО(НаборЗаписей) Экспорт
	ТаблицаФизЛиц = НаборЗаписей.Выгрузить();
	ОбновитьНаименованияФизЛицаИСотрудника(ТаблицаФизЛиц);	
КонецПроцедуры

Процедура ОбновитьНаименованияФизЛицаИСотрудника(ТаблицаФизЛиц) Экспорт
	
 	УстановитьПривилегированныйРежим(Истина);
	
	Запрос = Новый Запрос;
	
	Запрос.УстановитьПараметр("ТекущаяДата", '20990101');
	Запрос.УстановитьПараметр("ТекущийНабор", ТаблицаФизЛиц);
	
	Запрос.Текст = 
	"ВЫБРАТЬ РАЗЛИЧНЫЕ
	|	ТекущийНабор.ФизическоеЛицо
	|ПОМЕСТИТЬ ВТФизЛицаТекущегоНабора
	|ИЗ
	|	&ТекущийНабор КАК ТекущийНабор
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	ФИОФизическихЛицСрезПоследних.ФизическоеЛицо,
	|	ФИОФизическихЛицСрезПоследних.Фамилия,
	|	ФИОФизическихЛицСрезПоследних.Имя,
	|	ФИОФизическихЛицСрезПоследних.Отчество
	|ПОМЕСТИТЬ ВТФИОФизЛицПоследнее
	|ИЗ
	|	ВТФизЛицаТекущегоНабора КАК ФизЛицаТекущегоНабора
	|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.ФИОФизическихЛиц.СрезПоследних(
	|				&ТекущаяДата,
	|				ФизическоеЛицо В
	|					(ВЫБРАТЬ
	|						ФизЛицаТекущегоНабора.ФизическоеЛицо
	|					ИЗ
	|						ВТФизЛицаТекущегоНабора КАК ФизЛицаТекущегоНабора)) КАК ФИОФизическихЛицСрезПоследних
	|		ПО ФизЛицаТекущегоНабора.ФизическоеЛицо = ФИОФизическихЛицСрезПоследних.ФизическоеЛицо
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	ФИОФизЛицПоследнее.ФизическоеЛицо,
	|	ФИОФизЛицПоследнее.Фамилия,
	|	ФИОФизЛицПоследнее.Имя,
	|	ФИОФизЛицПоследнее.Отчество,
	|	ФизическиеЛица.Наименование
	|ИЗ
	|	ВТФИОФизЛицПоследнее КАК ФИОФизЛицПоследнее
	|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ Справочник.ФизическиеЛица КАК ФизическиеЛица
	|		ПО (ФИОФизЛицПоследнее.ФизическоеЛицо = ФизическиеЛица.Ссылка
	|				И (ФизическиеЛица.Наименование <> (ВЫРАЗИТЬ(ФИОФизЛицПоследнее.Фамилия + ВЫБОР
	|							КОГДА ФИОФизЛицПоследнее.Имя = """"
	|								ТОГДА """"
	|							ИНАЧЕ "" "" + ФИОФизЛицПоследнее.Имя
	|						КОНЕЦ + ВЫБОР
	|							КОГДА ФИОФизЛицПоследнее.Отчество = """"
	|								ТОГДА """"
	|							ИНАЧЕ "" "" + ФИОФизЛицПоследнее.Отчество
	|						КОНЕЦ КАК СТРОКА(50)))
	|					ИЛИ ФизическиеЛица.ФИО <> (ВЫРАЗИТЬ(ФИОФизЛицПоследнее.Фамилия + ВЫБОР
	|							КОГДА ФИОФизЛицПоследнее.Имя = """"
	|								ТОГДА """"
	|							ИНАЧЕ "" "" + ФИОФизЛицПоследнее.Имя
	|						КОНЕЦ + ВЫБОР
	|							КОГДА ФИОФизЛицПоследнее.Отчество = """"
	|								ТОГДА """"
	|							ИНАЧЕ "" "" + ФИОФизЛицПоследнее.Отчество
	|						КОНЕЦ КАК СТРОКА(50)))))
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	Сотрудники.Ссылка КАК Сотрудник,
	|	ФИОФизЛицПоследнее.Фамилия,
	|	ФИОФизЛицПоследнее.Имя,
	|	ФИОФизЛицПоследнее.Отчество,
	|	Сотрудники.Наименование КАК СотрудникНаименование
	|ИЗ
	|	ВТФИОФизЛицПоследнее КАК ФИОФизЛицПоследнее
	|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ Справочник.Сотрудники КАК Сотрудники
	|			ВНУТРЕННЕЕ СОЕДИНЕНИЕ Справочник.ФизическиеЛица КАК ФизическиеЛица
	|			ПО Сотрудники.ФизическоеЛицо = ФизическиеЛица.Ссылка
	|		ПО ФИОФизЛицПоследнее.ФизическоеЛицо = Сотрудники.ФизическоеЛицо
	|			И (Сотрудники.Наименование <> (ВЫРАЗИТЬ(ФИОФизЛицПоследнее.Фамилия + ВЫБОР
	|					КОГДА ФИОФизЛицПоследнее.Имя = """"
	|						ТОГДА """"
	|					ИНАЧЕ "" "" + ФИОФизЛицПоследнее.Имя
	|				КОНЕЦ + ВЫБОР
	|					КОГДА ФИОФизЛицПоследнее.Отчество = """"
	|						ТОГДА """"
	|					ИНАЧЕ "" "" + ФИОФизЛицПоследнее.Отчество
	|				КОНЕЦ КАК СТРОКА(50))))";
	
				   
	Результат = Запрос.ВыполнитьПакет();
	
	ИзменитьНаименованиеФизическихЛиц(Результат[2].Выбрать());
	ИзменитьНаименованиеСотрудников(Результат[3].Выбрать());
	
	УстановитьПривилегированныйРежим(Ложь);
КонецПроцедуры

///////////////////////////////////////////////////////////////////////////////
// Регламентированная отчетность

// Функция возвращает сведения об организации.
//
// Параметры:
//  Организация			- ссылка на элемент справочника "Организации";
//  ДатаЗначения		- дата, на которую нужно получить сведения;
//  СписокПоказателей	- список показателей, значения которых нужно вернуть.
//  
// Возвращаемое значение:
//  Структура - с ключами из списка показателей и возвращаемыми значениями.
//
Функция ПолучитьСведенияОбОрганизации(Знач Организация, Знач ДатаЗначения = Неопределено, Знач СписокПоказателей = Неопределено) Экспорт
КонецФункции

// Процедура заполняет список используемых регламентированных отчетов
//
Процедура ЗаполнитьСписокРегламентированныхОтчетов(СписокРегламентированныхОтчетов) Экспорт
	
КонецПроцедуры

// Процедура заполняет структуру показателей.
// Ключ структуры – идентификатор показателя.
// Значение структуры – массив из двух элементов:
// 	- признак автозаполнения показателя,
//	- признак расшифровки показателя.
//
// Параметры:
// 	ПоказателиОтчета - структура показателей отчета,
// 	ИДОтчета         - идентификатор отчета,
//	ИДРедакцииОтчета - идентификатор редакции формы отчета.
//
Процедура ЗаполнитьПоказателиРегламентированногоОтчета(ПоказателиОтчета, ИДОтчета, ИДРедакцииОтчета) Экспорт
	
КонецПроцедуры

// Процедура заполняет переданную в виде контейнера структуру данных отчета.
//
Процедура ЗаполнитьРегламентированныйОтчет(ИДОтчета, ИДРедакцииОтчета, ПараметрыОтчета, Контейнер) Экспорт
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// Прочие процедуры и функции

Функция РазделительЗапросов() Экспорт
	
	Возврат "
		|;
		|
		|////////////////////////////////////////////////////////////////////////////////
		|";
		
КонецФункции

Функция УникальноеИмяВременнойТаблицы(ИмяВременнойТаблицы) Экспорт
	
	Возврат ИмяВременнойТаблицы + "_" + СтрЗаменить(Строка(Новый УникальныйИдентификатор), "-", "x");
	
КонецФункции

Процедура ДобавитьТекстУдаленияВременнойТаблицы(ТекстЗапроса, ИмяВременнойТаблицы) Экспорт
	
		ТекстЗапроса = ТекстЗапроса + РазделительЗапросов() + "УНИЧТОЖИТЬ " + ИмяВременнойТаблицы;
		
КонецПроцедуры

Процедура ДобавитьТекстУдаленияВременныхТаблиц(ТекстЗапроса, МассивИменВременныхТаблиц) Экспорт
	
	Для каждого ИмяВТКУничтожению Из МассивИменВременныхТаблиц Цикл
		
		ДобавитьТекстУдаленияВременнойТаблицы(ТекстЗапроса, ИмяВТКУничтожению);
		
	КонецЦикла;
	
КонецПроцедуры

Процедура ОбъединитьТекстыЗапросов(ТекстЗапросаПриемник, ТекстЗапросаИсточник) Экспорт
	
	ТекстЗапросаПриемник = ?(ПустаяСтрока(ТекстЗапросаПриемник), "", ТекстЗапросаПриемник + РазделительЗапросов()) + ТекстЗапросаИсточник;
	
КонецПроцедуры

Процедура СкопироватьПараметрыЗапроса(ЗапросПриемник, ЗапросИсточник) Экспорт
	
	Для каждого Параметр Из ЗапросИсточник.Параметры Цикл
		
		ЗапросПриемник.УстановитьПараметр(Параметр.Ключ, Параметр.Значение);
		
	КонецЦикла;
	
КонецПроцедуры

Процедура ОбъединитьЗапросы(ЗапросПриемник, ЗапросИсточник) Экспорт
	
	ОбъединитьТекстыЗапросов(ЗапросПриемник.Текст, ЗапросИсточник.Текст);
	СкопироватьПараметрыЗапроса(ЗапросПриемник,  ЗапросИсточник);
	
КонецПроцедуры

Функция ЗапросВТИмяРегистраСрез(ТолькоРазрешенные, КоллекцииПолей, ИмяРегистра, ИмяТаблицыИзмерений, ИмяСоздаваемойТаблицы = "", Отбор = Неопределено, ВсеЗаписи = Ложь, ВключаяГраницу = Истина, СрезПоследних = Истина, СоответствиеИзмеренийПолямТаблицы = Неопределено) Экспорт
	
	Если СоответствиеИзмеренийПолямТаблицы = Неопределено Тогда
		СоответствиеИзмеренийПолямТаблицы = Новый Соответствие;
	КонецЕсли;
	
	ИзмерениеФильтраПериод = СоответствиеИзмеренийПолямТаблицы.Получить("Период");
	Если ИзмерениеФильтраПериод = Неопределено Тогда
		ИзмерениеФильтраПериод = "Период";
	КонецЕсли;
	
	Запрос = Новый Запрос;
	
	Если ПустаяСтрока(ИмяСоздаваемойТаблицы) Тогда
		ИмяСоздаваемойТаблицы = "ВТ" + ИмяРегистра + ?(СрезПоследних,"СрезПоследних","СрезПервых");
	КонецЕсли; 
	
	ИмяВТМаксимальныеПериоды = УникальноеИмяВременнойТаблицы("ВТМаксимальныеПериоды");
	
	ТекстУсловийСКД = "{ВЫБРАТЬ
		|	ЗаданныйПериод";
	
	ТекстЗапроса = 
		"ВЫБРАТЬ РАЗРЕШЕННЫЕ
		|	ИзмеренияДаты." + ИзмерениеФильтраПериод + " КАК ЗаданныйПериод";
		
	Для Каждого Измерение Из КоллекцииПолей.Измерения Цикл
			
		Если КоллекцииПолей.ИзмеренияФильтра.Найти(Измерение) <> НеОпределено Тогда
			
			ИзмерениеФильтра = СоответствиеИзмеренийПолямТаблицы.Получить(Измерение);
			Если ИзмерениеФильтра = Неопределено Тогда
				ИзмерениеФильтра = Измерение;
			КонецЕсли;
			
			ТекстЗапроса = ТекстЗапроса + ",
				|	ИзмеренияДаты." + ИзмерениеФильтра + " КАК " + Измерение;
				
			ТекстУсловийСКД = ТекстУсловийСКД + ",
				|	" + Измерение;
		Иначе
				
			ТекстЗапроса = ТекстЗапроса + ",
				|	РегистрСведений." + Измерение;
				
			ТекстУсловийСКД = ТекстУсловийСКД + ",
				|	" + Измерение;
				
		Конецесли;
			
	КонецЦикла;
	
	Если СрезПоследних Тогда
		
		ТекстУсловийСКД = ТекстУсловийСКД + "
			|	Период}";
		
		ТекстЗапроса = ТекстЗапроса + ",
			|	МАКСИМУМ(РегистрСведений.Период) КАК Период
			|ПОМЕСТИТЬ " + ИмяВТМаксимальныеПериоды + "
			|" + ТекстУсловийСКД + "
			|ИЗ
			|	" + ИмяТаблицыИзмерений + " КАК ИзмеренияДаты
			|		{ЛЕВОЕ СОЕДИНЕНИЕ РегистрСведений." + ИмяРегистра + " КАК РегистрСведений
			|		ПО (РегистрСведений.Период <= ИзмеренияДаты." + ИзмерениеФильтраПериод + " ИЛИ ИзмеренияДаты." + ИзмерениеФильтраПериод + " = ДАТАВРЕМЯ(1,1,1,0,0,0))";
			
		Если НЕ ВключаяГраницу Тогда
			ТекстЗапроса = СтрЗаменить(ТекстЗапроса,"<=","<");
		КонецЕсли;
		
	Иначе
		
		ТекстУсловийСКД = ТекстУсловийСКД + "
			|	МИНИМУМ(РегистрСведений.Период) КАК Период}";
		
		ТекстЗапроса = ТекстЗапроса + ",
			|	МИНИМУМ(РегистрСведений.Период) КАК Период
			|ПОМЕСТИТЬ " + ИмяВТМаксимальныеПериоды + "
			|" + ТекстУсловийСКД + "
			|ИЗ
			|	" + ИмяТаблицыИзмерений + " КАК ИзмеренияДаты
			|		{ЛЕВОЕ СОЕДИНЕНИЕ РегистрСведений." + ИмяРегистра + " КАК РегистрСведений
			|		ПО (РегистрСведений.Период >= ИзмеренияДаты." + ИзмерениеФильтраПериод + ")";
			
		Если НЕ ВключаяГраницу Тогда
			ТекстЗапроса = СтрЗаменить(ТекстЗапроса,">=",">");
		КонецЕсли;
		
	КонецЕсли;
	
	Для Каждого Измерение Из КоллекцииПолей.ИзмеренияФильтра Цикл
		
		ИзмерениеФильтра = СоответствиеИзмеренийПолямТаблицы.Получить(Измерение);
		Если ИзмерениеФильтра = Неопределено Тогда
			ИзмерениеФильтра = Измерение;
		КонецЕсли;
		
		ТекстЗапроса = ТекстЗапроса + "
			|			И (РегистрСведений." + Измерение + " = ИзмеренияДаты." + ИзмерениеФильтра + ")";
			
	КонецЦикла;
	
	ТекстЗапроса = ТекстЗапроса + "}";
	
	Если Отбор <> Неопределено И Отбор.Количество() > 0 Тогда
		
		СчПараметров = 1;
		
		ТекстОтбор = "
			|	И (";
			
		Для Каждого СтруктураОтбора Из Отбор Цикл
				
			Если ТипЗнч(СтруктураОтбора.ПравоеЗначение) = Тип("Строка") Тогда
				ОписаниеПараметра = СтруктураОтбора.ПравоеЗначение;
			Иначе
				
				ИмяПараметра = ИмяСоздаваемойТаблицы +"_Параметр" + СчПараметров;
				ОписаниеПараметра = "&" + ИмяПараметра;
				Запрос.УстановитьПараметр(ИмяПараметра, СтруктураОтбора.ПравоеЗначение);
				
			КонецЕсли;
			
			ТекстОтбор = ТекстОтбор + "
				|	РегистрСведений." + СтруктураОтбора.ЛевоеЗначение + " " + СтруктураОтбора.ВидСравнения + " (" + ОписаниеПараметра + ") И";
				
			СчПараметров = СчПараметров + 1;
			
		КонецЦикла;	
		
		ТекстОтбор = Лев(ТекстОтбор, СтрДлина(ТекстОтбор) - 1);
		ТекстОтбор = ТекстОтбор + ")";
		ТекстЗапроса = ТекстЗапроса + ТекстОтбор;
		
	КонецЕсли;
	
	ТекстОтборовСКД = "";
	Для каждого Измерение Из КоллекцииПолей.ИзмеренияФильтра Цикл
		ТекстОтборовСКД = ?(ПустаяСтрока(ТекстОтборовСКД), "", ТекстОтборовСКД + "," + Символы.ПС) + "	РегистрСведений." + Измерение + ".*";
	КонецЦикла;
	
	Если НЕ ПустаяСтрока(ТекстОтборовСКД) Тогда
		ТекстЗапроса = ТекстЗапроса + "
			|{ГДЕ
			|" + ТекстОтборовСКД + "}";
	КонецЕсли; 
	
	ТекстЗапроса = ТекстЗапроса + "
		|
		|СГРУППИРОВАТЬ ПО
		|	ИзмеренияДаты." + ИзмерениеФильтраПериод;
		
	Для Каждого Измерение Из КоллекцииПолей.Измерения Цикл
			
		Если КоллекцииПолей.ИзмеренияФильтра.Найти(Измерение) <> НеОпределено Тогда
			
			ИзмерениеФильтра = СоответствиеИзмеренийПолямТаблицы.Получить(Измерение);
			Если ИзмерениеФильтра = Неопределено Тогда
				ИзмерениеФильтра = Измерение;
			КонецЕсли;
			
			ТекстЗапроса = ТекстЗапроса + ",
				|	ИзмеренияДаты." + ИзмерениеФильтра;
				
		Иначе
			ТекстЗапроса = ТекстЗапроса + ",
				|	РегистрСведений." + Измерение;
		Конецесли;
			
	КонецЦикла;
	
	ТекстУсловийСКД = "{ВЫБРАТЬ
		|	Период,
		|	ПериодЗаписи";

	
	ТекстЗапроса = ТекстЗапроса + РазделительЗапросов() + 
		"ВЫБРАТЬ РАЗРЕШЕННЫЕ
		|	МаксимальныеПериоды.ЗаданныйПериод КАК Период,
		|	РегистрСведений.Период КАК ПериодЗаписи";
		
	Для Каждого Измерение Из КоллекцииПолей.Измерения Цикл
			
		ТекстЗапроса = ТекстЗапроса + ",
			|	МаксимальныеПериоды." + Измерение;
			
		ТекстУсловийСКД = ТекстУсловийСКД + ",
			|	" + Измерение;
			
	КонецЦикла;
	
	Если СрезПоследних Тогда
		
		ТекстЗапросаПолей = "";
		Для Каждого Ресурс Из КоллекцииПолей.ВозвратныеРесурсы Цикл
			
			ТекстЗапросаПолей = ТекстЗапросаПолей + ",
			|	ВЫБОР
			|		КОГДА РегистрСведений.ДействуетДо = ДАТАВРЕМЯ(1, 1, 1)
			|				ИЛИ РегистрСведений.ДействуетДо >= МаксимальныеПериоды.ЗаданныйПериод И МаксимальныеПериоды.ЗаданныйПериод <> ДАТАВРЕМЯ(1, 1, 1)
			|			ТОГДА РегистрСведений." + Ресурс + "
			|		ИНАЧЕ РегистрСведений." + Ресурс + "ПоОкончании
			|	КОНЕЦ КАК " + Ресурс;
			
		ТекстУсловийСКД = ТекстУсловийСКД + ",
			|	" + Ресурс;
		
		КонецЦикла;
		
		Если ВключаяГраницу Тогда
			ТекстЗапросаПолей = СтрЗаменить(ТекстЗапросаПолей,">=",">");
		КонецЕсли;
		
		ТекстЗапроса = ТекстЗапроса + ТекстЗапросаПолей;
		
	Иначе
		
		Для Каждого Ресурс Из КоллекцииПолей.ВозвратныеРесурсы Цикл
			ТекстЗапроса = ТекстЗапроса + ",
				|	РегистрСведений." + Ресурс + " КАК " + Ресурс;
			ТекстЗапроса = ТекстЗапроса + ",
				|	РегистрСведений." + Ресурс + "ПоОкончании КАК " + Ресурс + "ПоОкончании";
				
			ТекстУсловийСКД = ТекстУсловийСКД + ",
				|	" + Ресурс + ",
				|	" + Ресурс + "ПоОкончании";
		
		КонецЦикла;
			
	КонецЕсли;
	
	Для Каждого Ресурс Из КоллекцииПолей.Ресурсы Цикл
		ТекстЗапроса = ТекстЗапроса + ",
			|	РегистрСведений." + Ресурс + " КАК " + Ресурс;
		ТекстУсловийСКД = ТекстУсловийСКД + ",
			|	" + Ресурс;
	КонецЦикла;
	
	Для Каждого Реквизит Из КоллекцииПолей.Реквизиты Цикл
		ТекстЗапроса = ТекстЗапроса + ",
			|	РегистрСведений." + Реквизит;
		ТекстУсловийСКД = ТекстУсловийСКД + ",
			|	" + Реквизит;
	КонецЦикла;
	
	Для Каждого СтандартныйРеквизит Из КоллекцииПолей.СтандартныеРеквизиты Цикл
		ТекстЗапроса = ТекстЗапроса + ",
			|	РегистрСведений." + СтандартныйРеквизит;
		ТекстУсловийСКД = ТекстУсловийСКД + ",
			|	" + СтандартныйРеквизит;
	КонецЦикла;
	
	ТекстЗапроса = ТекстЗапроса + "
		|ПОМЕСТИТЬ " + ИмяСоздаваемойТаблицы + "
		|	" + ТекстУсловийСКД + "}
		|ИЗ
		|	" + ИмяВТМаксимальныеПериоды + " КАК МаксимальныеПериоды
		|		{ЛЕВОЕ СОЕДИНЕНИЕ РегистрСведений." + ИмяРегистра + " КАК РегистрСведений
		|		ПО (РегистрСведений.Период = МаксимальныеПериоды.Период)";
		
	Для Каждого Измерение Из КоллекцииПолей.Измерения Цикл
		ТекстЗапроса = ТекстЗапроса + "
			|			И (РегистрСведений." + Измерение + " = МаксимальныеПериоды." + Измерение + ")";
	КонецЦикла;
		
	ТекстЗапроса = ТекстЗапроса + "}";
		
	Если НЕ ВсеЗаписи Тогда
		ТекстЗапроса = ТекстЗапроса + "
			|ГДЕ
			|	(НЕ РегистрСведений.Период ЕСТЬ NULL)";
	КонецЕсли;
	
	ДобавитьТекстУдаленияВременнойТаблицы(ТекстЗапроса, ИмяВТМаксимальныеПериоды);
	
	Если НЕ ТолькоРазрешенные Тогда
		ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "ВЫБРАТЬ РАЗРЕШЕННЫЕ", "ВЫБРАТЬ");
	КонецЕсли;
	
	Запрос.Текст = ТекстЗапроса;
		
	Возврат Запрос;
	
КонецФункции

Функция ЗапросВТИмяРегистра(ТолькоРазрешенные, КоллекцииПолей, ИмяРегистра, ИмяТаблицыИзмерений, ИмяСоздаваемойТаблицы = "", Отбор = Неопределено, СоответствиеИзмеренийПолямТаблицы = Неопределено) Экспорт
	
	Если СоответствиеИзмеренийПолямТаблицы = Неопределено Тогда
		СоответствиеИзмеренийПолямТаблицы = Новый Соответствие;
	КонецЕсли;
	
	ИзмерениеФильтраДатаНачала = СоответствиеИзмеренийПолямТаблицы.Получить("ДатаНачала");
	Если ИзмерениеФильтраДатаНачала = Неопределено Тогда
		ИзмерениеФильтраДатаНачала = "ДатаНачала";
	КонецЕсли;
	
	ИзмерениеФильтраДатаОкончания = СоответствиеИзмеренийПолямТаблицы.Получить("ДатаОкончания");
	Если ИзмерениеФильтраДатаОкончания = Неопределено Тогда
		ИзмерениеФильтраДатаОкончания = "ДатаОкончания";
	КонецЕсли;
		
	Запрос = Новый Запрос;
	
	Если ПустаяСтрока(ИмяСоздаваемойТаблицы) Тогда
		ИмяСоздаваемойТаблицы = "ВТ" + ИмяРегистра;
	КонецЕсли; 
	
	ТекстЗапроса = 
	"ВЫБРАТЬ РАЗРЕШЕННЫЕ
	|	РегистрСведений.Период";
	Для Каждого Измерение Из КоллекцииПолей.Измерения Цикл
		ТекстЗапроса = ТекстЗапроса + ",
		|	РегистрСведений." + Измерение;
	КонецЦикла;
	Для Каждого Ресурс Из КоллекцииПолей.ВозвратныеРесурсы Цикл
		ТекстЗапроса = ТекстЗапроса + ",
		|	РегистрСведений." + Ресурс;
	КонецЦикла;
	Для Каждого Ресурс Из КоллекцииПолей.Ресурсы Цикл
		ТекстЗапроса = ТекстЗапроса + ",
		|	РегистрСведений." + Ресурс;
	КонецЦикла;
	Для Каждого Реквизит Из КоллекцииПолей.Реквизиты Цикл
		ТекстЗапроса = ТекстЗапроса + ",
		|	РегистрСведений." + Реквизит;
	КонецЦикла;
	Для Каждого СтандартныйРеквизит Из КоллекцииПолей.СтандартныеРеквизиты Цикл
		ТекстЗапроса = ТекстЗапроса + ",
		|	РегистрСведений." + СтандартныйРеквизит;
	КонецЦикла;
	ТекстЗапроса = ТекстЗапроса + "
	|ПОМЕСТИТЬ " + ИмяСоздаваемойТаблицы + "
	|ИЗ
	|	РегистрСведений." + ИмяРегистра + " КАК РегистрСведений
	|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ " + ИмяТаблицыИзмерений + " КАК ИзмеренияДаты
	|		ПО (ИзмеренияДаты." + ИзмерениеФильтраДатаНачала + " = ДАТАВРЕМЯ(1, 1, 1) ИЛИ РегистрСведений.Период >= ИзмеренияДаты." + ИзмерениеФильтраДатаНачала + ")
	|	И (ИзмеренияДаты." + ИзмерениеФильтраДатаОкончания + " = ДАТАВРЕМЯ(1, 1, 1) ИЛИ РегистрСведений.Период <= ИзмеренияДаты." + ИзмерениеФильтраДатаОкончания + ") И ";
	
	Для Каждого Измерение Из КоллекцииПолей.ИзмеренияФильтра Цикл
		ИзмерениеФильтра = СоответствиеИзмеренийПолямТаблицы.Получить(Измерение);
		Если ИзмерениеФильтра = Неопределено Тогда
			ИзмерениеФильтра = Измерение;
		КонецЕсли;
		ТекстЗапроса = ТекстЗапроса + "(ИзмеренияДаты." + ИзмерениеФильтра + " = РегистрСведений." + Измерение + ") И ";
	КонецЦикла;
	
	ТекстЗапроса = Лев(ТекстЗапроса, СтрДлина(ТекстЗапроса) - 3);
	
	Если Отбор <> Неопределено И Отбор.Количество() > 0 Тогда
		СчПараметров = 1;
		ТекстОтбор = "
		|	ГДЕ (";
		
		Для Каждого СтруктураОтбора Из Отбор Цикл
			Если ТипЗнч(СтруктураОтбора.ПравоеЗначение) = Тип("Строка") Тогда
				ОписаниеПараметра = СтруктураОтбора.ПравоеЗначение;
			Иначе
				ИмяПараметра = ИмяСоздаваемойТаблицы +"_Параметр" + СчПараметров;
				ОписаниеПараметра = "&" + ИмяПараметра;
				Запрос.УстановитьПараметр(ИмяПараметра, СтруктураОтбора.ПравоеЗначение);
			КонецЕсли;
			ТекстОтбор = ТекстОтбор + "
			|	РегистрСведений." + СтруктураОтбора.ЛевоеЗначение + " " + СтруктураОтбора.ВидСравнения + " (" + ОписаниеПараметра + ") И";
			СчПараметров = СчПараметров + 1;
		КонецЦикла;	
		ТекстОтбор = Лев(ТекстОтбор, СтрДлина(ТекстОтбор) - 1);
		ТекстОтбор = ТекстОтбор + ")";
		ТекстЗапроса = ТекстЗапроса + ТекстОтбор;
	КонецЕсли;	
	
	ТекстОтборовСКД = "";
	Для каждого Измерение Из КоллекцииПолей.ИзмеренияФильтра Цикл
		ТекстОтборовСКД = ?(ПустаяСтрока(ТекстОтборовСКД), "", ТекстОтборовСКД + "," + Символы.ПС) + "	РегистрСведений." + Измерение + ".*";
	КонецЦикла;
	
	Если НЕ ПустаяСтрока(ТекстОтборовСКД) Тогда
		ТекстЗапроса = ТекстЗапроса + "
			|{ГДЕ
			|" + ТекстОтборовСКД + "}";
	КонецЕсли; 
	
	Если КоллекцииПолей.ВозвратныеРесурсы.Количество() > 0 Тогда
			
		ТекстЗапроса = ТекстЗапроса + "
		|
		|ОБЪЕДИНИТЬ ВСЕ
		|
		|ВЫБРАТЬ
		|	РегистрСведений.ДействуетДо";
		
		Для Каждого Измерение Из КоллекцииПолей.Измерения Цикл
			ТекстЗапроса = ТекстЗапроса + ",
			|	РегистрСведений." + Измерение;
		КонецЦикла;
		Для Каждого Ресурс Из КоллекцииПолей.ВозвратныеРесурсы Цикл
			ТекстЗапроса = ТекстЗапроса + ",
			|	РегистрСведений." + Ресурс + "ПоОкончании";
		КонецЦикла;
		Для Каждого Ресурс Из КоллекцииПолей.Ресурсы Цикл
			ТекстЗапроса = ТекстЗапроса + ",
			|	РегистрСведений." + Ресурс;
		КонецЦикла;
		Для Каждого Реквизит Из КоллекцииПолей.Реквизиты Цикл
			ТекстЗапроса = ТекстЗапроса + ",
			|	РегистрСведений." + Реквизит;
		КонецЦикла;
		Для Каждого СтандартныйРеквизит Из КоллекцииПолей.СтандартныеРеквизиты Цикл
			ТекстЗапроса = ТекстЗапроса + ",
			|	РегистрСведений." + СтандартныйРеквизит;
		КонецЦикла;
		ТекстЗапроса = ТекстЗапроса + "
		|ИЗ
		|	РегистрСведений." + ИмяРегистра + " КАК РегистрСведений
		|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ " + ИмяТаблицыИзмерений + " КАК ИзмеренияДаты
		|		ПО (ИзмеренияДаты." + ИзмерениеФильтраДатаНачала + " = ДАТАВРЕМЯ(1, 1, 1) ИЛИ РегистрСведений.ДействуетДо >= ИзмеренияДаты." + ИзмерениеФильтраДатаНачала + ")
		|	И (ИзмеренияДаты." + ИзмерениеФильтраДатаОкончания + " = ДАТАВРЕМЯ(1, 1, 1) ИЛИ РегистрСведений.ДействуетДо <= ИзмеренияДаты." + ИзмерениеФильтраДатаОкончания + ")
		|	И РегистрСведений.ДействуетДо <> ДАТАВРЕМЯ(1, 1, 1) И ";

		Для Каждого Измерение Из КоллекцииПолей.ИзмеренияФильтра Цикл
			Если ВРег(Измерение) <> ВРег("ДатаНачала") И ВРег(Измерение) <> ВРег("ДатаОкончания") Тогда
				ИзмерениеФильтра = СоответствиеИзмеренийПолямТаблицы.Получить(Измерение);
				Если ИзмерениеФильтра = Неопределено Тогда
					ИзмерениеФильтра = Измерение;
				КонецЕсли;
				ТекстЗапроса = ТекстЗапроса + "(ИзмеренияДаты." + ИзмерениеФильтра + " = РегистрСведений." + Измерение + ") И ";
			КонецЕсли;	
		КонецЦикла;
	
		ТекстЗапроса = Лев(ТекстЗапроса, СтрДлина(ТекстЗапроса) - 3);
		
		ТекстЗапроса = ТекстЗапроса + "
		|		{ЛЕВОЕ СОЕДИНЕНИЕ РегистрСведений." + ИмяРегистра + " КАК РегистрСведенийВспом
		|		ПО РегистрСведений.Период < РегистрСведенийВспом.Период
		|			И РегистрСведений.ДействуетДо >= РегистрСведенийВспом.Период";
		Для Каждого Измерение Из КоллекцииПолей.Измерения Цикл
			ТекстЗапроса = ТекстЗапроса + "
			|			И РегистрСведений." + Измерение + " = РегистрСведенийВспом." + Измерение;
		КонецЦикла;
		ТекстЗапроса = ТекстЗапроса + "}";
		ТекстЗапроса = ТекстЗапроса + "
		|ГДЕ
		|	РегистрСведенийВспом.Период ЕСТЬ NULL";
		
		Если Отбор <> Неопределено И Отбор.Количество() > 0 Тогда
			СчПараметров = 1;
			ТекстОтбор = "
			|	И (";
			Для Каждого СтруктураОтбора Из Отбор Цикл
				Если ТипЗнч(СтруктураОтбора.ПравоеЗначение) = Тип("Строка") Тогда
					ОписаниеПараметра = СтруктураОтбора.ПравоеЗначение;
				Иначе
					ИмяПараметра = ИмяСоздаваемойТаблицы +"_Параметр" + СчПараметров;
					ОписаниеПараметра = "&" + ИмяПараметра;
					Запрос.УстановитьПараметр(ИмяПараметра, СтруктураОтбора.ПравоеЗначение);
				КонецЕсли;
				ТекстОтбор = ТекстОтбор + "
				|	РегистрСведений." + СтруктураОтбора.ЛевоеЗначение + " " + СтруктураОтбора.ВидСравнения + " (" + ОписаниеПараметра + ") И";
				СчПараметров = СчПараметров + 1;
			КонецЦикла;	
			ТекстОтбор = Лев(ТекстОтбор, СтрДлина(ТекстОтбор) - 1);
			ТекстОтбор = ТекстОтбор + ")";
			ТекстЗапроса = ТекстЗапроса + ТекстОтбор;
		КонецЕсли;	
		
	КонецЕсли;
	
	Если НЕ ТолькоРазрешенные Тогда
		ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "ВЫБРАТЬ РАЗРЕШЕННЫЕ", "ВЫБРАТЬ");
	КонецЕсли;
	
	Запрос.Текст = ТекстЗапроса;
	
	Возврат Запрос;
	
КонецФункции

Функция АдресаОрганизаций(Организации) Экспорт
	
	ВозвращаемоеЗначение = Новый Соответствие;
	
	Запрос = Новый Запрос;
	Запрос.МенеджерВременныхТаблиц = Новый МенеджерВременныхТаблиц;
	
	Если ТипЗнч(Организации) = Тип("СправочникСсылка.Организации") Тогда
		МассивОрганизаций = ОбщегоНазначенияКлиентСервер.ЗначениеВМассиве(Организации);
	Иначе
		МассивОрганизаций = Организации;
	КонецЕсли;
	
	ВидыАдресов = Новый Массив;
	ВидыАдресов.Добавить(Справочники.ВидыКонтактнойИнформации.ФактАдресОрганизации);
	ВидыАдресов.Добавить(Справочники.ВидыКонтактнойИнформации.ЮрАдресОрганизации);
	
	УправлениеКонтактнойИнформацией.СоздатьВТКонтактнаяИнформация(Запрос.МенеджерВременныхТаблиц, МассивОрганизаций, , ВидыАдресов);
	
	Запрос.Текст =
		"ВЫБРАТЬ
		|	ОрганизацииКонтактнаяИнформация.Объект КАК Объект,
		|	ОрганизацииКонтактнаяИнформация.Вид,
		|	ОрганизацииКонтактнаяИнформация.Представление,
		|	ОрганизацииКонтактнаяИнформация.ЗначенияПолей
		|ИЗ
		|	ВТКонтактнаяИнформация КАК ОрганизацииКонтактнаяИнформация
		|ИТОГИ ПО
		|	Объект";
		
	ВыборкаОрганизаций = Запрос.Выполнить().Выбрать(ОбходРезультатаЗапроса.ПоГруппировкам);
	Пока ВыборкаОрганизаций.Следующий() Цикл
		
		СоотвествиеАдресовОрганизации = Новый Соответствие;
		ВыборкаПоВидам = ВыборкаОрганизаций.Выбрать();
		Пока ВыборкаПоВидам.Следующий() Цикл
			
			СтруктураАдреса = СтруктураПустогоАдресаОрганизации();
			ЗаполнитьЗначенияСвойств(СтруктураАдреса, ВыборкаПоВидам);
			
			АдресСтруктура = УправлениеКонтактнойИнформацией.ПредыдущаяСтруктураКонтактнойИнформацииXML(
				ВыборкаПоВидам.ЗначенияПолей, ВыборкаПоВидам.Вид);
				
			Если АдресСтруктура.Свойство("Город") Тогда
				
				СтруктураАдреса.Город = АдресСтруктура.Город;
				Если АдресСтруктура.Свойство("ГородСокращение") Тогда
					СтруктураАдреса.Город = Лев(СтруктураАдреса.Город, СтрДлина(СтруктураАдреса.Город) - СтрДлина(АдресСтруктура.ГородСокращение) - 1);
				КонецЕсли;
				
			КонецЕсли; 
			
			СоотвествиеАдресовОрганизации.Вставить(ВыборкаПоВидам.Вид, СтруктураАдреса);
			
		КонецЦикла; 
		
		ВозвращаемоеЗначение.Вставить(ВыборкаОрганизаций.Объект, СоотвествиеАдресовОрганизации);
		
	КонецЦикла;
	
	Возврат ВозвращаемоеЗначение;
	
КонецФункции

Функция АдресОрганизации(АдресаОрганизаций, Организация, ВидАдреса) Экспорт
	
	АдресОрганизации = СтруктураПустогоАдресаОрганизации();
	
	АдресаОрганизации = АдресаОрганизаций.Получить(Организация);
	Если АдресаОрганизации <> Неопределено Тогда
		Адрес = АдресаОрганизации.Получить(ВидАдреса);
		Если Адрес <> Неопределено Тогда
				АдресОрганизации = Адрес;
		КонецЕсли; 
	КонецЕсли; 
		
	Возврат АдресОрганизации;
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Универсальные процедуры и функции

// Заполняет данные выбора справочника при вводе по строке и автоподборе в справочнике
// Предназначена для вызова из обработчика ОбработкаПолученияДанныхВыбора в том случае, когда 
// обработка получения данных выбора выполняется "особым образом" (с выполнением особенного запроса).
//
// Параметры:
//		ДанныеВыбора
//		МетаданныеОбъекта - метаданные справочника для которого переопределяется обработка получения данных выбора
//		Отбор - параметры отбора, переданные в ОбработкаПолученияДанныхВыбора 
//		Запрос - Запрос с предустановленными параметрами текст запроса, который необходимо выполнять.
//			ВНИМАНИЕ! Запрос обязательно должен быть построен по схеме:
//				ВЫБРАТЬ * 
//				ИЗ 
//					... КАК <Псевдоним>
//				...
//			Текст запроса дополняется необходимыми функциями
//		ПсевдонимТаблицы - псевдоним основной таблицы в тексте переданного запроса.
//
Процедура ЗаполнитьДанныеВыбораСправочника(ДанныеВыбора, МетаданныеОбъекта, Отбор, Запрос, ПсевдонимТаблицы) Экспорт
	
	ЗапросТекст = Запрос.Текст;
	
	ЗапросТекст = СтрЗаменить(ЗапросТекст, " *", 
		" ПЕРВЫЕ 51
		|	" + ПсевдонимТаблицы + ".Ссылка,
		|	" + ПсевдонимТаблицы + ".ПометкаУдаления,
		|	" + ПсевдонимТаблицы + ".Код,
		|	" + ПсевдонимТаблицы + ".Наименование");
		
	Если МетаданныеОбъекта.ДлинаКода = 0 Тогда
		ЗапросТекст = СтрЗаменить(ЗапросТекст, ",
		|	" + ПсевдонимТаблицы + ".Код", "");
	КонецЕсли;
	Если МетаданныеОбъекта.ДлинаНаименования = 0 Тогда
		ЗапросТекст = СтрЗаменить(ЗапросТекст, ",
		|	" + ПсевдонимТаблицы + ".Наименование", "");
	КонецЕсли;
	
	ЗапросТекст = ЗапросТекст + "
		|
		|УПОРЯДОЧИТЬ ПО
		|	Наименование";
	
	КоличествоЭлементов = 51;
	ДанныеВыбора = Новый СписокЗначений;
	Если МетаданныеОбъекта.ОсновноеПредставление = Метаданные.СвойстваОбъектов.ОсновноеПредставлениеСправочника.ВВидеНаименования И МетаданныеОбъекта.ДлинаНаименования > 0 Тогда 
		ПолеОсновногоПредставления = "Наименование";
		Если МетаданныеОбъекта.ДлинаКода > 0 Тогда
			ПолеДопПредставления = "Код";
		Иначе
			ПолеДопПредставления = "";
		КонецЕсли;
	ИначеЕсли МетаданныеОбъекта.ДлинаКода > 0 Тогда
		ПолеОсновногоПредставления = "Код";
		Если МетаданныеОбъекта.ДлинаНаименования > 0 Тогда
			ПолеДопПредставления = "Наименование";
		Иначе
			ПолеДопПредставления = "";
		КонецЕсли;
	Иначе
		ПолеОсновногоПредставления = "";
		ПолеДопПредставления = "";
	КонецЕсли;
	
	ДополнительноеУсловие = "";
	
	Для Каждого ЭлементОтбора Из Отбор Цикл
		Реквизит = МетаданныеОбъекта.Реквизиты.Найти(ЭлементОтбора.Ключ);
		Если Реквизит <> НеОпределено Тогда
			Если ТипЗнч(ЭлементОтбора.Значение) = Тип("Массив") Тогда
				ДополнительноеУсловие = "
				|	И " + ПсевдонимТаблицы + "." + ЭлементОтбора.Ключ + " В (&" + ЭлементОтбора.Ключ + ")";
			Иначе
				ДополнительноеУсловие = "
				|	И " + ПсевдонимТаблицы + "." + ЭлементОтбора.Ключ + " = &" + ЭлементОтбора.Ключ;
			КонецЕсли;	
			Запрос.УстановитьПараметр(ЭлементОтбора.Ключ, ЭлементОтбора.Значение);
		КонецЕсли;
	КонецЦикла;
	
	Для Каждого Поле Из МетаданныеОбъекта.ВводПоСтроке Цикл
		ТекстЗапроса = ЗапросТекст;
	
		ИмяПоля = Поле.Имя;
		
		// установим в запросе условие
		ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "И &ДополнительноеУсловие", ДополнительноеУсловие + "
		|И " + ПсевдонимТаблицы + "." + ИмяПоля + " ПОДОБНО &СтрокаПоиска");
		
		// допишем в поля выборки поле поиска
		Если ИмяПоля <> ПолеОсновногоПредставления И ИмяПоля <> ПолеДопПредставления Тогда
			ТекстЗапроса = СтрЗаменить(ТекстЗапроса, " ПЕРВЫЕ 51", " ПЕРВЫЕ 51
				|	" + ПсевдонимТаблицы + "." + ИмяПоля + " КАК ПолеПоиска,");
		КонецЕсли;
		
		// установим число выбираемых элементов
		ТекстЗапроса = СтрЗаменить(ТекстЗапроса, " ПЕРВЫЕ 51", " ПЕРВЫЕ " + Строка(КоличествоЭлементов));
		
		Запрос.Текст = ТекстЗапроса;
		Выборка = Запрос.Выполнить().Выбрать();
		Пока Выборка.Следующий() Цикл
			Если ПолеОсновногоПредставления = ИмяПоля Тогда
				Если ПустаяСтрока(ПолеДопПредставления) Тогда
					Представление = СокрЛП(Выборка[ПолеОсновногоПредставления]);
				Иначе
					Представление = СокрЛП(Выборка[ПолеОсновногоПредставления]) + " (" + СокрЛП(Выборка[ПолеДопПредставления]) + ")";
				КонецЕсли;
			ИначеЕсли ПолеДопПредставления = ИмяПоля Тогда
				Представление = Выборка[ПолеДопПредставления] + " (" + СокрЛП(Выборка[ПолеОсновногоПредставления]) + ")";
			Иначе
				Представление = Выборка.ПолеПоиска + " (" + СокрЛП(Выборка[ПолеОсновногоПредставления]) + ")";
			КонецЕсли;
			ДанныеВыбора.Добавить(Выборка.Ссылка, Представление);
			
		КонецЦикла;
		КоличествоЭлементов = КоличествоЭлементов - Выборка.Количество();
		Если КоличествоЭлементов <= 0 Тогда
			Прервать;
		КонецЕсли;
		
	КонецЦикла;
	
	ДанныеВыбора.СортироватьПоПредставлению();

КонецПроцедуры

// Готовит данные выбора для справочников - классификаторов, упорядочивает по коду
//
Процедура ПодготовитьДанныеВыбораКлассификаторовСПорядкомКодов(ДанныеВыбора, Параметры, СтандартнаяОбработка, ПолноеИмяОбъектаМетаданных) Экспорт
	
	Запрос = Новый Запрос;
	
	ДанныеВыбора = Новый СписокЗначений;
	
	Запрос.Текст =
		"ВЫБРАТЬ РАЗРЕШЕННЫЕ ПЕРВЫЕ 51
		|	СписокСправочника.Ссылка,
		|	СписокСправочника.Код КАК Код,
		|	СписокСправочника.Наименование,
		|	ИСТИНА КАК НайденПоКоду
		|ИЗ
		|	&СписокСправочника КАК СписокСправочника
		|ГДЕ &ТекстУсловийОтбораПоКодам
		|
		|ОБЪЕДИНИТЬ ВСЕ
		|
		|ВЫБРАТЬ
		|	СписокСправочника.Ссылка,
		|	СписокСправочника.Код,
		|	СписокСправочника.Наименование,
		|	ЛОЖЬ
		|ИЗ
		|	&СписокСправочника КАК СписокСправочника
		|ГДЕ &ТекстУсловийОтбораПоНаименованиям
		|
		|УПОРЯДОЧИТЬ ПО
		|	Код";
		
	Запрос.Текст = СтрЗаменить(Запрос.Текст, "&СписокСправочника", ПолноеИмяОбъектаМетаданных);
	
	УстановитьОтборВЗапросеПоПараметрам(Запрос, Параметры);
		
	Выборка = Запрос.Выполнить().Выбрать();
		
	Пока Выборка.Следующий() Цикл
		
		Если ДанныеВыбора.НайтиПоЗначению(Выборка.Ссылка) = Неопределено Тогда
			
			Если Выборка.НайденПоКоду Тогда
				Представление = СокрЛП(Выборка.Код) + " (" + Выборка.Наименование + ")";
			Иначе
				Представление = Выборка.Наименование + " (" + СокрЛП(Выборка.Код) + ")";
			КонецЕсли;
			
			ДанныеВыбора.Добавить(Выборка.Ссылка, Представление);
			
		КонецЕсли; 
		
	КонецЦикла;
		
	СтандартнаяОбработка = Ложь;
	
КонецПроцедуры

Процедура ПодготовитьДанныеВыбораКлассификаторовСПорядкомРеквизитаДопУпорядочивания(ДанныеВыбора, Параметры, СтандартнаяОбработка, ПолноеИмяОбъектаМетаданных) Экспорт
	
	Запрос = Новый Запрос;
	
	ДанныеВыбора = Новый СписокЗначений;
	
	Запрос.Текст =
		"ВЫБРАТЬ
		|	СписокСправочника.Ссылка
		|ИЗ
		|	&СписокСправочника КАК СписокСправочника
		|ГДЕ &ТекстУсловийОтбораПоНаименованиям
		|
		|УПОРЯДОЧИТЬ ПО
		|	СписокСправочника.РеквизитДопУпорядочивания";
	
	Запрос.Текст = СтрЗаменить(Запрос.Текст, "&СписокСправочника", ПолноеИмяОбъектаМетаданных);
	
	УстановитьОтборВЗапросеПоПараметрам(Запрос, Параметры);
		
	Выборка = Запрос.Выполнить().Выбрать();
	Пока Выборка.Следующий() Цикл
		ДанныеВыбора.Добавить(Выборка.Ссылка);
	КонецЦикла;
	
КонецПроцедуры

// Создает структуру наборов записей, имитирующую коллекцию движений регистратора.
// Может применяться для временного использования методов, формирующих движения, 
// когда регистратор пока не записан.
//
// Параметры
//	МетаданныеРегистратора
//
// Возвращаемое значение:
//		Структура - где ключ имя набора, значение - набор записей с отбором по временной ссылке.
//
Функция НаборыЗаписейРегистратора(МетаданныеРегистратора, ВременнаяСсылка = Неопределено, ПропуститьПроверкуЗапретаИзменения = Истина) Экспорт
	
	НаборыЗаписей = Новый Структура;
	
	Если ВременнаяСсылка = Неопределено Тогда
		ВременнаяСсылка = ОбщегоНазначения.МенеджерОбъектаПоПолномуИмени(МетаданныеРегистратора.ПолноеИмя()).ПолучитьСсылку();
	КонецЕсли;
	
	Для Каждого МетаданныеНабора Из МетаданныеРегистратора.Движения Цикл
		Менеджер = ОбщегоНазначения.МенеджерОбъектаПоПолномуИмени(МетаданныеНабора.ПолноеИмя());
		НаборЗаписей = Менеджер.СоздатьНаборЗаписей();
		НаборЗаписей.Отбор.Регистратор.Установить(ВременнаяСсылка);
		НаборЗаписей.Записывать = Истина;
		Если ПропуститьПроверкуЗапретаИзменения Тогда
			НаборЗаписей.ДополнительныеСвойства.Вставить("ПропуститьПроверкуЗапретаИзменения");
		КонецЕсли;
		НаборыЗаписей.Вставить(МетаданныеНабора.Имя, НаборЗаписей);
	КонецЦикла;
	
	Возврат НаборыЗаписей;
	
КонецФункции

///////////////////////////////////////////////////////////////////////////////
// Формирование печатных форм

// Выводит строки по данным заполнения в результирующий табличный документ,
// в количестве не превышающем "ОграничениеСтрок".
// Остальные строки выводятся в дополнительные страницы, которые помещаются в массив "ОбластиДополнительныхСтрок".
//
// Параметры:
//		ТабличныйДокумент - результирующий табличный документ.
//		ДанныеЗаполнения - коллекция с данными для заполнения строк,
//						коллекция доступна для обхода циклом Для Каждого … Из … Цикл.
//		ОграничениеСтрок - число, количество строк, размещаемых в основной области.
//		ОбластиДополнительныхСтрок - массив областей с дополнительными строками.
//		ОбластьШапка - область табличного документа для шапки.
//		ОбластьСтрока - область табличного документа для строки.
//		МассивОбластейЗаголовок - массив областей табличного документа для заголовка, выводятся по порядку.
//		МассивОбластейПодвал - массив областей табличного документа для подвала, выводятся по порядку.
//		ВыводитьСтрокиНаВсюСтраницу - Если Истина, то до конца дополнительной страницы будут выведены пустые строки.
//
Процедура СформироватьОбластьТабличногоДокументаСОграниченнымНаборомСтрок(ТабличныйДокумент, ДанныеЗаполнения, ОграничениеСтрок,
	ОбластиДополнительныхСтрок, ОбластьШапка, ОбластьСтрока, МассивОбластейЗаголовок = Неопределено, МассивОбластейПодвал = Неопределено,
	ВыводитьСтрокиНаВсюСтраницу = Ложь) Экспорт
	
	КоличествоВыведенныхСтрок = 0;
	ДополнительнаяСтраница = Новый ТабличныйДокумент;
	
	Для каждого СтрокаДанныхЗаполнения Из ДанныеЗаполнения Цикл
		
		КоличествоВыведенныхСтрок = КоличествоВыведенныхСтрок + 1;
		
		// Если выводимая строка помещается в основной табличный документ
		Если КоличествоВыведенныхСтрок <= ОграничениеСтрок Тогда
			ОбластьСтрока.Параметры.Заполнить(СтрокаДанныхЗаполнения);
			ТабличныйДокумент.Вывести(ОбластьСтрока);
		КонецЕсли;
		
		// Если выводимая строка не помещается в основной табличный документ, то нужно вывести
		// заголовок и шапку для дополнительной страницы.
		Если КоличествоВыведенныхСтрок = ОграничениеСтрок + 1 Тогда
			
			// Если задан заголовок для дополнительной страницы - выведем его
			Если МассивОбластейЗаголовок <> Неопределено Тогда
				СтруктураПараметров = Новый Структура("НомерПриложения", ОбластиДополнительныхСтрок.Количество() + 1);
				Для каждого ОбластьЗаголовок Из МассивОбластейЗаголовок Цикл
					ОбластьЗаголовок.Параметры.Заполнить(СтруктураПараметров);
					ДополнительнаяСтраница.Вывести(ОбластьЗаголовок);
				КонецЦикла;
			КонецЕсли;
			
			// Выводим шапку дополнительной страницы
			ДополнительнаяСтраница.Вывести(ОбластьШапка);
			
			// Повторяем шапку на каждой странице при печати
			ДополнительнаяСтраница.ПовторятьПриПечатиСтроки = ОбластьШапка;
			
		КонецЕсли;
		
		// Все строки, которые не поместились в основной табличный документ выводим в дополнительную страницу.
		Если КоличествоВыведенныхСтрок > ОграничениеСтрок Тогда
			ОбластьСтрока.Параметры.Заполнить(СтрокаДанныхЗаполнения);
			ДополнительнаяСтраница.Вывести(ОбластьСтрока);
		КонецЕсли;
		
	КонецЦикла;
	
	// Если создавали дополнительную страницу нужно вывести подвал и надпись о продолжении таблицы.
	Если КоличествоВыведенныхСтрок > ОграничениеСтрок Тогда
		
		// Выводим пустые строки до конца дополнительной страницы
		Если ВыводитьСтрокиНаВсюСтраницу Тогда
			
			Для ПараметрОбласти = 0 По ОбластьСтрока.Параметры.Количество() -1 Цикл
				ОбластьСтрока.Параметры[ПараметрОбласти] = Неопределено;
			КонецЦикла;
			
			ВыводимыеОбласти = Новый Массив();
			ВыводимыеОбласти.Добавить(ОбластьСтрока);
			Если МассивОбластейПодвал <> Неопределено Тогда
				Для каждого ОбластьПодвал Из МассивОбластейПодвал Цикл
					ВыводимыеОбласти.Добавить(ОбластьПодвал);
				КонецЦикла;
			КонецЕсли;
			
			Пока ОбщегоНазначения.ПроверитьВыводТабличногоДокумента(ДополнительнаяСтраница, ВыводимыеОбласти, Ложь) Цикл
				ДополнительнаяСтраница.Вывести(ОбластьСтрока);
			КонецЦикла;
			
		КонецЕсли;
		
		// Если задан подвал для дополнительной страницы - выведем его
		Если МассивОбластейПодвал <> Неопределено Тогда
			Для каждого ОбластьПодвал Из МассивОбластейПодвал Цикл
				ДополнительнаяСтраница.Вывести(ОбластьПодвал);
			КонецЦикла;
		КонецЕсли;
		
		// Поместим созданную страницу в массив
		ОбластиДополнительныхСтрок.Добавить(ДополнительнаяСтраница);
		
		// В основном табличном документе напишем, что есть дополнительная страница
		ОбластьНадписи = ОбластьСтрока.Область(1,1, ОбластьСтрока.ВысотаТаблицы, ОбластьСтрока.ШиринаТаблицы);
		ОбластьНадписи.Объединить();
		ОбластьНадписи.Очистить(Истина, Истина, Истина);
		ТекстНадписи = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				НСтр("ru = 'Продолжение таблицы см. в дополнении к документу №%1.'"),
				ОбластиДополнительныхСтрок.Количество());
		ОбластьНадписи.Текст = ТекстНадписи;
		ОбластьНадписи.ГоризонтальноеПоложение = ГоризонтальноеПоложение.Право;
		ТабличныйДокумент.Вывести(ОбластьСтрока);
		
	// В основном табличном документе выведем пустые строки до заданного количества "ОграничениеСтрок".
	ИначеЕсли КоличествоВыведенныхСтрок < ОграничениеСтрок Тогда
		
		Для ПараметрОбласти = 0 По ОбластьСтрока.Параметры.Количество() -1 Цикл
			ОбластьСтрока.Параметры[ПараметрОбласти] = Неопределено;
		КонецЦикла;
		
		Для Шаг = КоличествоВыведенныхСтрок + 1 По ОграничениеСтрок Цикл
			ТабличныйДокумент.Вывести(ОбластьСтрока);
		КонецЦикла;
		
	КонецЕсли;
	
КонецПроцедуры

// Выводит дополнительные страницы в результирующий табличный документ
//
// Параметры:
//		ТабличныйДокумент - результирующий табличный документ
//		ОбластиДополнительныхСтрок - массив областей с дополнительными строками.
//
Процедура ВывестиОбластиТабличногоДокументаСОграниченнымНаборомСтрок(ТабличныйДокумент, ОбластиДополнительныхСтрок) Экспорт
	
	Для каждого ДополнительнаяСтраница Из ОбластиДополнительныхСтрок Цикл
		ТабличныйДокумент.ВывестиГоризонтальныйРазделительСтраниц();
		ТабличныйДокумент.Вывести(ДополнительнаяСтраница);
	КонецЦикла;
	
КонецПроцедуры

// Выводит данные побуквенно
// Параметры:
//			Данные - Строка, которую нужно вывести
//			Раздел - Макет (область) табличного документа в которую нужно вывести
//			ИмяПоказателя - Строка, имя ячейки в области к которой прибавляется номер позиции в имени показателя
//			КоличествоЯчеек - Число, количество ячеек в которые нужно вывести данные
//			НачальнаяЯчейка - Число, ячейка с которой нужно начать побуквенный вывод.
Процедура ВывестиДанныеПоБуквенно(Данные, Раздел, ИмяПоказателя, КоличествоЯчеек, НачальнаяЯчейка = 1) Экспорт

	Для НомЯчейки = НачальнаяЯчейка По НачальнаяЯчейка + КоличествоЯчеек - 1 Цикл
		Раздел.Области[ИмяПоказателя + Формат(НомЯчейки,"ЧГ=0")].Текст = Сред(Данные, НомЯчейки - НачальнаяЯчейка + 1, 1);
	КонецЦикла;

КонецПроцедуры

// Разбивает строку (не разрывая слов) на подстроки указанной длинны, 
//							строки дополняются пробелами, переводы строк удаляются
// Параметры
//  ТекстСтроки  - Строка, которую необходимо разбить на подстроки.
//                 
//  МассивДлинСтрок  - Массив длин строк, если в результирующей строке оказалось подстрок больше
//                     Чем кодичество указанных длин, то все "лишние" строки выравниваются по последнему
//                     значению длинны строки.
// Возвращаемое значение:
//   Строка   - разбитая на подстроки указанной длинны.
//
Функция РазбитьСтрокуНаПодСтроки(Знач ТекстСтроки, МассивДлинСтрок) Экспорт

	ВозвращаемаяСтрока = "";
	
	РазделителиСлов = " .,:;?!%\<>+-*/=_" + Символы.ПС;
	
	ТекстСтроки = СокрЛП(ТекстСтроки);
	
	// обыграем случай, когда у нас многострочная строка
	Если СтрЧислоСтрок(ТекстСтроки) > 1 Тогда
	
		Для НомерПодстроки = 1 По СтрЧислоСтрок(ТекстСтроки) Цикл
			
			НовыйМассивДлинСтроки = Новый Массив;
			
			Если НомерПодстроки = 1 Тогда
			
				НачальнаяГраница = 0;
			
			Иначе
				
				Если СтрЧислоСтрок(ВозвращаемаяСтрока) > МассивДлинСтрок.ВГраница() Тогда
				
					НачальнаяГраница = МассивДлинСтрок.ВГраница();
					
				Иначе
					
					НачальнаяГраница = СтрЧислоСтрок(ВозвращаемаяСтрока);
				
				КонецЕсли; 
			
			КонецЕсли; 
			
			Для ИндексСтроки = НачальнаяГраница По МассивДлинСтрок.ВГраница() Цикл
			
				НовыйМассивДлинСтроки.Добавить(МассивДлинСтрок[ИндексСтроки]);
			
			КонецЦикла; 
		
			ВозвращаемаяСтрока = ВозвращаемаяСтрока + ?(ПустаяСтрока(ВозвращаемаяСтрока), "", Символы.ПС) + РазбитьСтрокуНаПодСтроки(СтрПолучитьСтроку(ТекстСтроки, НомерПодстроки), НовыйМассивДлинСтроки);
		
		КонецЦикла; 
		
	Иначе
		
		ДлинаСтроки = МассивДлинСтрок[0];
		
		// Если длина строки меньше или равна нужной длине - просто вернем ее
		Если СтрДлина(ТекстСтроки) <= ДлинаСтроки Тогда
		
			ВозвращаемаяСтрока = ТекстСтроки; 
			
		Иначе
			
			// Заменим все разделители символом _, для удобства анализа
			ТестируемаяСтрока = ТекстСтроки;
			
			Для НомерРазделителя = 1 По СтрДлина(РазделителиСлов)  Цикл
				
				РазделительСлов = Сред(РазделителиСлов, НомерРазделителя, 1);
				
				ТестируемаяСтрока = СтрЗаменить(ТестируемаяСтрока, РазделительСлов, "_");
			
			КонецЦикла; 
			
			// Найдем первый разделитель
			Разрыв = Найти(ТестируемаяСтрока, "_");
			
			ИндексМассиваДлинСтрок = 0;
			
			// Обрабатываем строку пока она не закончится
			Пока СтрДлина(ТекстСтроки) > 0 Цикл
				
				Если ИндексМассиваДлинСтрок <= МассивДлинСтрок.ВГраница() Тогда
				
					ДлинаСтроки = МассивДлинСтрок[ИндексМассиваДлинСтрок];
				
				Иначе
				
					ДлинаСтроки = МассивДлинСтрок[МассивДлинСтрок.ВГраница()];
				
				КонецЕсли; 
				
				// Если разрыв больше чем нужная длина
				// если разрывов больше нет
				// и частный случай, когда есть разрыв - пробел в самом конце строки нужной длины
				// или длина оставшейся строки меньше или равна нужной длине.
				Если Разрыв >= ДлинаСтроки ИЛИ Разрыв = 0 ИЛИ Сред(ТекстСтроки, ДлинаСтроки + 1, 1) = " " ИЛИ СтрДлина(ТекстСтроки) <= ДлинаСтроки Тогда
				
					ВозвращаемаяСтрока = ВозвращаемаяСтрока + ?(ПустаяСтрока(ВозвращаемаяСтрока), "", Символы.ПС) + СокрЛП(Лев(ТекстСтроки, ДлинаСтроки));
					
					ТекстСтроки = СокрЛП(Сред(ТекстСтроки, ДлинаСтроки + 1));
					
					ТестируемаяСтрока = Сред(ТестируемаяСтрока, ДлинаСтроки + 1);
					
					Если Лев(ТестируемаяСтрока,1) = "_" Тогда
					
						ТестируемаяСтрока = Сред(ТестируемаяСтрока, 2);
					
					КонецЕсли; 
					
					ИндексМассиваДлинСтрок = ИндексМассиваДлинСтрок + 1;
					
					Разрыв = Найти(ТестируемаяСтрока, "_");
				
				Иначе 
					
					НовыйРазрыв = Найти(Сред(ТестируемаяСтрока, Разрыв + 1), "_");
					
					// Есть еще один разрыв и он вместе с предыдущим меньше или равен длине строки
					Если НовыйРазрыв > 0 И Разрыв + НовыйРазрыв <= ДлинаСтроки Тогда
						
						Разрыв = Разрыв + НовыйРазрыв;
						
					Иначе
						
						// Больше разрывов нет
						// или он вместе с предыдущим больше нужной длины.
						ВозвращаемаяСтрока = ВозвращаемаяСтрока + ?(ПустаяСтрока(ВозвращаемаяСтрока), "", Символы.ПС) + СокрЛП(Лев(ТекстСтроки, Разрыв));
						
						ТекстСтроки = СокрЛП(Сред(ТекстСтроки, Разрыв + 1));
						
						ТестируемаяСтрока = Сред(ТестируемаяСтрока, Разрыв + 1);
						
						Если Лев(ТестируемаяСтрока,1) = "_" Тогда
					
							ТестируемаяСтрока = Сред(ТестируемаяСтрока, 2);
					
						КонецЕсли; 
					
						ИндексМассиваДлинСтрок = ИндексМассиваДлинСтрок + 1;
					
						Разрыв = Найти(ТестируемаяСтрока, "_");
						
					КонецЕсли;
				
				КонецЕсли;
				
			КонецЦикла; 
				
		КонецЕсли; 
	
	КонецЕсли;
	
	Если СтрЧислоСтрок(ВозвращаемаяСтрока) > 1 Тогда
		
		ВыровненнаяСтрока = "";
		
		Для НомерПодстроки = 1 По СтрЧислоСтрок(ВозвращаемаяСтрока) - 1 Цикл
			
			ВыравниваемаяСтрока = СтрПолучитьСтроку(ВозвращаемаяСтрока, НомерПодстроки);
			
			Если НомерПодстроки - 1 <= МассивДлинСтрок.ВГраница() Тогда
				
				ДлинаСтроки = МассивДлинСтрок[НомерПодстроки - 1];
				
			Иначе
				
				ДлинаСтроки = МассивДлинСтрок[МассивДлинСтрок.ВГраница()];
				
			КонецЕсли; 
				
			Для НомерПозицииВСтроке = СтрДлина(ВыравниваемаяСтрока) + 1 По ДлинаСтроки Цикл
			
				ВыравниваемаяСтрока = ВыравниваемаяСтрока + " ";
			
			КонецЦикла; 
			
			ВыровненнаяСтрока = ВыровненнаяСтрока + ?(ПустаяСтрока(ВыровненнаяСтрока), "", Символы.ПС) + ВыравниваемаяСтрока;
		
		КонецЦикла;
		
		ВозвращаемаяСтрока = ВыровненнаяСтрока + Символы.ПС + СтрПолучитьСтроку(ВозвращаемаяСтрока, СтрЧислоСтрок(ВозвращаемаяСтрока));
		
	КонецЕсли; 
	
	ВозвращаемаяСтрока = СтрЗаменить(ВозвращаемаяСтрока, Символы.ПС, "");
	
	Возврат ВозвращаемаяСтрока;

КонецФункции // РазбитьСтрокуПоСтрочно()

// Выводит сумму в рублях и копейках в ячейки посимвольно.
// Параметры:
//			Данные - Строка, которую нужно вывести
//			ТабличныйДокумент - Макет (область) табличного документа в которую нужно вывести
//			ПрефиксЯчеек - Строка, имя ячейки в области к которой прибавляется номер позиции в имени показателя
//			КоличествоЯчеек - Число, количество ячеек в которые нужно вывести данные.
Процедура ВывестиСуммуВРубляхКопейкахВЯчейки(Данные, ТабличныйДокумент, ПрефиксЯчеек, КоличествоЯчеек) Экспорт
	ВывестиДанныеПоБуквенно(Прав("                  " + Формат(Данные, "ЧЦ=" + (КоличествоЯчеек + 1) + "; ЧДЦ=0; ЧС=-2; ЧГ="), КоличествоЯчеек), ТабличныйДокумент, ПрефиксЯчеек, КоличествоЯчеек);
КонецПроцедуры

// Возвращает ответственных лиц организации
//
// Параметры:
//		Организация - ссылка на организацию.
//		Сведения - строка с идентификаторами, разделенными запятыми.
//		ДатаСведений - дата получения сведений.
//
// Возвращаемое значение:
//		СтруктураДанных - структура со свойствами, совпадающими с параметром «Сведения».
//			Допустимые идентификаторы запрашиваемых значений:
//				Руководитель - руководитель организации.
//				ДолжностьРуководителя - должность руководителя.
//				ГлавныйБухгалтер - главбух организации.
//				Кассир - кассир организации.
//				ДолжностьКассира - должность кассира.
//
Функция ОтветственныеЛицаОрганизации(Организация, Сведения, ДатаСведений) Экспорт
	
КонецФункции

// Принимает Соответствие между замещаемыми ссылками и заменителями и заменяет ссылки по информационной базе.
Процедура ЗаменитьСсылки(ПарыЗамен) Экспорт
	КешПолей = Новый Соответствие;
	ДвиженияССубконтоИмя =
		?(Метаданные.ВариантВстроенногоЯзыка = Метаданные.СвойстваОбъектов.ВариантВстроенногоЯзыка.Английский,
		".RecordsWithExtDimensions",
		".ДвиженияССубконто");
	
	ЗаменяемыеСсылки = Новый Массив;
	Для Каждого Пара Из ПарыЗамен Цикл
		ЗаменяемыеСсылки.Добавить(Пара.Ключ);
	КонецЦикла;
	РезультатыПоиска = НайтиПоСсылкам(ЗаменяемыеСсылки);
	МаксимальныйИндекс = РезультатыПоиска.Количество() - 1;
	// (.Ссылка: исходная ссылка; .Данные: ссылающийся объект; .Метаданные: метаданные ссылающегося объекта).
	
 	Для Каждого Результат Из РезультатыПоиска Цикл
		Замещаемое = Результат.Ссылка;
		// объект, ссылающийся сам на себя не трогаем!
		Если Замещаемое = Результат.Данные Тогда
			Продолжить;
		КонецЕсли;

		ТипЗамещаемого = ТипЗнч(Замещаемое);
		Заменитель = ПарыЗамен[Результат.Ссылка];

		Если ЭтоСсылочныйОбъектМетаданных(Результат.Метаданные) Тогда
			// обработка самого объекта
			ОбъектДанных = Результат.Данные.ПолучитьОбъект();
			ИменаПолей = ИменаПолейСТипом(Результат.Метаданные.ПолноеИмя(), ТипЗамещаемого, КешПолей, "Ссылка, Ref");
			ЗаменитьЗначение(ОбъектДанных, ИменаПолей, Замещаемое, Заменитель);
			// обработка табчастей объекта
			Для Каждого Табчасть Из Результат.Метаданные.ТабличныеЧасти Цикл
				ИменаПолей = ИменаПолейСТипом(Результат.Метаданные.ПолноеИмя()+"."+Табчасть.Имя, ТипЗамещаемого, КешПолей, "Ссылка, Ref");
				Для Каждого Табстрока Из ОбъектДанных[Табчасть.Имя] Цикл
					ЗаменитьЗначение(Табстрока, ИменаПолей, Замещаемое, Заменитель);
				КонецЦикла;
			КонецЦикла;
			// обработка стандартных табчастей объекта
			Если Метаданные.ПланыСчетов.Содержит(Результат.Метаданные) Или Метаданные.ПланыВидовРасчета.Содержит(Результат.Метаданные) Тогда
				Для Каждого Табчасть Из Результат.Метаданные.СтандартныеТабличныеЧасти Цикл
					ИменаПолей = ИменаПолейСТипом(Результат.Метаданные.ПолноеИмя()+"."+Табчасть.Имя, ТипЗамещаемого, КешПолей, "Ссылка, Ref");
					Для Каждого Табстрока Из ОбъектДанных[Табчасть.Имя] Цикл
						ЗаменитьЗначение(Табстрока, ИменаПолей, Замещаемое, Заменитель);
					КонецЦикла;
				КонецЦикла;
			КонецЕсли;
			ЗаписатьДанные(ОбъектДанных);
			ОбъектДанных = Неопределено;
			// обработка движений документа
			Если Метаданные.Документы.Содержит(Результат.Метаданные) Тогда
				Для Каждого Движение Из Результат.Метаданные.Движения Цикл
					ДопТаблица = "";
					Если Метаданные.РегистрыНакопления.Содержит(Движение) Тогда
						Регистр = РегистрыНакопления[Движение.Имя];
					ИначеЕсли Метаданные.РегистрыСведений.Содержит(Движение) Тогда
						Регистр = РегистрыСведений[Движение.Имя];
					ИначеЕсли Метаданные.РегистрыБухгалтерии.Содержит(Движение) Тогда
						ДопТаблица = ДвиженияССубконтоИмя;
						Регистр = РегистрыБухгалтерии[Движение.Имя];
					ИначеЕсли Метаданные.РегистрыРасчета.Содержит(Движение) Тогда
						Регистр = РегистрыРасчета[Движение.Имя];
					КонецЕсли;
					ИменаПолей = ИменаПолейСТипом(Движение.ПолноеИмя() + ДопТаблица, ТипЗамещаемого, КешПолей, "Регистратор, Recorder");
					Набор = НаборЗаписей(Регистр, Новый Структура("Регистратор", Результат.Данные));
					ЗначениеЗаменено = Ложь;
					Для Каждого Запись Из Набор Цикл
						ЗаменитьЗначение(Запись, ИменаПолей, Замещаемое, Заменитель, ЗначениеЗаменено);
					КонецЦикла;
					ЗаписатьДанные(Набор, ЗначениеЗаменено);
				КонецЦикла;
				// обработка последовательностей, включающих документ
				Для Каждого Последовательность Из Метаданные.Последовательности Цикл
					Если Последовательность.Документы.Содержит(Результат.Метаданные) Тогда
						ИменаПолей = ИменаПолейСТипом(Последовательность.ПолноеИмя(), ТипЗамещаемого, КешПолей, "Регистратор, Recorder");
						Набор = НаборЗаписей(Последовательности[Последовательность.Имя], Новый Структура("Регистратор", Результат.Данные));
						Для Каждого Запись Из Набор Цикл
							ЗаменитьЗначение(Запись, ИменаПолей, Замещаемое, Заменитель);
						КонецЦикла;
						ЗаписатьДанные(Набор);
					КонецЕсли;
				КонецЦикла;
			КонецЕсли;
		// константы
		ИначеЕсли Метаданные.Константы.Содержит(Результат.Метаданные) Тогда
			Константы[Результат.Метаданные.Имя].Установить(Заменитель);
		// регистры сведений (необъектные таблицы)
		ИначеЕсли Метаданные.РегистрыСведений.Содержит(Результат.Метаданные) Тогда
			ИменаПолей = ИменаПолейСТипом(Результат.Метаданные.ПолноеИмя(), ТипЗамещаемого, КешПолей);
			Отборы = ОтборыРегистраСведений(Результат.Метаданные, Результат.Данные);
			Набор = НаборЗаписей(РегистрыСведений[Результат.Метаданные.Имя], Отборы);
			// Сохраняем старую запись набора и очищаем саму запись в БД
			Таблица = Набор.Выгрузить();
			Набор.Очистить();
			ЗаписатьДанные(Набор);
			// Заменяем значение в сохраненной записи и пишем ее в БД
			ЗаменитьЗначение(Таблица[0], ИменаПолей, Замещаемое, Заменитель);
			Для Каждого ИмяПоля Из ИменаПолей Цикл
				Если Отборы.Свойство(ИмяПоля) И Отборы[ИмяПоля] = Замещаемое Тогда
					Набор.Отбор[ИмяПоля].Установить(Заменитель);
				КонецЕсли
			КонецЦикла;
			Набор.Загрузить(Таблица);
			ЗаписатьДанные(Набор);
			// Заменим значение в таких же ключах записей следующих результатов поиска
			ИндексРезультата = РезультатыПоиска.Индекс(Результат);
			Для ИндексСледующего = ИндексРезультата + 1 По МаксимальныйИндекс Цикл
				Следующий = РезультатыПоиска[ИндексСледующего];
				Если ТипЗнч(Следующий.Данные) = ТипЗнч(Результат.Данные) Тогда
					СледующийСовпадает = Ложь;
					// Определяемся, что найденный ключ такой же, как обработанный
					Для Каждого Отбор Из Отборы Цикл
						СледующийСовпадает = (Следующий.Данные[Отбор.Ключ] = Отбор.Значение);
						Если Не СледующийСовпадает Тогда
							Прервать;
						КонецЕсли;
					КонецЦикла;
					// Меняем значение в совпадающем ключе записи
					Если СледующийСовпадает Тогда
						Для Каждого Отбор Из Отборы Цикл
							Если Следующий.Данные[Отбор.Ключ] = Замещаемое Тогда
								Следующий.Данные[Отбор.Ключ] = Заменитель;
							КонецЕсли;
						КонецЦикла;
					КонецЕсли;
				КонецЕсли;
			КонецЦикла;
			// все
		КонецЕсли;
	КонецЦикла;
КонецПроцедуры

// Возвращает ссылку на валюту в которой происзодит расчет заработной платы (рубль РФ).
// Номинирование тарифов, надбавок, выплата зарплаты допускается в любой валюте, 
// но расчеты выполняются в валюте учета зарплаты.
Функция ВалютаУчетаЗаработнойПлаты() Экспорт
	

	
КонецФункции

Функция ЭтоРегистрСведенийСЗаписьюПоУмолчанию(ИмяРегистра) Экспорт
	
	Возврат (Найти("ГражданствоФизическихЛиц,СтатусФизическихЛицКакНалогоплательщиковНДФЛ,СтатусыЗастрахованныхФизическихЛиц", ИмяРегистра) > 0);
	
КонецФункции

Функция ЗаписьРегистраСведенийПоУмолчанию(ИмяРегистра, СтруктураОтборов) Экспорт
	
	ЗаписьПоУмолчанию = РегистрыСведений[ИмяРегистра].ЗаписьПоУмолчанию();
		
	Для каждого ЭлементОтбора Из СтруктураОтборов Цикл
		ЗаписьПоУмолчанию.Вставить(ЭлементОтбора.Ключ, ЭлементОтбора.Значение);
	КонецЦикла;
		
	Возврат ЗаписьПоУмолчанию;
	
КонецФункции

// Процедура вызывается при заполнении формы "Согласие на обработку персональных данных"
//  данными, переданных в качестве параметров, субъектов.
//
// Параметры:
//		СубъектыПерсональныхДанных 	- данные формы коллекция, содержащая сведения о субъектах.
//		ДатаАктуальности			- дата, на которую нужно заполнить сведения.
//
Процедура ДополнитьДанныеСубъектовПерсональныхДанных(СубъектыПерсональныхДанных, ДатаАктуальности) Экспорт 
	
	СписокФизическихЛиц = ОбщегоНазначения.ВыгрузитьКолонку(СубъектыПерсональныхДанных, "Субъект", Истина);	
	КадровыеДанные = "ФИОПолные, ДокументСерия, ДокументНомер, АдресПоПропискеПредставление";
	
	КадровыеДанныеФизическихЛиц = КадровыйУчет.КадровыеДанныеФизическихЛиц(Истина, СписокФизическихЛиц, КадровыеДанные, ДатаАктуальности);
	
	Для Каждого ТекСтрока Из СубъектыПерсональныхДанных Цикл 
		КадровыеДанныеФизическогоЛица = КадровыеДанныеФизическихЛиц.Найти(ТекСтрока.Субъект, "ФизическоеЛицо");
		Если КадровыеДанныеФизическогоЛица <> Неопределено Тогда
			ТекСтрока.ФИО = КадровыеДанныеФизическогоЛица.ФИОПолные;
			ТекСтрока.Адрес = КадровыеДанныеФизическогоЛица.АдресПоПропискеПредставление;
			ТекСтрока.ПаспортныеДанные = КадровыеДанныеФизическогоЛица.ДокументСерия + " " + КадровыеДанныеФизическогоЛица.ДокументНомер;
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

/////////////////////////////////////
// Работа с деревом XML

Функция ПолучитьФорматЗаписиИзДереваФормата(Знач ДеревоФормата, Знач ИмяЗаписи)
	
	ТаблицаФормаЗаписи = Новый ТаблицаЗначений;
	ТаблицаФормаЗаписи.Колонки.Добавить("ИмяПоля",					Новый ОписаниеТипов("Строка", , Новый КвалификаторыСтроки(100)));
	ТаблицаФормаЗаписи.Колонки.Добавить("ТипДанных",				Новый ОписаниеТипов("Строка", , Новый КвалификаторыСтроки(10)));
	ТаблицаФормаЗаписи.Колонки.Добавить("ТипЭлемента",				Новый ОписаниеТипов("Строка", , Новый КвалификаторыСтроки(10)));
	ТаблицаФормаЗаписи.Колонки.Добавить("Размер",					Новый ОписаниеТипов("Число", Новый КвалификаторыЧисла(5)));
	ТаблицаФормаЗаписи.Колонки.Добавить("РазрядностьДробнойЧасти",	Новый ОписаниеТипов("Число", Новый КвалификаторыЧисла(5)));
	ТаблицаФормаЗаписи.Колонки.Добавить("ЭлементНеОбязателен", Новый ОписаниеТипов("Булево"));
	ТаблицаФормаЗаписи.Колонки.Добавить("НеВыводитьВФайл", Новый ОписаниеТипов("Булево"));

	
	УзлыФормата = ДеревоФормата.ДочерниеУзлы[0].ПолучитьЭлементыПоИмени(ИмяЗаписи)[0].ДочерниеУзлы;
	
	Для Каждого УзелФормата Из УзлыФормата Цикл
		
		// имя поля хранится в 4-ой колонке
		ИмяПоля = УзелФормата.ДочерниеУзлы[3].ТекстовоеСодержимое;
		Если ИмяПоля <> "" Тогда
			
			НовоеПоле = ТаблицаФормаЗаписи.Добавить();
			НовоеПоле.ИмяПоля = СокрЛП(ИмяПоля);
			// тип данных хранится во 2-ой колонке	
			НовоеПоле.ТипДанных = ВРег(УзелФормата.ДочерниеУзлы[1].ТекстовоеСодержимое);
			
			НовоеПоле.НеВыводитьВФайл = Ложь;
			
			Если УзелФормата.ДочерниеУзлы.Количество() = 7 И УзелФормата.ДочерниеУзлы[6].ИмяУзла = "ТипЭлемента" Тогда
				НовоеПоле.ТипЭлемента = ВРег(УзелФормата.ДочерниеУзлы[6].ТекстовоеСодержимое);
			Иначе
				НовоеПоле.ТипЭлемента = "С";
			КонецЕсли;	
			
			// размер поля хранится в 3-ей колонке	
			СтрРазмерПоля = УзелФормата.ДочерниеУзлы[2].ТекстовоеСодержимое;
			// Если указан размер поля, сохраним его
			Если (НовоеПоле.ТипДанных = "ЧИСЛО" Или НовоеПоле.ТипДанных = "СТРОКА") И СтрРазмерПоля <> "" Тогда
				ПозицияТочки = Найти(СтрРазмерПоля,".");
				Если ПозицияТочки<>0 Тогда
					НовоеПоле.Размер = Число(Лев(СтрРазмерПоля,ПозицияТочки-1));
					НовоеПоле.РазрядностьДробнойЧасти = Число(Сред(СтрРазмерПоля,ПозицияТочки+1));
				Иначе	
					НовоеПоле.Размер = Число(СтрРазмерПоля);
					НовоеПоле.РазрядностьДробнойЧасти = 0;
				КонецЕсли;	 
			КонецЕсли;	 
			// Признак обязательности элемента хранится в 5-й колонке	
			НовоеПоле.ЭлементНеОбязателен = (ВРег(УзелФормата.ДочерниеУзлы[4].ТекстовоеСодержимое) = "НЕ ОБЯЗАТЕЛЬНО" Или ВРег(УзелФормата.ДочерниеУзлы[4].ТекстовоеСодержимое) = "Н");
			
		КонецЕсли;	 
		
	КонецЦикла;
	
	Возврат ТаблицаФормаЗаписи;
КонецФункции

///////////////////////////////////////////////////////////////////////////////
// Проверка персональных данных физических лиц

Процедура ПроверитьЗаполнениеИНН(СтруктураПроверяемыхДанных, СоответствиеРеквизитовОткрываемымОбъектам, ДанныеДляПроверки, ВыводитьСообщения = Истина, Отказ = Ложь)
	Перем ОткрываемыйОбъект;
	Если СтруктураПроверяемыхДанных.Свойство("ИНН") Тогда 
		Если Не СоответствиеРеквизитовОткрываемымОбъектам.Свойство("ИНН", ОткрываемыйОбъект) Тогда
			ОткрываемыйОбъект = ДанныеДляПроверки.Сотрудник;
		КонецЕсли;	
		ТекстСообщения = "";
		Если Не ПустаяСтрока(СтруктураПроверяемыхДанных.ИНН) И НЕ РегламентированныеДанныеКлиентСервер.ИННСоответствуетТребованиям(СтруктураПроверяемыхДанных.ИНН, Ложь, ТекстСообщения) Тогда
			Если ВыводитьСообщения Тогда
				ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(Нстр("ru = 'Сотрудник %1: %2'"), ДанныеДляПроверки.СотрудникНаименование, ТекстСообщения);
				ОбщегоНазначенияКлиентСервер.СообщитьПользователю(ТекстОшибки, ОткрываемыйОбъект, "ИНН", , Отказ);
			Иначе
				Отказ = Истина;
			КонецЕсли;	
		КонецЕсли;	
	КонецЕсли;	
КонецПроцедуры	

Процедура ПроверитьДатыРождения(Дата, СтруктураПроверяемыхДанных, СоответствиеРеквизитовОткрываемымОбъектам, ДанныеДляПроверки, ВыводитьСообщения = Истина, Отказ = Ложь)
	Перем ОткрываемыйОбъект;
	
	Если СтруктураПроверяемыхДанных.Свойство("ДатаРожденияВСвидетельстве") Тогда
		Если Не СоответствиеРеквизитовОткрываемымОбъектам.Свойство("ДатаРожденияВСвидетельстве", ОткрываемыйОбъект) Тогда
			ОткрываемыйОбъект = ДанныеДляПроверки.Сотрудник;
		КонецЕсли;	
		
		Если ЗначениеЗаполнено(СтруктураПроверяемыхДанных.ДатаРожденияВСвидетельстве) И СтруктураПроверяемыхДанных.ДатаРожденияВСвидетельстве > Дата Тогда
			Если ВыводитьСообщения Тогда
				ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр("ru = 'Сотрудник %1: указанная в свидетельстве дата рождения не может быть больше даты подачи сведений!'"), ДанныеДляПроверки.СотрудникНаименование);
				ОбщегоНазначенияКлиентСервер.СообщитьПользователю(ТекстОшибки, ОткрываемыйОбъект, "ДатаРождения",,Отказ);
			Иначе
				Отказ = Истина;
			КонецЕсли;	
		КонецЕсли;	
	КонецЕсли;	
	
	Если СтруктураПроверяемыхДанных.Свойство("ДатаРождения") Тогда
		Если Не СоответствиеРеквизитовОткрываемымОбъектам.Свойство("ДатаРождения", ОткрываемыйОбъект) Тогда
			ОткрываемыйОбъект = ДанныеДляПроверки.Сотрудник;
		КонецЕсли;	
		
		Если ЗначениеЗаполнено(СтруктураПроверяемыхДанных.ДатаРождения) И СтруктураПроверяемыхДанных.ДатаРождения > Дата Тогда
			Если ВыводитьСообщения Тогда
				ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр("ru = 'Сотрудник %1: дата рождения не может быть больше даты подачи сведений!'"), ДанныеДляПроверки.СотрудникНаименование);
				ОбщегоНазначенияКлиентСервер.СообщитьПользователю(ТекстОшибки, ОткрываемыйОбъект, "ДатаРождения",,Отказ);
			Иначе
				Отказ = Истина;
			КонецЕсли;	
		КонецЕсли;	
	КонецЕсли;		
КонецПроцедуры	

Процедура ПроверитьОбязательныеПоля(Ссылка, СтруктураПроверяемыхДанных, ДанныеДляПроверки, СоответствиеПутейИИменПроверяемыхРеквизитов, СоответствиеРеквизитовФормеОбъекта, СоответствиеРеквизитовПутиВФормеОбъекта, СоответствиеРеквизитовОткрываемымОбъектам, ПредставленияПроверяемыхРеквизитов, МассивНепроверяемыхРеквизитов, ВыводитьСообщения = Истина, Отказ = Ложь)
	Перем ЗначениеДанныхСвидетельства;
	Перем ОткрываемыйОбъект;
	Для Каждого КлючЗначение Из СтруктураПроверяемыхДанных Цикл
		Если КлючЗначение.Значение = Неопределено Тогда 
			Продолжить;	
		КонецЕсли;	
		
		Если СоответствиеПутейИИменПроверяемыхРеквизитов.Свойство(КлючЗначение.Ключ) Тогда
			Если Не ЗначениеЗаполнено(КлючЗначение.Значение) Тогда
				
				ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр("ru = 'Сотрудник %1: %2'"), ДанныеДляПроверки.СотрудникНаименование, ПредставленияПроверяемыхРеквизитов[КлючЗначение.Ключ]);
				
				Если НЕ СоответствиеРеквизитовОткрываемымОбъектам.Свойство(КлючЗначение.Ключ, ОткрываемыйОбъект) Тогда
					ОткрываемыйОбъект = ДанныеДляПроверки.Сотрудник;
				КонецЕсли;	
				
				Если (СтруктураПроверяемыхДанных.Свойство(КлючЗначение.Ключ + "ВСвидетельстве", ЗначениеДанныхСвидетельства) И ЗначениеДанныхСвидетельства <> Неопределено) Или Прав(КлючЗначение.Ключ, 14) = "ВСвидетельстве" Тогда
					ОткрываемыйОбъект = Ссылка;
				Иначе
					ОткрываемыйОбъект = ДанныеДляПроверки.Сотрудник;
				КонецЕсли;	
				Если ВыводитьСообщения Тогда
					ОбщегоНазначенияКлиентСервер.СообщитьПользователю(ТекстОшибки, ОткрываемыйОбъект, СоответствиеРеквизитовФормеОбъекта[КлючЗначение.Ключ], СоответствиеРеквизитовПутиВФормеОбъекта[КлючЗначение.Ключ], Отказ);
				Иначе
					Отказ = Истина;
				КонецЕсли;	
			КонецЕсли;
			МассивНепроверяемыхРеквизитов.Добавить(СоответствиеПутейИИменПроверяемыхРеквизитов[КлючЗначение.Ключ]);
		КонецЕсли;				
	КонецЦикла;	
	
КонецПроцедуры	

Процедура ПроверитьЗаполнениеСтраховыхНомеровПФР(СтруктураПроверяемыхДанных, СоответствиеРеквизитовОткрываемымОбъектам, ДанныеДляПроверки, ВыводитьСообщения = Истина, Отказ = Ложь)
	Перем ОткрываемыйОбъект;
	
	Если СтруктураПроверяемыхДанных.Свойство("СтраховойНомерПФР") Тогда
		
		Если Не СоответствиеРеквизитовОткрываемымОбъектам.Свойство("СтраховойНомерПФР", ОткрываемыйОбъект) Тогда
			ОткрываемыйОбъект = ДанныеДляПроверки.Сотрудник;
		КонецЕсли;	
		
		ТекстСообщения = "";
		Если ЗначениеЗаполнено(СтруктураПроверяемыхДанных.СтраховойНомерПФР) И (Не РегламентированныеДанныеКлиентСервер.СтраховойНомерПФРСоответствуетТребованиям(СтруктураПроверяемыхДанных.СтраховойНомерПФР, ТекстСообщения)) Тогда
			ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр("ru = 'Сотрудник %1: %2 '"), ДанныеДляПроверки.СотрудникНаименование, ТекстСообщения);		
			Если ВыводитьСообщения Тогда
				ОбщегоНазначенияКлиентСервер.СообщитьПользователю(ТекстОшибки, ОткрываемыйОбъект, "СтраховойНомерПФР",,Отказ);
			Иначе
				Отказ = Истина;
			КонецЕсли;	
		КонецЕсли;
	КонецЕсли;	
	
	Если СтруктураПроверяемыхДанных.Свойство("СтраховойНомерПФРВСвидетельстве") Тогда
		
		Если Не СоответствиеРеквизитовОткрываемымОбъектам.Свойство("СтраховойНомерПФРВСвидетельстве", ОткрываемыйОбъект) Тогда
			ОткрываемыйОбъект = ДанныеДляПроверки.Сотрудник;
		КонецЕсли;	

		ТекстСообщения = "";
		Если ЗначениеЗаполнено(СтруктураПроверяемыхДанных.СтраховойНомерПФРВСвидетельстве) И (Не РегламентированныеДанныеКлиентСервер.СтраховойНомерПФРСоответствуетТребованиям(СтруктураПроверяемыхДанных.СтраховойНомерПФРВСвидетельстве, ТекстСообщения)) Тогда
			ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр("ru = 'Сотрудник %1: %2'"), ДанныеДляПроверки.СотрудникНаименование);		
			Если ВыводитьСообщения Тогда
				ОбщегоНазначенияКлиентСервер.СообщитьПользователю(ТекстОшибки, ОткрываемыйОбъект, "СтраховойНомерПФР",,Отказ);
			Иначе
				Отказ = Истина;
			КонецЕсли;	
		КонецЕсли;
	КонецЕсли;	
	
КонецПроцедуры	

Процедура ПроверитьМестоРождения(СтруктураПроверяемыхДанных, СоответствиеРеквизитовОткрываемымОбъектам, ДанныеДляПроверки, ВыводитьСообщения = Истина, Отказ = Ложь)
	Перем ОткрываемыйОбъект;
	
	Если СтруктураПроверяемыхДанных.Свойство("МестоРождения") Тогда
		
		Если Не СоответствиеРеквизитовОткрываемымОбъектам.Свойство("МестоРождения", ОткрываемыйОбъект) Тогда
			ОткрываемыйОбъект = ДанныеДляПроверки.Сотрудник;
		КонецЕсли;	
		
		Если ЗначениеЗаполнено(ДанныеДляПроверки.МестоРождения) Тогда 
			Если СокрЛП(СтрЗаменить(ДанныеДляПроверки.МестоРождения,",","")) = "" 
				или СокрЛП(СтрЗаменить(ДанныеДляПроверки.МестоРождения,",","")) = "0" Тогда
				ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр("ru = 'Сотрудник %1: не заполнено место рождения!'"), ДанныеДляПроверки.СотрудникНаименование);
				Если ВыводитьСообщения Тогда
					ОбщегоНазначенияКлиентСервер.СообщитьПользователю(ТекстОшибки, ОткрываемыйОбъект, "ФизическоеЛицоМестоРождения", "ЭтаФорма",Отказ);
				Иначе
					Отказ = Истина;
				КонецЕсли;	
			КонецЕсли; 
		КонецЕсли;	

	КонецЕсли;		
КонецПроцедуры	

Процедура ПроверитьДанныеУдостоверенийЛичности(Ссылка, Дата, СтруктураПроверяемыхДокументов, ДанныеДляПроверки, СоответствиеПутейИИменПроверяемыхРеквизитов, СоответствиеРеквизитовФормеОбъекта, СоответствиеРеквизитовПутиВФормеОбъекта, ПредставленияПроверяемыхРеквизитов,СоответствиеРеквизитовОткрываемымОбъектам, МассивНепроверяемыхРеквизитов, ВыводитьСообщения = Истина, Отказ = Истина)
		
КонецПроцедуры	

Процедура ПроверитьЗаполнениеАдресов(СтруктураПроверяемыхДанных, СоответствиеРеквизитовОткрываемымОбъектам, ДанныеДляПроверки, ВыводитьСообщения = Истина, Отказ = Ложь)
Перем ОткрываемыйОбъект;
	
	Если СтруктураПроверяемыхДанных.Свойство("АдресРегистрации") И ЗначениеЗаполнено(СтруктураПроверяемыхДанных.АдресРегистрации) Тогда
		АдресРегистрации = СтруктураПроверяемыхДанных.АдресРегистрации;
		
		Если НЕ СоответствиеРеквизитовОткрываемымОбъектам.Свойство("АдресРегистрации", ОткрываемыйОбъект) Тогда
			ОткрываемыйОбъект = ДанныеДляПроверки.Сотрудник;
		КонецЕсли;
	ИначеЕсли СтруктураПроверяемыхДанных.Свойство("Адрес") И ЗначениеЗаполнено(СтруктураПроверяемыхДанных.Адрес) Тогда
		АдресРегистрации = СтруктураПроверяемыхДанных.Адрес;
		Если НЕ СоответствиеРеквизитовОткрываемымОбъектам.Свойство("Адрес", ОткрываемыйОбъект) Тогда
			ОткрываемыйОбъект = ДанныеДляПроверки.Сотрудник;
		КонецЕсли;
	Иначе
		АдресРегистрации = "";
	КонецЕсли;
	
	Если ЗначениеЗаполнено(АдресРегистрации) Тогда 
		МассивОшибок = УправлениеКонтактнойИнформацией.ПроверитьАдрес(АдресРегистрации);
		Если МассивОшибок.Количество() <> 0 Тогда
			Если ВыводитьСообщения Тогда
				СообщенияПроверки = "";
				Для каждого СтруктураОшибки Из МассивОшибок Цикл
					СообщенияПроверки = СообщенияПроверки + СтруктураОшибки.Сообщение + Символы.ПС;
				КонецЦикла;
				СтроковыеФункцииКлиентСервер.УдалитьПоследнийСимволВСтроке(СообщенияПроверки, 1);
				ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр("ru = 'Сотрудник %1: - поле ""Адрес регистрации"":'"), ДанныеДляПроверки.СотрудникНаименование);
				ТекстОшибки = ТекстОшибки + Символы.ПС + СообщенияПроверки;
				ОбщегоНазначенияКлиентСервер.СообщитьПользователю(ТекстОшибки,ОткрываемыйОбъект, ,,Отказ);
			Иначе
				Отказ = Истина;
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	
	Если СтруктураПроверяемыхДанных.Свойство("АдресФактический") Тогда
		Если НЕ СоответствиеРеквизитовОткрываемымОбъектам.Свойство("АдресФактический", ОткрываемыйОбъект) Тогда
			ОткрываемыйОбъект = ДанныеДляПроверки.Сотрудник;
		КонецЕсли;
		Если ЗначениеЗаполнено(СтруктураПроверяемыхДанных.АдресФактический) Тогда 
			МассивОшибок = УправлениеКонтактнойИнформацией.ПроверитьАдрес(СтруктураПроверяемыхДанных.АдресФактический);
			Если МассивОшибок.Количество() <> 0 Тогда
				Если ВыводитьСообщения Тогда
					СообщенияПроверки = "";
					Для каждого СтруктураОшибки Из МассивОшибок Цикл
						СообщенияПроверки = СообщенияПроверки + СтруктураОшибки.Сообщение + Символы.ПС;
					КонецЦикла;
					СтроковыеФункцииКлиентСервер.УдалитьПоследнийСимволВСтроке(СообщенияПроверки, 1);
					ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр("ru = 'Сотрудник %1: - поле ""Фактический адрес"":'"), ДанныеДляПроверки.СотрудникНаименование);
					ТекстОшибки = ТекстОшибки + Символы.ПС + СообщенияПроверки;
					ОбщегоНазначенияКлиентСервер.СообщитьПользователю(ТекстОшибки, ОткрываемыйОбъект, ,,Отказ);
				Иначе
					Отказ = Истина;
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	
	Если СтруктураПроверяемыхДанных.Свойство("АдресДляИнформирования") Тогда
		Если НЕ СоответствиеРеквизитовОткрываемымОбъектам.Свойство("АдресДляИнформирования", ОткрываемыйОбъект) Тогда
			ОткрываемыйОбъект = ДанныеДляПроверки.Сотрудник;
		КонецЕсли;
		Если ЗначениеЗаполнено(СтруктураПроверяемыхДанных.АдресДляИнформирования) Тогда 
			МассивОшибок = УправлениеКонтактнойИнформацией.ПроверитьАдрес(СтруктураПроверяемыхДанных.АдресДляИнформирования);
			Если МассивОшибок.Количество() <> 0 Тогда
				Если ВыводитьСообщения Тогда
					СообщенияПроверки = "";
					Для каждого СтруктураОшибки Из МассивОшибок Цикл
						СообщенияПроверки = СообщенияПроверки + СтруктураОшибки.Сообщение + Символы.ПС;
					КонецЦикла;
					СтроковыеФункцииКлиентСервер.УдалитьПоследнийСимволВСтроке(СообщенияПроверки, 1);
					ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр("ru = 'Сотрудник %1: - поле ""Адрес для информирования"":'"), ДанныеДляПроверки.СотрудникНаименование);
					ТекстОшибки = ТекстОшибки + Символы.ПС + СообщенияПроверки;
					ОбщегоНазначенияКлиентСервер.СообщитьПользователю(ТекстОшибки, ОткрываемыйОбъект, ,,Отказ);
				Иначе
					Отказ = Истина;
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////////////////////////
// Работа с личными данными физических лиц

Процедура ИзменитьНаименованиеФизическихЛиц(ДанныеФИО)
	
	Пока ДанныеФИО.Следующий() Цикл
		
		ФизЛицоОбъект = ДанныеФИО.ФизическоеЛицо.ПолучитьОбъект();
		
		СтруктураФИО = ФизическиеЛицаКлиентСервер.ЧастиИмени(ДанныеФИО.Наименование);
		НаименованиеФизЛица = СтруктураФИО.Фамилия + " " + СтруктураФИО.Имя + " " + СтруктураФИО.Отчество;
		
		Если СокрЛП(НаименованиеФизЛица) = КадровыйУчетКлиентСервер.ПолноеНаименованиеСотрудника(ДанныеФИО.Фамилия, ДанныеФИО.Имя, ДанныеФИО.Отчество, "") Тогда
			Продолжить;
		КонецЕсли;
		
		Попытка 
			ФизЛицоОбъект.Заблокировать();
		Исключение
			Отказ = Истина;
			ТекстИсключенияЗаписи = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Не удалось изменить имя физического лица %1.
			|Возможно, данные сотрудника редактируются другим пользователем'"),
			ФизЛицоОбъект.Наименование);
			ВызватьИсключение ТекстИсключенияЗаписи;
			
		КонецПопытки;
		
		ФизЛицоОбъект.Наименование = КадровыйУчетКлиентСервер.ПолноеНаименованиеСотрудника(
				ДанныеФИО.Фамилия,
				ДанныеФИО.Имя,
				ДанныеФИО.Отчество,
				"");
		
		ФизЛицоОбъект.Записать();
		
	КонецЦикла;
	
КонецПроцедуры

Процедура ИзменитьНаименованиеСотрудников(ДанныеФИО)
	
	Пока ДанныеФИО.Следующий() Цикл
		
		СтруктураФИО = ФизическиеЛицаКлиентСервер.ЧастиИмени(ДанныеФИО.СотрудникНаименование);
		НаименованиеСотрудника = СтруктураФИО.Фамилия + " " + СтруктураФИО.Имя + " " + СтруктураФИО.Отчество;
		
		ПолноеНаименованиеСотрудника  = КадровыйУчетКлиентСервер.ПолноеНаименованиеСотрудника(
				ДанныеФИО.Фамилия,
				ДанныеФИО.Имя,
				ДанныеФИО.Отчество,
				"");
		
		Если СокрЛП(НаименованиеСотрудника) = ПолноеНаименованиеСотрудника Тогда
			Продолжить;
		КонецЕсли;
		
		СотрудникОбъект = ДанныеФИО.Сотрудник.ПолучитьОбъект();
		
		Попытка 
			СотрудникОбъект.Заблокировать();
		Исключение
			Отказ = Истина;
			ТекстИсключенияЗаписи = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Не удалось изменить имя сотрудника %1.
			|Возможно, данные сотрудника редактируются другим пользователем'"),
			СотрудникОбъект.Наименование);
			ВызватьИсключение ТекстИсключенияЗаписи;
			
		КонецПопытки;
		
		СотрудникОбъект.Наименование = ПолноеНаименованиеСотрудника;
		
		СотрудникОбъект.Записать();
	КонецЦикла;
	
КонецПроцедуры

///////////////////////////////////////////////////////////////////////////////
// Регламентированная отчетность

////////////////////////////////////////////////////////////////////////////////
// Прочие процедуры и функции

// Формирует временную таблицу с значениями ресурсов заданного регистра сведений.
// Параметры:
//		МенеджерВременныхТаблиц.
//
//		ТолькоРазрешенные - если истина, выбираются только разрешенные записи.
//
//		ИмяРегистра - имя регистра сведений (не полное).
//
//		ИзмеренияДаты - таблица значений.
//			Должна обязательно содержать колонку "Период"
//			Может содержать колонки с именами, совпадающими с именами 
//			измерений регистра сведений.
//
//			Используется как фильтр - переданные в ней значения измерений "фильтруют" регистр.
//			В зависимости от значения параметра ВсеЗаписи строки ИзмеренияДаты используются 
//			не только как фильтр, но и как набор значений для дополнения результирующей 
//			временной таблицы.
//			Содержит даты получения последних значений ресурсов.
//			В предельном случае, когда нет колонок таблицы, соответствующих измерениям, 
//			(т.е. фильтрация по измерениям не выполняется), в таблице содержится одна строка 
//			с датой на которую нужно получить значения ресурсов.
//
//		Отбор - коллекция условий отбора, соединяемых по "И" и применяемых к регистру сведений.
//			Коллекция строки которой имеют поля
//				ЛевоеЗначение - строка, имя поля регистра сведений
//				ВидСравнения - строка, вид сравнения, допустимый в языке запросов
//				ПравоеЗначение - значение для сравнения с полем ЛевоеЗначение.
//
//		ВсеЗаписи - булево значение. 
//			Если Истина, то в результирующей временной таблице
//			должно быть столько же записей, сколько передано в параметре ИзмеренияДаты.
//			Если Ложь, то временная таблица содержит записи только для тех 
//			значений измерений, для которых существуют данные в регистре.
//			По умолчанию - Ложь.
//	
//		ВключаяГраницу - булево значение.	
//			Если Истина, то записи на дату формирования среза учитываются
//			Если Ложь, то записи на дату формирования среза не учитываются
//			По умолчанию - Истина.  
//
//		СрезПоследних - булево значение. 
//			Если Истина, во временную таблицу выберется срез последних, иначе срез первых 
//			По умолчанию - Истина.  
//			
//		ИмяРезультирующейТаблицы - имя временной таблицы в которую должен быть помещен результат.
//			Если имя не задано, то создается временная таблица с именем 
//			ВТ<ИмяРегистра>СрезПоследних или ВТ<ИмяРегистра>СрезПервых, например: ВТПлановыеНачисленияСрезПоследних.
//
// Создает в МенеджерВременныхТаблиц временную таблицу.
// Поля временной таблицы
//	- Период
//	- Все измерения (не только переданные в качестве фильтра, а все)
//	- Все ресурсы 
//	- Все реквизиты
//	- Все стандартные реквизиты.
//
Процедура СоздатьПоТаблицеЗначенийВТИмяРегистраСрез(МенеджерВременныхТаблиц, ТолькоРазрешенные, ИмяРегистра, ИзмеренияДаты, Отбор, ВсеЗаписи, ВключаяГраницу, СрезПоследних, ИмяРезультирующейТаблицы)
	
	МассивИзмерений = Новый Массив;
	Для Каждого Колонка Из ИзмеренияДаты.Колонки Цикл
		МассивИзмерений.Добавить(Колонка.Имя);		
	КонецЦикла;	
	
	КоллекцииПолей = КоллекцииПолейДляПодготовкиТекстаЗапроса(ИмяРегистра, МассивИзмерений);
	
	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("ИзмеренияДаты", ИзмеренияДаты);
	Запрос.МенеджерВременныхТаблиц = МенеджерВременныхТаблиц;
	
	ИмяВТИзмеренияДаты = УникальноеИмяВременнойТаблицы("ВТИзмеренияДаты");
	
	ТекстЗапроса = 
	"ВЫБРАТЬ
	|	ИзмеренияДаты.Период";
	Для Каждого Измерение Из КоллекцииПолей.ИзмеренияФильтра Цикл
		ТекстЗапроса = ТекстЗапроса + ",
		|	ИзмеренияДаты." + Измерение;
	КонецЦикла;
	ТекстЗапроса = ТекстЗапроса + "
	|ПОМЕСТИТЬ " + ИмяВТИзмеренияДаты + "
	|ИЗ
	|	&ИзмеренияДаты КАК ИзмеренияДаты";
	
	Запрос.Текст = ТекстЗапроса;
	Запрос.Выполнить();
	
	ЗапросВТИмяРегистраСрез = ЗапросВТИмяРегистраСрез(ТолькоРазрешенные, КоллекцииПолей, ИмяРегистра, ИмяВТИзмеренияДаты, ИмяРезультирующейТаблицы, Отбор, ВсеЗаписи, ВключаяГраницу, СрезПоследних);
	ЗапросВТИмяРегистраСрез.МенеджерВременныхТаблиц = Запрос.МенеджерВременныхТаблиц;
	
	ДобавитьТекстУдаленияВременнойТаблицы(ЗапросВТИмяРегистраСрез.Текст, ИмяВТИзмеренияДаты);
	
	ЗапросВТИмяРегистраСрез.Выполнить();
	
КонецПроцедуры

// Формирует временную таблицу с значениями ресурсов заданного регистра сведений.
// Параметры:
//		ПараметрыСреза - Структура, структура полученная функцией ПараметрыДляСоздатьПоВременнойТаблицеВТИмяРегистра.
//						МенеджерВременныхТаблиц,
//						Содержит следующие поля:
//							ИмяВТИзмеренияДаты - имя временной таблицы с параметрами среза.
//												 Должна обязательно поле "Период"
//												 Используется как фильтр - переданные в ней значения измерений "фильтруют" регистр.
//												 В зависимости от значения параметра ВсеЗаписи строки ИзмеренияДаты используются 
//												 не только как фильтр, но и как набор значений для дополнения результирующей 
//												 временной таблицы.
//												 Содержит даты получения последних значений ресурсов.
//												 В предельном случае, когда нет колонок таблицы, соответствующих измерениям, 
//												 (т.е. фильтрация по измерениям не выполняется), в таблице содержится одна строка 
//												 с датой на которую нужно получить значения ресурсов.
//							Измерения - массив с именами измерений, по которым будет получен "Срез последних"
//										Может содержать колонки с именами, совпадающими с именами 
//										измерений регистра сведений.
//						
//
//		ТолькоРазрешенные - если истина, выбираются только разрешенные записи.
//
//		ИмяРегистра - имя регистра сведений (не полное).
//			
//		Отбор - коллекция условий отбора, соединяемых по "И" и применяемых к регистру сведений.
//			Коллекция строки которой имеют поля
//				ЛевоеЗначение - строка, имя поля регистра сведений.
//				ВидСравнения - строка, вид сравнения, допустимый в языке запросов.
//				ПравоеЗначение - значение для сравнения с полем ЛевоеЗначение.
//
//		ВсеЗаписи - булево значение. 
//			Если Истина, то в результирующей временной таблице
//			должно быть столько же записей, сколько передано в параметре ИзмеренияДаты.
//			Если Ложь, то временная таблица содержит записи только для тех 
//			значений измерений, для которых существуют данные в регистре.
//			По умолчанию - Ложь.
//	
//		ВключаяГраницу - булево значение.	
//			Если Истина, то записи на дату формирования среза учитываются
//			Если Ложь, то записи на дату формирования среза не учитываются
//			По умолчанию - Истина.  
//
//		СрезПоследних - булево значение. 
//			Если Истина, во временную таблицу выберется срез последних, иначе срез первых. 
//			По умолчанию - Истина.  
//			
//		ИмяРезультирующейТаблицы - имя временной таблицы в которую должен быть помещен результат.
//			Если имя не задано, то создается временная таблица с именем 
//			ВТ<ИмяРегистра>СрезПоследних или ВТ<ИмяРегистра>СрезПервых, например: ВТПлановыеНачисленияСрезПоследних.
//
// Создает в МенеджерВременныхТаблиц временную таблицу
// Поля временной таблицы
//	- Период
//	- Все измерения (не только переданные в качестве фильтра, а все)
//	Если ПолучениеСрезаПоследних = Истина, то
//	- Все ресурсы без постфикса ПоОкончании
//	Если ПолучениеСрезаПоследних = Ложь, то
//	- Все ресурсы
//	- Все реквизиты
//	- Все стандартные реквизиты.
//
Процедура СоздатьПоВременнойТаблицеВТИмяРегистраСрез(ПараметрыСреза, ТолькоРазрешенные,  ИмяРегистра, Отбор, ВсеЗаписи, ВключаяГраницу, СрезПоследних, ИмяРезультирующейТаблицы)
	
	КоллекцииПолей = КоллекцииПолейДляПодготовкиТекстаЗапроса(ИмяРегистра, ПараметрыСреза.Измерения);
	
	ЗапросВТИмяРегистраСрез = ЗапросВТИмяРегистраСрез(ТолькоРазрешенные, КоллекцииПолей, ИмяРегистра, ПараметрыСреза.ИмяВТИзмеренияДаты, ИмяРезультирующейТаблицы, Отбор, ВсеЗаписи, ВключаяГраницу, СрезПоследних);
	ЗапросВТИмяРегистраСрез.МенеджерВременныхТаблиц = ПараметрыСреза.МенеджерВременныхТаблиц;
	
	ЗапросВТИмяРегистраСрез.Выполнить();
	
КонецПроцедуры

Процедура ПрочитатьПериодическиеСведенияОрганизации(Форма)
	

КонецПроцедуры

Процедура ЗаписатьПериодическиеСведенияОрганизации(Форма)
	

КонецПроцедуры

// Процедура вызывается при заполнении формы "Согласие на обработку персональных данных"
//  данными организации.
//
// Параметры:
//		Организация					- организация - оператор персональных данных.
//		ДанныеОрганизации			- структура с данными об организации (адрес, ФИО ответственного и т.д.).
//		ДатаАктуальности			- дата, на которую нужно заполнить сведения.
//
Процедура ДополнитьДанныеОрганизацииОператораПерсональныхДанных(Организация, ДанныеОрганизации, ДатаАктуальности) Экспорт 

	АдресаОрганизаций = ЗарплатаКадры.АдресаОрганизаций(Организация);
	ДанныеОрганизации.АдресОрганизации = ЗарплатаКадры.АдресОрганизации(АдресаОрганизаций, Организация, Справочники.ВидыКонтактнойИнформации.ЮрАдресОрганизации).Представление;
	
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// Универсальные процедуры и функции

Процедура УстановитьОтборВЗапросеПоПараметрам(Запрос, Параметры)
	
	ТекстУсловийОтбора = "";
	
	Если Параметры.Отбор.Количество() > 0 Тогда
		
		Для каждого ЭлементОтбора Из Параметры.Отбор Цикл
			
			Если ТипЗнч(ЭлементОтбора.Значение) = Тип("ФиксированныйМассив") Тогда
				
				УсловиеСПравымЗначением = " В (&Отбор" + ЭлементОтбора.Ключ + ")";
				
			Иначе
				
				УсловиеСПравымЗначением = " = (&Отбор" + ЭлементОтбора.Ключ + ")";
				
			КонецЕсли; 
			
			ТекстУсловийОтбора = ?(ПустаяСтрока(ТекстУсловийОтбора), "", ТекстУсловийОтбора + Символы.ПС + " И ")
				+ "СписокСправочника." + ЭлементОтбора.Ключ + УсловиеСПравымЗначением;
				
			Запрос.УстановитьПараметр("Отбор" + ЭлементОтбора.Ключ, ЭлементОтбора.Значение);
			
		КонецЦикла;
		
	КонецЕсли;
	
	Если НЕ ПустаяСтрока(Параметры.СтрокаПоиска) Тогда
		
		ТекстУсловийОтбораПоКоду = "СписокСправочника.Код ПОДОБНО &СтрокаПоиска";
		ТекстУсловийОтбораПоНаименованию = "СписокСправочника.Наименование ПОДОБНО &СтрокаПоиска";
		
		Запрос.УстановитьПараметр("СтрокаПоиска", Параметры.СтрокаПоиска + "%");
		
	Иначе
		
		ТекстУсловийОтбораПоКоду = "";
		ТекстУсловийОтбораПоНаименованию = "";
		
	КонецЕсли;
	
	Если НЕ ПустаяСтрока(ТекстУсловийОтбора) Тогда
		
		ТекстУсловийОтбораПоКоду = ?(ПустаяСтрока(ТекстУсловийОтбораПоКоду), "", ТекстУсловийОтбораПоКоду + Символы.ПС + " И ") + ТекстУсловийОтбора;
		ТекстУсловийОтбораПоНаименованию = ?(ПустаяСтрока(ТекстУсловийОтбораПоНаименованию), "", ТекстУсловийОтбораПоНаименованию + Символы.ПС + " И ") + ТекстУсловийОтбора;
		
	КонецЕсли; 
	
	Если НЕ ПустаяСтрока(ТекстУсловийОтбораПоКоду) Тогда
		
		ТекстУсловийОтбораПоКоду = "ГДЕ
			|	" + ТекстУсловийОтбораПоКоду;
			
		ТекстУсловийОтбораПоНаименованию = "ГДЕ
			|	" + ТекстУсловийОтбораПоНаименованию;
			
	КонецЕсли; 
	
	Запрос.Текст = СтрЗаменить(Запрос.Текст, "ГДЕ &ТекстУсловийОтбораПоКодам", ТекстУсловийОтбораПоКоду);
	Запрос.Текст = СтрЗаменить(Запрос.Текст, "ГДЕ &ТекстУсловийОтбораПоНаименованиям", ТекстУсловийОтбораПоНаименованию);
	
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// Замена ссылок по информационной базе

Функция ИменаПолейСТипом(ИмяТаблицы, ТипДанных, КешПолейТаблиц=Неопределено, СтрокаИсключений="")
	ИменаПолей = Новый Массив;
	
	ТекстЗапроса = СтрЗаменить("ВЫБРАТЬ * ИЗ ТаблицаВыборки КАК Т ГДЕ ЛОЖЬ", "ТаблицаВыборки", ИмяТаблицы);
	Если Неопределено <> КешПолейТаблиц Тогда
		ПоляТаблицы = КешПолейТаблиц.Получить(ИмяТаблицы);
		Если Неопределено = ПоляТаблицы Тогда
			Запрос = Новый Запрос(ТекстЗапроса);
			ПоляТаблицы = Запрос.Выполнить().Колонки;
			КешПолейТаблиц.Вставить(ИмяТаблицы, ПоляТаблицы);
		КонецЕсли;
	Иначе
		Запрос = Новый Запрос(ТекстЗапроса);
		ПоляТаблицы = Запрос.Выполнить().Колонки;
	КонецЕсли;
	
	Исключения = Новый Структура(СтрокаИсключений);
	Для Каждого Поле Из ПоляТаблицы Цикл
		Если Поле.ТипЗначения.СодержитТип(ТипДанных) И Не Исключения.Свойство(Поле.Имя) Тогда
			ИменаПолей.Добавить(Поле.Имя);
		КонецЕсли;
	КонецЦикла;
	
    Возврат ИменаПолей;
КонецФункции

Процедура ЗаменитьЗначение(Данные, ИменаПолей, Замещаемое, Заменитель, ЗначениеЗаменено=Ложь)
	Для Каждого ИмяПоля Из ИменаПолей Цикл
		Если Данные[ИмяПоля] = Замещаемое Тогда
			Данные[ИмяПоля] = Заменитель;
			ЗначениеЗаменено = Истина;
		КонецЕсли;
	КонецЦикла;
КонецПроцедуры

Процедура ЗаписатьДанные(Данные, Принудительно=Ложь)
	Если Данные.Модифицированность() Или Принудительно Тогда
		Данные.ОбменДанными.Загрузка = Истина;
		Данные.Записать();
	КонецЕсли;
КонецПроцедуры

Функция ОтборыРегистраСведений(МетаданныеРегистра, Запись)
	Отборы = Новый Структура;
	Если МетаданныеРегистра.ПериодичностьРегистраСведений <> Метаданные.СвойстваОбъектов.ПериодичностьРегистраСведений.Непериодический Тогда
		Отборы.Вставить("Период", Запись.Период);
	КонецЕсли;
	Для Каждого Измерение Из МетаданныеРегистра.Измерения Цикл
		Отборы.Вставить(Измерение.Имя, Запись[Измерение.Имя]);
	КонецЦикла;
	Возврат Отборы;
КонецФункции

Функция НаборЗаписей(МенеджерРегистра, Отборы)
	Набор = МенеджерРегистра.СоздатьНаборЗаписей();
	Для Каждого Отбор Из Отборы Цикл
		Набор.Отбор[Отбор.Ключ].Установить(Отбор.Значение);
	КонецЦикла;
	Набор.Прочитать();
	Возврат Набор;
КонецФункции

Функция ЭтоСсылочныйОбъектМетаданных(ОбъектМетаданных)
	Возврат Метаданные.Справочники.Содержит(ОбъектМетаданных)
		ИЛИ Метаданные.Документы.Содержит(ОбъектМетаданных)
		ИЛИ Метаданные.Перечисления.Содержит(ОбъектМетаданных)
		ИЛИ Метаданные.ПланыВидовХарактеристик.Содержит(ОбъектМетаданных)
		ИЛИ Метаданные.ПланыСчетов.Содержит(ОбъектМетаданных)
		ИЛИ Метаданные.ПланыВидовРасчета.Содержит(ОбъектМетаданных)
		ИЛИ Метаданные.БизнесПроцессы.Содержит(ОбъектМетаданных)
		ИЛИ Метаданные.Задачи.Содержит(ОбъектМетаданных)
		ИЛИ Метаданные.ПланыОбмена.Содержит(ОбъектМетаданных);
КонецФункции

Функция СтруктураПустогоАдресаОрганизации()
	
	Возврат Новый Структура("Представление,Город,ЗначенияПолей", "", "", "");
	
КонецФункции

#КонецОбласти
