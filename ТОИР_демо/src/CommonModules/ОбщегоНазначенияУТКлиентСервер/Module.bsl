
#Область ПрограммныйИнтерфейс

#Область ПроцедурыИФункцииОбщегоНазначения

// Рассчитывает дату окончания периода
//
// Параметры:
// 	ДатаНачала         - Дата - дата начала, от которой будет рассчитана дата окончания периода.
// 	Периодичность      - ПеречислениеСсылка.Периодичность - Периодичность.
// 	КоличествоПериодов - Число - количество повторов периода.
//
// Возвращаемое значение:
// 	Дата - Дата окончания периода.
//
Функция РассчитатьДатуОкончанияПериода(ДатаНачала, Периодичность, КоличествоПериодов) Экспорт

	ОдинДень = 86400;

	Если Периодичность = ПредопределенноеЗначение("Перечисление.Периодичность.День") Тогда 
		
		ДатаОкончания = ДатаНачала + ОдинДень * КоличествоПериодов;

	ИначеЕсли Периодичность = ПредопределенноеЗначение("Перечисление.Периодичность.Неделя") Тогда
		
		ДатаОкончания = ДатаНачала + ОдинДень * 7 * КоличествоПериодов;

	ИначеЕсли (Периодичность = ПредопределенноеЗначение("Перечисление.Периодичность.Декада")) Тогда
		
		ДеньМесяца = День(ДатаНачала);
		НачМесяца = НачалоМесяца(ДатаНачала);
		Если ДеньМесяца <= 10 Тогда
			НомерДекады = 1;
		ИначеЕсли ДеньМесяца <= 20 Тогда
			НомерДекады = 2;
		Иначе
			НомерДекады = 3;
		КонецЕсли;
			
		НомерДекады = НомерДекады + КоличествоПериодов;
		
		Если НомерДекады > 0 Тогда
			Месяцев = Цел((НомерДекады-1)/3);
		Иначе
			Месяцев = -1 - Цел((-НомерДекады)/3);
		КонецЕсли;
			
		НомерДекады = НомерДекады - 3*Месяцев;
		Дт = ДобавитьМесяц(НачМесяца, Месяцев) + (НомерДекады-1) * 10 * ОдинДень;

		Если КоличествоПериодов > 0 Тогда
			ДатаОкончания = Дт;
		
		Иначе 
			ДеньМесяца = День(Дт);

			Если ДеньМесяца <= 10 Тогда
				ДатаОкончания = КонецДня(НачалоМесяца(Дт) + ОдинДень * 9);
			ИначеЕсли ДеньМесяца <= 20 Тогда
				ДатаОкончания = КонецДня(НачалоМесяца(Дт) + ОдинДень * 19);
			Иначе
				ДатаОкончания = КонецМесяца(Дт);
			КонецЕсли;
		КонецЕсли;

	ИначеЕсли (Периодичность= ПредопределенноеЗначение("Перечисление.Периодичность.Месяц")) Тогда
		
		ДатаОкончания = ДобавитьМесяц(ДатаНачала, КоличествоПериодов);

	ИначеЕсли (Периодичность = ПредопределенноеЗначение("Перечисление.Периодичность.Квартал")) Тогда
		
		ДатаОкончания = ДобавитьМесяц(ДатаНачала, 3 * КоличествоПериодов);

	ИначеЕсли (Периодичность = ПредопределенноеЗначение("Перечисление.Периодичность.Полугодие")) Тогда
		
		ДатаОкончания = ДобавитьМесяц(ДатаНачала, 6 * КоличествоПериодов);

	ИначеЕсли (Периодичность = ПредопределенноеЗначение("Перечисление.Периодичность.Год")) Тогда
		
		ДатаОкончания = ДобавитьМесяц(ДатаНачала, 12 * КоличествоПериодов);

	КонецЕсли;
			
	Возврат КонецДня(ДатаОкончания-ОдинДень);

КонецФункции // РассчитатьДатуОкончанияПериода()

// Рассчитывает ближайшую к указанной дату начала периода
//
// Параметры:
// 	ДатаНачала          - Дата - дата, к которой будет рассчитана ближайшая дата начала периода
// 	Периодичность       - ПеречислениеСсылка.Периодичность - Периодичность.
//
// Возвращаемое значение:
// 	Дата - Дата начала ближайшего периода.
//
Функция РассчитатьДатуНачалаБлижайшегоПериода(ДатаНачала, Периодичность) Экспорт
	
	ОдинДень = 86400;
	
	Если Периодичность = ПредопределенноеЗначение("Перечисление.Периодичность.День") Тогда
		
		БлижайшаяДата = ДатаНачала;
		
	ИначеЕсли Периодичность = ПредопределенноеЗначение("Перечисление.Периодичность.Неделя") Тогда
		
		Если ДатаНачала = НачалоНедели(ДатаНачала) Тогда
			БлижайшаяДата = ДатаНачала;
		Иначе
			БлижайшаяДата = КонецНедели(ДатаНачала) + ОдинДень;
		КонецЕсли;
		
	ИначеЕсли (Периодичность = ПредопределенноеЗначение("Перечисление.Периодичность.Декада")) Тогда
		
		ДеньМесяца   = День(ДатаНачала);
		НачалоМесяца = НачалоМесяца(ДатаНачала);
		
		Если ДеньМесяца = 1 Или ДеньМесяца = 11 Или ДеньМесяца = 21 Тогда
			БлижайшаяДата = ДатаНачала;
		ИначеЕсли ДеньМесяца <= 10 Тогда // Первая декада
			БлижайшаяДата = НачалоМесяца + ОдинДень * 10;
		ИначеЕсли ДеньМесяца <= 20 Тогда // Вторая декада
			БлижайшаяДата = НачалоМесяца + ОдинДень * 20;
		Иначе // Третья декада
			БлижайшаяДата = КонецМесяца(НачалоМесяца) + ОдинДень;
		КонецЕсли;
		
	ИначеЕсли (Периодичность= ПредопределенноеЗначение("Перечисление.Периодичность.Месяц")) Тогда
		
		Если ДатаНачала = НачалоМесяца(ДатаНачала) Тогда
			БлижайшаяДата = ДатаНачала;
		Иначе
			БлижайшаяДата = КонецМесяца(ДатаНачала) + ОдинДень;
		КонецЕсли;

	ИначеЕсли (Периодичность = ПредопределенноеЗначение("Перечисление.Периодичность.Квартал")) Тогда
		
		Если ДатаНачала = НачалоКвартала(ДатаНачала) Тогда
			БлижайшаяДата = ДатаНачала;
		Иначе
			БлижайшаяДата = КонецКвартала(ДатаНачала) + ОдинДень;
		КонецЕсли;

	ИначеЕсли (Периодичность = ПредопределенноеЗначение("Перечисление.Периодичность.Полугодие")) Тогда
		
		НачалоГода      = НачалоГода(ДатаНачала);
		НачалоПолугодия = ДобавитьМесяц(НачалоГода,6);
		
		Если ДатаНачала = НачалоПолугодия Или ДатаНачала = НачалоГода Тогда
			БлижайшаяДата = ДатаНачала;
		Иначе
			БлижайшаяДата = ?(ДатаНачала > НачалоПолугодия, КонецГода(ДатаНачала) + ОдинДень, НачалоПолугодия);
		КонецЕсли;

	ИначеЕсли (Периодичность = ПредопределенноеЗначение("Перечисление.Периодичность.Год")) Тогда
		
		Если ДатаНачала = НачалоГода(ДатаНачала) Тогда
			БлижайшаяДата = ДатаНачала;
		Иначе
			БлижайшаяДата = КонецГода(ДатаНачала) + ОдинДень;
		КонецЕсли;

	КонецЕсли;
	
	Возврат БлижайшаяДата;
	
КонецФункции // РассчитатьДатуНачалаБлижайшегоПериода()

// Сравнивает значения переданных стуктур по указанным свойствам
// Параметры:
//		Стуктура1 - Структура - первая структура для сравнения.
//		Стуктура2 - Структура - вторая структура для сравнения.
//		Свойства - Массив - имена свойств, по которым нужно проводить сравнение, 
//				Тип - массив строк с именами свойств, или строка (именя перечисляются через запятую).
// Возвращаемое значение:
//		Булево - ИСТИНА, если структуры равны по значениниям переданных свойств,
//					ЛОЖЬ - в противном случае.
Функция СтруктурыРавны(Стуктура1, Стуктура2, Свойства) Экспорт
	Если ТипЗнч(Свойства) = Тип("Строка") Тогда
		МассивСвойств = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(Свойства);
	Иначе
		МассивСвойств = Свойства
	КонецЕсли;
	
	Для Каждого СтрМас из МассивСвойств Цикл
		Если Стуктура1[СтрМас]<> Стуктура2[СтрМас] Тогда
			Возврат Ложь;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Истина;
КонецФункции

// Возвращает структуру, содержащую ключи, имеющиеся в обеих исходных структурах.
//
// Параметры:
//		Структура1 - Структура - первая структура для сравнения.
//		Структура2 - Структура - вторая структура для сравнения.
// Возвращаемое значение:
// 	Структура - структура с общими ключами.
Функция ПолучитьОбщиеКлючиСтруктур(Структура1, Структура2) Экспорт
	
	Результат = Новый Структура;
	
	Для Каждого КлючИЗначение Из Структура1 Цикл
		Если Структура2.Свойство(КлючИЗначение.Ключ) Тогда
			Результат.Вставить(КлючИЗначение.Ключ);
		КонецЕсли;
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

// Дополняет структуру приемник полями структуры источника
//
// Параметры:
// 		СтруктураПриемник - Структура - Структура, в которую необходимо скопировать поля
// 		СтруктураИсточник - Структура - Структура, из которой необходимо скопировать поля
// 		КопироватьЗначения - Булево - Истина, если надо копировать значения.
//
Процедура ДополнитьСтруктуру(СтруктураПриемник, СтруктураИсточник, КопироватьЗначения=Ложь) Экспорт
	
	Для Каждого Элемент Из СтруктураИсточник Цикл
		СтруктураПриемник.Вставить(Элемент.Ключ, ?(КопироватьЗначения, Элемент.Значение, Неопределено));
	КонецЦикла;
	
КонецПроцедуры // ДополнитьСтруктуру()

// Возвращает период, увеличенный на количество периодов.
// Параметры:
// 	БазоваяДата - Дата - дата, относительно которой рассчитывается период
// 	Периодичность - ПеречислениеСсылка.Периодичность - Периодичность,
// 	КоличествоПериодов - Число - количество периодов, на которое нужно расширить базовый.
//                     если = 0, то возвращается период, в котором находится базовая дата,
//                     если < 0, то возвращаются период, соответсвующий предыдущим периодам,
//                     если > 0, то возвращаются период, соответсвующий следующим периодам.
//
// Возвращаемое значение:
// 	СтандартныйПериод - период, увеличенный на количество периодов.
Функция РасширенныйПериод(БазоваяДата, Периодичность, КоличествоПериодов = 0) Экспорт

	ОдинДень = 86400;
	Период = Новый СтандартныйПериод;
	Период.Вариант = ВариантСтандартногоПериода.ПроизвольныйПериод;

	Если Периодичность = ПредопределенноеЗначение("Перечисление.Периодичность.День") Тогда

		Период.ДатаНачала    = НачалоДня(БазоваяДата);
		Период.ДатаОкончания = КонецДня(БазоваяДата);

		Если КоличествоПериодов < 0 Тогда
			Период.ДатаОкончания = Период.ДатаНачала - 1;
			Период.ДатаНачала    = Период.ДатаНачала + ОдинДень * КоличествоПериодов;
		ИначеЕсли КоличествоПериодов > 0 Тогда
			Период.ДатаНачала    = Период.ДатаОкончания + 1;
			Период.ДатаОкончания = Период.ДатаОкончания + ОдинДень * КоличествоПериодов;
		КонецЕсли;

	ИначеЕсли Периодичность = ПредопределенноеЗначение("Перечисление.Периодичность.Неделя") Тогда

		Период.ДатаНачала    = НачалоНедели(БазоваяДата);
		Период.ДатаОкончания = КонецНедели(БазоваяДата);

		Если КоличествоПериодов < 0 Тогда
			Период.ДатаОкончания = Период.ДатаНачала - 1;
			Период.ДатаНачала    = Период.ДатаНачала + ОдинДень * 7 * КоличествоПериодов;
		ИначеЕсли КоличествоПериодов > 0 Тогда
			Период.ДатаНачала    = Период.ДатаОкончания + 1;
			Период.ДатаОкончания = Период.ДатаОкончания + ОдинДень * 7 * КоличествоПериодов;
		КонецЕсли;

	ИначеЕсли (Периодичность = ПредопределенноеЗначение("Перечисление.Периодичность.Декада")) Тогда

		ДеньМесяца = День(БазоваяДата);
		Если ДеньМесяца <= 10 Тогда
			НомерДекады = 1;
		ИначеЕсли ДеньМесяца <= 20 Тогда
			НомерДекады = 2;
		Иначе
			НомерДекады = 3;
		КонецЕсли;

		НомерДекады = НомерДекады + КоличествоПериодов;

		Если НомерДекады > 0 Тогда
			СмещениеМесяцев = Цел((НомерДекады-1)/3);
		Иначе
			СмещениеМесяцев = -1 - Цел((-НомерДекады)/3);
		КонецЕсли;

		НомерДекады = НомерДекады - 3*СмещениеМесяцев;
		СмещеннаяДата = ДобавитьМесяц(НачалоМесяца(БазоваяДата), СмещениеМесяцев) + (НомерДекады-1) * 10 * ОдинДень;
		ДеньМесяца = День(СмещеннаяДата);

		Если ДеньМесяца <= 10 Тогда
			Период.ДатаНачала    = НачалоМесяца(СмещеннаяДата);
			Период.ДатаОкончания = Период.ДатаНачала + ОдинДень * 9;
		ИначеЕсли ДеньМесяца <= 20 Тогда
			Период.ДатаНачала    = НачалоМесяца(СмещеннаяДата) + ОдинДень * 9;
			Период.ДатаОкончания = НачалоМесяца(СмещеннаяДата) + ОдинДень * 19;
		Иначе
			Период.ДатаНачала    = НачалоМесяца(СмещеннаяДата) + ОдинДень * 19;
			Период.ДатаОкончания = КонецМесяца(СмещеннаяДата);
		КонецЕсли;

	ИначеЕсли (Периодичность= ПредопределенноеЗначение("Перечисление.Периодичность.Месяц")) Тогда

		Период.ДатаНачала    = НачалоМесяца(БазоваяДата);
		Период.ДатаОкончания = КонецМесяца(БазоваяДата);

		Если КоличествоПериодов < 0 Тогда
			Период.ДатаОкончания = Период.ДатаНачала - 1;
			Период.ДатаНачала = ДобавитьМесяц(Период.ДатаНачала, КоличествоПериодов);
		ИначеЕсли КоличествоПериодов > 0 Тогда
			Период.ДатаНачала = Период.ДатаОкончания + 1;
			Период.ДатаОкончания = ДобавитьМесяц(Период.ДатаОкончания, КоличествоПериодов);
		КонецЕсли;

	ИначеЕсли (Периодичность = ПредопределенноеЗначение("Перечисление.Периодичность.Квартал")) Тогда

		Период.ДатаНачала    = НачалоКвартала(БазоваяДата);
		Период.ДатаОкончания = КонецКвартала(БазоваяДата);

		Если КоличествоПериодов < 0 Тогда
			Период.ДатаОкончания = Период.ДатаНачала - 1;
			Период.ДатаНачала    = ДобавитьМесяц(Период.ДатаНачала, 3*КоличествоПериодов);
		ИначеЕсли КоличествоПериодов > 0 Тогда
			Период.ДатаНачала    = Период.ДатаОкончания + 1;
			Период.ДатаОкончания = ДобавитьМесяц(Период.ДатаОкончания, 3*КоличествоПериодов);
		КонецЕсли;

	ИначеЕсли (Периодичность = ПредопределенноеЗначение("Перечисление.Периодичность.Полугодие")) Тогда

		Если Месяц(БазоваяДата) < 7 Тогда
			Период.ДатаНачала    = НачалоГода(БазоваяДата);
			Период.ДатаОкончания = КонецГода(ДобавитьМесяц(Период.ДатаНачала, - 6));
		Иначе
			Период.ДатаНачала    = ДобавитьМесяц(НачалоГода(БазоваяДата), 6);
			Период.ДатаОкончания = КонецГода(БазоваяДата);
		КонецЕсли;

		Если КоличествоПериодов < 0 Тогда
			Период.ДатаОкончания = Период.ДатаНачала - 1;
			Период.ДатаНачала    = ДобавитьМесяц(Период.ДатаНачала, 6*КоличествоПериодов);
		ИначеЕсли КоличествоПериодов > 0 Тогда
			Период.ДатаНачала    = Период.ДатаОкончания + 1;
			Период.ДатаОкончания = ДобавитьМесяц(Период.ДатаОкончания, 6*КоличествоПериодов);
		КонецЕсли;

	ИначеЕсли (Периодичность = ПредопределенноеЗначение("Перечисление.Периодичность.Год")) Тогда

		Период.ДатаНачала    = НачалоГода(БазоваяДата);
		Период.ДатаОкончания = КонецГода(БазоваяДата);

		Если КоличествоПериодов < 0 Тогда
			Период.ДатаОкончания = Период.ДатаНачала - 1;
			Период.ДатаНачала    = ДобавитьМесяц(Период.ДатаНачала, 12*КоличествоПериодов);
		ИначеЕсли КоличествоПериодов > 0 Тогда
			Период.ДатаНачала    = Период.ДатаОкончания + 1;
			Период.ДатаОкончания = ДобавитьМесяц(Период.ДатаОкончания, 12*КоличествоПериодов);
		КонецЕсли;

	КонецЕсли;

	Возврат Период;

КонецФункции

// Проверяет строку с адресом электронной почты на корректность введенных данных
//
// Параметры:
//  ПроверяемыйАдрес  - Строка - содержит строку с адресом электронной почты,
//                 		которую необходимо проверить.
// Возвращаемое значение:
//   Булево   		 - Ложь, если проверка закончилась успешно, Истина в обратном случае.
//
Функция ПроверитьЗаполнениеПочтовогоАдреса(ПроверяемыйАдрес) Экспорт
	
	Отказ = Ложь;
	АдресДляПроверки = ПроверяемыйАдрес;
	
	Попытка
		Результат =  ОбщегоНазначенияКлиентСервер.РазобратьСтрокуСПочтовымиАдресами(АдресДляПроверки);	 
	Исключение 		
		Отказ = Истина;
	КонецПопытки;
	
	Если НЕ Отказ Тогда
		Если Результат.Количество() = 0 Тогда
			Отказ =  Истина;
		Иначе	
			АдресДляПроверки = Результат[0].Адрес;
			Если СтрЧислоВхождений(АдресДляПроверки,"@") <> 1 Тогда 
				Отказ = Истина;
			Иначе
				ДоменныйАдрес = Прав(АдресДляПроверки, СтрДлина(АдресДляПроверки) - Найти(АдресДляПроверки,"@"));
				Если СтрДлина(ДоменныйАдрес) > 0 Тогда
					Если СтрЧислоВхождений(ДоменныйАдрес,".") < 1 ИЛИ Лев(ДоменныйАдрес,1) = "." ИЛИ Прав(ДоменныйАдрес,1) = "." Тогда
						Отказ = Истина;
					КонецЕсли;
				Иначе
					Отказ = Истина;
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;	
	КонецЕсли;	
	
	Возврат Отказ;
	
КонецФункции // ПроверитьЗаполнениеПочтовогоАдреса() 

// Вычисляет значение идентификатора из строки соответствии с правилами
// именования идентификаторов.
//
// Параметры:
//		СтрНаименование - Строка - разбираемая строка.
//
// Возвращаемое значение:
// 	Строка - Идентификатор, соответствующий правилам именования идентификаторов.
//
Функция ПолучитьИдентификатор(СтрНаименование) Экспорт
	
	Разделители	=  " .,+,-,/,*,?,=,<,>,(,)%!@#$%&*""№:;{}[]?()\|/`~'^_";
	
	Идентификатор = "";
	БылСпецСимвол = Ложь;
	
	Для НомСимвола = 1 По СтрДлина(СтрНаименование) Цикл
		
		Символ = Сред(СтрНаименование, НомСимвола, 1);
		
		Если Найти(Разделители, Символ) <> 0 Тогда
			БылСпецСимвол = Истина;
		ИначеЕсли БылСпецСимвол Тогда
			БылСпецСимвол = Ложь;
			Идентификатор = Идентификатор + ВРег(Символ);
		Иначе
			Идентификатор = Идентификатор + Символ;
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат Идентификатор;
	
КонецФункции // ПолучитьИдентификатор()

// Заполняет все строки указанных колонок коллекции указанным значением
//
// Параметры:
// 		Коллекция - ДанныеФормыКоллекция - Коллекция для заполнения строк
// 		Значение - Произвольный - Значение для подстановки
// 		Колонки - Строка - Строка перечисленных через запятую имен колонок коллекции.
//
Процедура ЗаполнитьЗначенияСвойствКоллекции(Коллекция, Значение, Колонки) Экспорт
	
	СтруктураЗаполнения = Новый Структура(Колонки);
	Для Каждого Колонка Из СтруктураЗаполнения Цикл
		СтруктураЗаполнения[Колонка.Ключ] = Значение;
	КонецЦикла;
	
	Для Сч = 0 По Коллекция.Количество() - 1 Цикл
		ЗаполнитьЗначенияСвойств(Коллекция[Сч], СтруктураЗаполнения);
	КонецЦикла;
	
КонецПроцедуры // ЗаполнитьЗначенияКолонокКоллекции()

// Используется для преобразования страниц саммари
//
// Параметры:
//  СтрокаКПреобразованию - Строка - Строка, из которой необходиомо удалить блок
//  СтрокаОграничивающая - Строка - ограчитель блока, который подлежит удалению.
//
Процедура УдалитьИзСтрокиПодстроку(СтрокаКПреобразованию, СтрокаОграничивающая) Экспорт
	
	ИндексПервогоВхождения = Найти(СтрокаКПреобразованию, СтрокаОграничивающая);
	Если ИндексПервогоВхождения = 0 Тогда
		Возврат;
	КонецЕсли;
	ДлинаВходящейСтроки = СтрДлина(СтрокаКПреобразованию);
	ЛеваяЧасть =  ЛЕВ(СтрокаКПреобразованию, ИндексПервогоВхождения-1);
	ПраваяЧастьСтрокиКОбработке = Прав(СтрокаКПреобразованию, СтрДлина(СтрокаКПреобразованию) - ИндексПервогоВхождения-4);
	ИндексВторогоВхождения = Найти(ПраваяЧастьСтрокиКОбработке, СтрокаОграничивающая);
	Если ИндексВторогоВхождения = 0 Тогда
		Возврат;
	КонецЕсли;
	ПраваяЧасть = ПРАВ(ПраваяЧастьСтрокиКОбработке,СтрДлина(ПраваяЧастьСтрокиКОбработке) - ИндексВторогоВхождения -4);
	
	СтрокаКПреобразованию = ЛеваяЧасть +  ПраваяЧасть;
	
КонецПроцедуры

// Функция выполняет пропорциональное распределение суммы в соответствии
// с заданными коэффициентами распределения.
//
// Параметры:
//		ИсхСумма - Сумма - распределяемая сумма
//		МассивКоэф - Массив - массив коэффициентов распределения
//		Точность - Число - точность округления при распределении. Необязателен.
//
//	Возвращаемое значение:
//		Массив - массив размерностью равный массиву коэффициентов, содержит
//			суммы в соответствии с весом коэффициента (из массива коэффициентов)
//          В случае если распределить не удалось (сумма = 0, кол-во коэф. = 0,
//          или суммарный вес коэф. = 0), тогда возвращается значение Неопределено.
//
Функция РаспределитьПропорционально(Знач ИсхСумма, МассивКоэф, Знач Точность = 2) Экспорт

	Если МассивКоэф.Количество() = 0 Или ИсхСумма = 0 Или ИсхСумма = Null Тогда
		Возврат Неопределено;
	КонецЕсли;

	ИндексМакс = 0;
	МаксЗнач   = 0;
	РаспрСумма = 0;
	СуммаКоэф  = 0;

	Для Сч = 0 По МассивКоэф.Количество() - 1 Цикл

		МодульЧисла = ?(МассивКоэф[Сч] > 0, МассивКоэф[Сч], - МассивКоэф[Сч]);

		Если МаксЗнач < МодульЧисла Тогда
			МаксЗнач = МодульЧисла;
			ИндексМакс = Сч;
		КонецЕсли;

		СуммаКоэф = СуммаКоэф + МассивКоэф[Сч];

	КонецЦикла;

	Если СуммаКоэф = 0 Тогда
		Возврат Неопределено;
	КонецЕсли;

	МассивСумм = Новый Массив(МассивКоэф.Количество());

	Для Сч = 0 По МассивКоэф.Количество() - 1 Цикл
		МассивСумм[Сч] = Окр(ИсхСумма * МассивКоэф[Сч] / СуммаКоэф, Точность, 1);
		РаспрСумма = РаспрСумма + МассивСумм[Сч];
	КонецЦикла;

	// Погрешности округления отнесем на коэффициент с максимальным весом
	Если Не РаспрСумма = ИсхСумма Тогда
		МассивСумм[ИндексМакс] = МассивСумм[ИндексМакс] + ИсхСумма - РаспрСумма;
	КонецЕсли;

	Возврат МассивСумм;

КонецФункции // РаспределитьПропорционально()

// Проверяет, что авторизован внешний пользователь
//
// Возвращаемое значение:
//   Булево   - Истина, если авторизован внешний пользователь. Ложь, в обратном случае.
//
Функция АвторизованВнешнийПользователь() Экспорт

	Возврат ТипЗнч(ПользователиКлиентСервер.АвторизованныйПользователь()) =  Тип("СправочникСсылка.ВнешниеПользователи");

КонецФункции

// Функция формирует список значений, содержащий значения времени, рассчитанные
// с указанным интервалом.
// Параметры:
// 	ТекущееЗначение - Строка - исходное значение времени.
// 	Интервал - Число - интервал, с которым необходимо заполнить список, по умолчанию час.
//
//	Возвращаемое значение:
//		СписокЗначений - Список значений со временем.
Функция СписокВремени(Знач ТекущееЗначение = '00010101000000', Интервал = 3600) Экспорт
	
	НачалоРабочегоДня      = '00010101000000';
	ОкончаниеРабочегоДня   = '00010101235959';

	СписокВремен = Новый СписокЗначений;
	НачалоРабочегоДня = НачалоЧаса(НачалоДня(ТекущееЗначение) +
		Час(НачалоРабочегоДня) * 3600 +
		Минута(НачалоРабочегоДня)*60);
	ОкончаниеРабочегоДня = КонецЧаса(НачалоДня(ТекущееЗначение) +
		Час(ОкончаниеРабочегоДня) * 3600 +
		Минута(ОкончаниеРабочегоДня)*60);

	ВремяСписка = НачалоРабочегоДня;
	Пока НачалоЧаса(ВремяСписка) <= НачалоЧаса(ОкончаниеРабочегоДня) Цикл
		Если НЕ ЗначениеЗаполнено(ВремяСписка) Тогда
			ПредставлениеВремени = "00:00";
		Иначе
			ПредставлениеВремени = Формат(ВремяСписка,"ДФ=ЧЧ:мм");
		КонецЕсли;

		СписокВремен.Добавить(ВремяСписка, ПредставлениеВремени);

		ВремяСписка = ВремяСписка + Интервал;
	КонецЦикла;
	
	Возврат СписокВремен;
	
КонецФункции

// Функция преобразует строку к множественному числу. Предназначена для формирования "правильной" подписи к числительным.
//
// Параметры: 
//  Слово1 - Строка - форма слова в ед числе      ("шкаф")
//  Слово2 - Строка - форма слова для числит 2-4  ("шкафа")
//  Слово3 - Строка - форма слова для числит 5-10 ("шкафов")
//  ЦелоеЧисло - Число - целое число.
//
// Возвращаемое значение:
//  Строка - одну из строк в зависимости от параметра ЦелоеЧисло.
//
Функция ФормаМножественногоЧисла(Слово1, Слово2, Слово3, Знач ЦелоеЧисло) Экспорт
	
	// Изменим знак целого числа, иначе отрицательные числа будут неправильно преобразовываться.
	Если ЦелоеЧисло < 0 Тогда
		ЦелоеЧисло = -1 * ЦелоеЧисло;
	КонецЕсли;
	
	Если ЦелоеЧисло <> Цел(ЦелоеЧисло) Тогда 
		// для нецелых чисел - всегда вторая форма
		Возврат Слово2;
	КонецЕсли;
	
	// остаток
	Остаток = ЦелоеЧисло%10;
	Если (ЦелоеЧисло >10) И (ЦелоеЧисло<20) Тогда
		// для второго десятка - всегда третья форма
		Возврат Слово3;
	ИначеЕсли Остаток=1 Тогда
		Возврат Слово1;
	ИначеЕсли (Остаток>1) И (Остаток<5) Тогда
		Возврат Слово2;
	Иначе
		Возврат Слово3;
	КонецЕсли;

КонецФункции

#КонецОбласти

#Область ВспомогательныеПроцедурыРаботыСОтчетами

// Устанавливает значение свойства элемента формы, если находит элемент на форме.
//
// Параметры:
//  ЭлементыФормы - ВсеЭлементыФормы - элементы формы, среди которых содержится искомый элемент.
//  ИмяЭлемента   - Строка - имя искомого элемента.
//  ИмяСвойства   - Строка - имя свойства, для которого будет устанавливаться значение.
//  Значение      - Произвольный - значение, которое будет установлено.
//  УстанавливатьДляПодчиненных - Булево - установить аналогичное свойство для подчиненных элементов искомого элемента.
//
Процедура УстановитьСвойствоЭлементаФормы(ЭлементыФормы, ИмяЭлемента, ИмяСвойства, Значение, УстанавливатьДляПодчиненных = Ложь) Экспорт
	
	Элемент = ЭлементыФормы.Найти(ИмяЭлемента);
	Если Элемент = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	Если НРег(ИмяСвойства) = "толькопросмотр"
		И ТипЗнч(Элемент) = Тип("КнопкаФормы") Тогда
			
		ИмяСвойстваЭлемента = "Доступность";
		ЗначениеСвойства    = НЕ Значение;
	Иначе
		ИмяСвойстваЭлемента = ИмяСвойства;
		ЗначениеСвойства    = Значение;
	КонецЕсли;
	
	Если Элемент[ИмяСвойстваЭлемента] <> ЗначениеСвойства Тогда
		Элемент[ИмяСвойстваЭлемента] = ЗначениеСвойства;
	КонецЕсли;
	
	ТипыЭлементовФормыСПодчиненнымиЭлементами = Новый ОписаниеТипов("УправляемаяФорма, ГруппаФормы, ТаблицаФормы");
	
	Если УстанавливатьДляПодчиненных И ТипыЭлементовФормыСПодчиненнымиЭлементами.СодержитТип(ТипЗнч(Элемент)) Тогда
		Для Каждого ПодчиненныйЭлемент Из Элемент.ПодчиненныеЭлементы Цикл
			УстановитьСвойствоЭлементаФормы(ЭлементыФормы, ПодчиненныйЭлемент.Имя, ИмяСвойства, Значение, Истина);
		КонецЦикла;
 	КонецЕсли;
 	
КонецПроцедуры // УстановитьСвойствоЭлементаФорма()

// Устанавливает значение свойства элементов формы, если находит элемент на форме.
//
// Параметры:
//  ЭлементыФормы  - ВсеЭлементыФормы - элементы формы, среди которых содержится искомый элемент.
//  ИменаЭлементов - Массив, Строка, Структура - имена искомых элементов.
//  ИмяСвойства    - Строка - имя свойства, для которого будет устанавливаться значение.
//  Значение       - Произвольный - значение, которое будет установлено
//  УстанавливатьДляПодчиненных - Булево - установить аналогичное свойство для подчиненных элементов искомых элементов.
//
Процедура УстановитьСвойствоЭлементовФормы(ЭлементыФормы, ИменаЭлементов, ИмяСвойства, Значение, УстанавливатьДляПодчиненных = Ложь) Экспорт
	
	Если ТипЗнч(ИменаЭлементов) = Тип("Массив") Тогда
		
		Для Каждого ИмяЭлемента Из ИменаЭлементов Цикл
			УстановитьСвойствоЭлементаФормы(ЭлементыФормы, ИмяЭлемента, ИмяСвойства, Значение, УстанавливатьДляПодчиненных);
		КонецЦикла
		
	Иначе
		
		Если ТипЗнч(ИменаЭлементов) = Тип("Строка") Тогда
			СтруктураИменЭлементов = Новый Структура(ИменаЭлементов);
		Иначе
			СтруктураИменЭлементов = ИменаЭлементов;
		КонецЕсли;
		
		Для Каждого ИмяЭлемента Из СтруктураИменЭлементов Цикл
			УстановитьСвойствоЭлементаФормы(ЭлементыФормы, ИмяЭлемента.Ключ, ИмяСвойства, Значение, УстанавливатьДляПодчиненных);
		КонецЦикла
		
	КонецЕсли;
	
КонецПроцедуры // УстановитьСвойствоЭлементовФормы()

// Процедура заполняет массив непроверяемых реквизитов значениями,
// не используемыми при выбранной хозяйственной операции документа.
//
// Параметры:
//	МассивВсехРеквизитов - Массив - Массив всех реквизитов документа
//	МассивРеквизитовОперации - Массив - Массив реквизитов документа, которые относятся к хозяйственной операции документа
//	МассивНепроверяемыхРеквизитов - Массив - Массив реквизитов объекта, не требующих проверки.
//
Процедура ЗаполнитьМассивНепроверяемыхРеквизитов(МассивВсехРеквизитов, МассивРеквизитовОперации, МассивНепроверяемыхРеквизитов) Экспорт
	
	Для Каждого ЭлементМассива Из МассивВсехРеквизитов Цикл
		
		// Если реквизит не используется для хозяйственной операции, исключаем данный реквизит из проверки.
		Если МассивРеквизитовОперации.Найти(ЭлементМассива) = Неопределено Тогда
			МассивНепроверяемыхРеквизитов.Добавить(ЭлементМассива);
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры // ЗаполнитьМассивНепроверяемыхРеквизитов()

// Сбрасывает служебный реквизит - ПодразделениеОбязательно, если его заполнение не требуется.
//
// Параметры:
// 	Товары - ДанныеФормыКоллекция - таблица формы Товары.
// 	Подразделение - СправочникСсылка.СтруктураПредприятия - подразделение, реквизит Формы.
// 	ПодразделениеОбязательно - Булево - служебный реквизит Формы, определяет необходимость заполнения подразделения.
// 	НеУчитыватьОтмененныеСтроки - Булево - не учитывать отмененные строки.
//
// Возвращаемое значение:
// 	Булево - Ложь, если значение реквизита было сброшено.
//
Функция ПроверитьНеобходимостьОбновленияПодразделения(Товары,
	                                                    Подразделение,
	                                                    ПодразделениеОбязательно,
	                                                    НеУчитыватьОтмененныеСтроки=Ложь) Экспорт
	Если Товары.Количество() = 0 Или ЗначениеЗаполнено(Подразделение) Тогда
		ПодразделениеОбязательно = Ложь;
		Возврат Ложь;
	КонецЕсли;
	
	Возврат Истина;
	
КонецФункции // ПроверитьНеобходимостьОбновленияПодразделения()

#КонецОбласти

#Область ВспомогательныеПроцедурыРаботыСПодсистемойКонтрольИАнализ

// Функция - Получить персональные настройки монитора целевых показателей по умолчанию
// Возвращаемое значение:
//  Структура - Ключи:
//		"ВариантГруппировкиПоказателей" - Значение "ПоВажности",
//		"КоличествоКолонокМонитораПоказателей" - Значение 3,
//		"РазмерДиаграмм" - Значение 1,
//		"ВариантОтображенияДеталей" - Значение "ПоказыватьТолькоТекущееЗначение",
//		"ПериодАвтообновления" - Значение 15.
Функция ПолучитьПерсональныеНастройкиМонитораЦелевыхПоказателейПоУмолчанию() Экспорт
	
	НастройкиПоУмолчанию = Новый Структура;
	
	// порядок вывода показателей
	НастройкиПоУмолчанию.Вставить("ВариантГруппировкиПоказателей", "ПоВажности");
	НастройкиПоУмолчанию.Вставить("КоличествоКолонокМонитораПоказателей", 3);
	
	// Внешний вид показателей
	НастройкиПоУмолчанию.Вставить("РазмерДиаграмм", 1);
	НастройкиПоУмолчанию.Вставить("ВариантОтображенияДеталей", "ПоказыватьТолькоТекущееЗначение");
	
	// Обновление данных
	НастройкиПоУмолчанию.Вставить("ПериодАвтообновления", 15);
	
	Возврат НастройкиПоУмолчанию;
	
КонецФункции

#КонецОбласти

#Область ВспомогательныеПроцедурыРаботыСФормами

// Получить массив отмеченных элементов табличной части формы по массиву идентификаторов
// выделенных строк таблицы формы.
//
// Параметры:
//	Коллекция - ДанныеФормыКоллекция - табличная часть основного реквизита формы.
//	Идентификаторы - Массив - массив целых чисел, свойство ВыделенныеСтроки таблицы формы.
//
// Возвращаемое значение:
//	Массив - Массив выделенных строк.
//
Функция ВыделенныеЭлементыКоллекции(Коллекция, Идентификаторы) Экспорт
	
	ВыделенныеЭлементы = Новый Массив;
	Для Каждого ИндексСтроки Из Идентификаторы Цикл
		ЭлементКоллекции = Коллекция.НайтиПоИдентификатору(ИндексСтроки);
		Если ЭлементКоллекции <> Неопределено Тогда
			ВыделенныеЭлементы.Добавить(ЭлементКоллекции);
		КонецЕсли;
	КонецЦикла;
	Возврат ВыделенныеЭлементы;
	
КонецФункции

// Устанавливается свойство ОтображениеПредупрежденияПриРедактировании элемента формы.
//
// Параметры:
//		Элемент - ЭлементФормы - элемент.
//		Отображать - Булево - отображать предупреждение при редактировании.
Процедура ОтображениеПредупрежденияПриРедактировании(Элемент, Отображать) Экспорт
	
	Если Отображать Тогда
		Элемент.ОтображениеПредупрежденияПриРедактировании = ОтображениеПредупрежденияПриРедактировании.Отображать;
	Иначе
		Элемент.ОтображениеПредупрежденияПриРедактировании = ОтображениеПредупрежденияПриРедактировании.НеОтображать;
	КонецЕсли;
	
КонецПроцедуры

#КонецОбласти

#Область ФункцииДляПоддержкиФормированияПечатныхФорм

// Возвращает заголовок документа в том виде, в котором его формирует платформа для представления ссылки на документ.
//
// Параметры:
//  Шапка - Структура - с ключами
//          Номер - строка или число - номер документа
//          Дата  - дата - дата документа
//  НазваниеДокумента - Строка - название документа (например, синоним объекта метаданных).
//  УдалитьТолькоЛидирующиеНулиИзНомераОбъекта - Булево - Удалить только лидируещие нули.
//
// Возвращаемое значение: 
//  Строка - заголовок документа.
//
Функция СформироватьЗаголовокДокумента(Шапка, знач НазваниеДокумента = "", УдалитьТолькоЛидирующиеНулиИзНомераОбъекта = Ложь) Экспорт
	
	ДанныеДокумента = Новый Структура("Номер,Дата,Представление");
	ЗаполнитьЗначенияСвойств(ДанныеДокумента, Шапка);
	
	// Если название документа не передано, получим название по представлению документа.
	Если ПустаяСтрока(НазваниеДокумента) И ЗначениеЗаполнено(ДанныеДокумента.Представление) Тогда
		ПоложениеНомера = Найти(ДанныеДокумента.Представление, ДанныеДокумента.Номер);
		Если ПоложениеНомера > 0 Тогда
			НазваниеДокумента = СокрЛП(Лев(ДанныеДокумента.Представление, ПоложениеНомера - 1));
		КонецЕсли;
	КонецЕсли;

	Если УдалитьТолькоЛидирующиеНулиИзНомераОбъекта Тогда
		НомерНаПечать = ПрефиксацияОбъектовКлиентСервер.УдалитьЛидирующиеНулиИзНомераОбъекта(ДанныеДокумента.Номер);
	Иначе 
		// Кроме лидирующих нулей будут удалены также префикс организации и префикс информационной базы.
		НомерНаПечать = ПрефиксацияОбъектовКлиентСервер.НомерНаПечать(ДанныеДокумента.Номер);
	КонецЕсли;
	
	Возврат СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
		НСтр("ru = '%1 № %2 от %3'"),
		НазваниеДокумента, НомерНаПечать, Формат(ДанныеДокумента.Дата, "ДЛФ=DD"));
	
КонецФункции

#КонецОбласти

#Область ВыборПериодаИзСписка

// Функция - Начало периода отчета
//
// Параметры:
//  ВидПериода	 - Перечисление.ДоступныеПериодыОтчета - Вид периода
//  ДатаПериода	 - Дата - Дата периода.
// Возвращаемое значение:
//  Дата - Начало периода.
Функция НачалоПериодаОтчета(ВидПериода, ДатаПериода) Экспорт
	
	НачалоПериода = ДатаПериода;
	
	Если ВидПериода = ПредопределенноеЗначение("Перечисление.ДоступныеПериодыОтчета.Год") Тогда
		НачалоПериода = НачалоГода(ДатаПериода);
		
	ИначеЕсли ВидПериода = ПредопределенноеЗначение("Перечисление.ДоступныеПериодыОтчета.Полугодие") Тогда
		Если Месяц(ДатаПериода) > 6 Тогда
			НачалоПериода = Дата(Год(ДатаПериода), 7, 1);
		Иначе
			НачалоПериода = Дата(Год(ДатаПериода), 1, 1);
		КонецЕсли;
		
	ИначеЕсли ВидПериода = ПредопределенноеЗначение("Перечисление.ДоступныеПериодыОтчета.Квартал") Тогда
		НачалоПериода = НачалоКвартала(ДатаПериода);
		
	ИначеЕсли ВидПериода = ПредопределенноеЗначение("Перечисление.ДоступныеПериодыОтчета.Месяц") Тогда
		НачалоПериода = НачалоМесяца(ДатаПериода);
		
	ИначеЕсли ВидПериода = ПредопределенноеЗначение("Перечисление.ДоступныеПериодыОтчета.Декада") Тогда
		Если День(ДатаПериода) <= 10 Тогда
			НачалоПериода = Дата(Год(ДатаПериода), Месяц(ДатаПериода), 1);
		ИначеЕсли День(ДатаПериода) > 10 И День(ДатаПериода) <= 20 Тогда
			НачалоПериода = Дата(Год(ДатаПериода), Месяц(ДатаПериода), 11);
		Иначе
			НачалоПериода = Дата(Год(ДатаПериода), Месяц(ДатаПериода), 21);
		КонецЕсли;
		
	ИначеЕсли ВидПериода = ПредопределенноеЗначение("Перечисление.ДоступныеПериодыОтчета.Неделя") Тогда
		НачалоПериода = НачалоНедели(ДатаПериода);
		
	ИначеЕсли ВидПериода = ПредопределенноеЗначение("Перечисление.ДоступныеПериодыОтчета.День") Тогда
		НачалоПериода = НачалоДня(ДатаПериода);
		
	КонецЕсли;
		
	Возврат НачалоПериода;
	
КонецФункции
 
// Функция - Конец периода отчета
//
// Параметры:
//  ВидПериода	 - Перечисление.ДоступныеПериодыОтчета - Вид периода
//  ДатаПериода	 - Дата - Дата периода.
// Возвращаемое значение:
//  Дата - Конец периода.
Функция КонецПериодаОтчета(ВидПериода, ДатаПериода) Экспорт
	
	КонецПериода = ДатаПериода;
	
	Если ВидПериода = ПредопределенноеЗначение("Перечисление.ДоступныеПериодыОтчета.Год") Тогда
		КонецПериода = КонецГода(ДатаПериода);
		
	ИначеЕсли ВидПериода = ПредопределенноеЗначение("Перечисление.ДоступныеПериодыОтчета.Полугодие") Тогда
		Если Месяц(ДатаПериода) > 6 Тогда
			КонецПериода = КонецГода(ДатаПериода);
		Иначе
			КонецПериода = КонецДня(Дата(Год(ДатаПериода), 6, 30));
		КонецЕсли;
		
	ИначеЕсли ВидПериода = ПредопределенноеЗначение("Перечисление.ДоступныеПериодыОтчета.Квартал") Тогда
		КонецПериода = КонецКвартала(ДатаПериода);
		
	ИначеЕсли ВидПериода = ПредопределенноеЗначение("Перечисление.ДоступныеПериодыОтчета.Месяц") Тогда
		КонецПериода = КонецМесяца(ДатаПериода);
		
	ИначеЕсли ВидПериода = ПредопределенноеЗначение("Перечисление.ДоступныеПериодыОтчета.Декада") Тогда
		Если День(ДатаПериода) <= 10 Тогда
			КонецПериода = КонецДня(Дата(Год(ДатаПериода), Месяц(ДатаПериода), 10));
		ИначеЕсли День(ДатаПериода) > 10 И День(ДатаПериода) <= 20 Тогда
			КонецПериода = КонецДня(Дата(Год(ДатаПериода), Месяц(ДатаПериода), 20));
		Иначе
			КонецПериода = КонецМесяца(ДатаПериода);
		КонецЕсли;
		
	ИначеЕсли ВидПериода = ПредопределенноеЗначение("Перечисление.ДоступныеПериодыОтчета.Неделя") Тогда
		КонецПериода = КонецНедели(ДатаПериода);
		
	ИначеЕсли ВидПериода = ПредопределенноеЗначение("Перечисление.ДоступныеПериодыОтчета.День") Тогда
		КонецПериода = КонецДня(ДатаПериода);
		
	КонецЕсли;
		
	Возврат КонецПериода;
	
КонецФункции

// Функция - Получить список периодов
//
// Параметры:
//  НачалоПериода	 - Дата - Начало периода 
//  ВидПериода		 - Перечисление.ДоступныеПериодыОтчета - Вид периода. 
// Возвращаемое значение:
//  СписокЗначений - Список периодоа.
Функция ПолучитьСписокПериодов(Знач НачалоПериода, Знач ВидПериода) Экспорт
	                                                                                                  
	СписокПериодов = Новый СписокЗначений;
	Если НачалоПериода = '00010101' Тогда
		Возврат Новый СписокЗначений;
	Иначе
		ЗначениеНачалоПериода = НачалоПериода;
	КонецЕсли;
	
	Если ВидПериода = ПредопределенноеЗначение("Перечисление.ДоступныеПериодыОтчета.Год") Тогда
		ТекущийГод = Год(ЗначениеНачалоПериода);
		СписокПериодов.Добавить(Дата(ТекущийГод - 7, 1, 1), "Предыдущие года");
		Для Сч = ТекущийГод - 3 По ТекущийГод + 3 Цикл
			СписокПериодов.Добавить(Дата(Сч, 1, 1), Формат(Сч, "ЧГ=0"));
		КонецЦикла;
		СписокПериодов.Добавить(Дата(ТекущийГод + 7, 1, 1), "Последующие года");
		
	ИначеЕсли ВидПериода = ПредопределенноеЗначение("Перечисление.ДоступныеПериодыОтчета.Полугодие") Тогда
		ТекущийГод = Год(ЗначениеНачалоПериода);
		СписокПериодов.Добавить(Дата(ТекущийГод - 2, 1, 1), Формат(ТекущийГод - 2, "ЧГ=0") + "...");
		Для Сч = ТекущийГод - 1 По ТекущийГод + 1 Цикл
			СписокПериодов.Добавить(Дата(Сч, 1, 1), "I полугодие " + Формат(Сч, "ЧГ=0"));
			СписокПериодов.Добавить(Дата(Сч, 7, 1), "II полугодие " + Формат(Сч, "ЧГ=0"));
		КонецЦикла;
		СписокПериодов.Добавить(Дата(ТекущийГод + 2, 1, 1), Формат(ТекущийГод + 2, "ЧГ=0") + "...");
		
	ИначеЕсли ВидПериода = ПредопределенноеЗначение("Перечисление.ДоступныеПериодыОтчета.Квартал") Тогда
		ТекущийГод = Год(ЗначениеНачалоПериода);
		СписокПериодов.Добавить(Дата(ТекущийГод - 2, 1, 1), Формат(ТекущийГод - 2, "ЧГ=0") + "...");
		Для Сч = ТекущийГод - 1 По ТекущийГод Цикл
			СписокПериодов.Добавить(Дата(Сч, 1, 1), "I квартал " + Формат(Сч, "ЧГ=0"));
			СписокПериодов.Добавить(Дата(Сч, 4, 1), "II квартал " + Формат(Сч, "ЧГ=0"));
			СписокПериодов.Добавить(Дата(Сч, 7, 1), "III квартал " + Формат(Сч, "ЧГ=0"));
			СписокПериодов.Добавить(Дата(Сч, 10, 1), "IV квартал " + Формат(Сч, "ЧГ=0"));
		КонецЦикла;
		СписокПериодов.Добавить(Дата(ТекущийГод + 1, 1, 1), Формат(ТекущийГод + 1, "ЧГ=0") + "...");
		
	ИначеЕсли ВидПериода = ПредопределенноеЗначение("Перечисление.ДоступныеПериодыОтчета.Месяц") Тогда
		ТекущийГод = Год(ЗначениеНачалоПериода);
		СписокПериодов.Добавить(Дата(ТекущийГод - 1, 1, 1), Формат(ТекущийГод - 1, "ЧГ=0") + "...");
		Для Сч = 1 По 12 Цикл
			СписокПериодов.Добавить(Дата(ТекущийГод, Сч, 1), Формат(Дата(ТекущийГод, Сч, 1), "ДФ='MMMM yyyy'"));
		КонецЦикла;
		СписокПериодов.Добавить(Дата(ТекущийГод + 1, 1, 1), Формат(ТекущийГод + 1, "ЧГ=0") + "...");

	ИначеЕсли ВидПериода = ПредопределенноеЗначение("Перечисление.ДоступныеПериодыОтчета.Декада") Тогда
		ТекущийГод   = Год(ЗначениеНачалоПериода);
		ТекущийМесяц = Месяц(ЗначениеНачалоПериода);
		
		СчМесяц = ?(ТекущийМесяц - 4 < 1, 12 + ТекущийМесяц - 4, ТекущийМесяц - 4);
		СчГод   = ?(ТекущийМесяц - 4 < 1, ТекущийГод - 1       , ТекущийГод);
		Сч = 6;
		
		Период = Дата(?(СчМесяц <> 1, СчГод, СчГод - 1), ?(СчМесяц > 1, СчМесяц - 1, 12), 1);
		СписокПериодов.Добавить(Период, Формат(Период, "ДФ='MMMM yyyy'") + "...");
		Пока Сч >0 Цикл
			СписокПериодов.Добавить(Дата(СчГод, СчМесяц, 1),  "I дек. " + Нрег(Формат(Дата(СчГод, СчМесяц, 1), "ДФ='MMMM yyyy'")));
			СписокПериодов.Добавить(Дата(СчГод, СчМесяц, 11), "II дек. " + Нрег(Формат(Дата(СчГод, СчМесяц, 1), "ДФ='MMMM yyyy'")));
			СписокПериодов.Добавить(Дата(СчГод, СчМесяц, 21), "III дек. " + Нрег(Формат(Дата(СчГод, СчМесяц, 1), "ДФ='MMMM yyyy'")));
			СчМесяц = СчМесяц + 1;
			Если СчМесяц > 12 Тогда
				СчГод = СчГод + 1;
				СчМесяц = 1;
			КонецЕсли;
			Сч = Сч - 1;
		КонецЦикла;
		СписокПериодов.Добавить(Дата(СчГод, СчМесяц, 1), Формат(Дата(СчГод, СчМесяц, 1), "ДФ='MMMM yyyy'") + "...");
		
	ИначеЕсли ВидПериода = ПредопределенноеЗначение("Перечисление.ДоступныеПериодыОтчета.Неделя") Тогда
		НачалоНедели = НачалоНедели(ЗначениеНачалоПериода) - 21 * 86400;
		
		СписокПериодов.Добавить(НачалоНедели - 7 * 86400, "Пред. недели ...");
		Для Сч = 0 По 6 Цикл
			НачНедели = НачалоНедели + 7 * Сч * 86400;  
			КонНедели = КонецНедели(НачНедели);
			СписокПериодов.Добавить(НачНедели, Формат(НачНедели, "ДФ=dd.MM") + " - " + Формат(КонНедели, "ДФ=dd.MM"));
		КонецЦикла;
		СписокПериодов.Добавить(НачалоНедели + 7 * 86400, "След. недели ..." );
		
	ИначеЕсли ВидПериода = ПредопределенноеЗначение("Перечисление.ДоступныеПериодыОтчета.День") Тогда
		КонецНедели   = КонецНедели(ЗначениеНачалоПериода);
		ДатаДняНедели = НачалоНедели(ЗначениеНачалоПериода);
		
		СписокПериодов.Добавить(ДатаДняНедели - 86400, "Предыдущая неделя");
		
		Пока ДатаДняНедели < КонецНедели Цикл
			ДеньНед = ДеньНедели(ДатаДняНедели);
			
			СписокПериодов.Добавить(ДатаДняНедели, Формат(ДатаДняНедели, "ДФ='dd MMMM yyyy (ddd)'"));
			
			ДатаДняНедели = ДатаДняНедели + 86400;
		КонецЦикла;
		
		СписокПериодов.Добавить(КонецНедели + 1, "Следующая неделя");
	КонецЕсли;
		
	Возврат СписокПериодов;
	
КонецФункции

#КонецОбласти

#Область РаботаСДинамическимиСписками

// Определяет отбор динамического списка в зависимости от наличия режима совместимости.
//
// Параметры:
//  Список - ДинамическийСписок - список, для которого надо определить отбор.
//
// Возвращаемое значение:
//   Отбор - требуемый отбор.
//
Функция ПолучитьОтборДинамическогоСписка(Список) Экспорт
	
	Возврат Список.КомпоновщикНастроек.ФиксированныеНастройки.Отбор;
	
КонецФункции

// Определяет поля группировки динамического списка в зависимости от наличия режима совместимости.
//
// Параметры:
//  Список - ДинамическийСписок - список, для которого надо определить группировку.
//
// Возвращаемое значение:
//   ПоляГруппировкиКомпоновкиДанных - требуемые поля группировки.
//
Функция ПолучитьПоляГруппировкиДинамическогоСписка(Список) Экспорт
	Перем Группировка, ПоляГруппировки;
	
	Для Каждого Элемент Из Список.КомпоновщикНастроек.Настройки.Структура Цикл
		Если ТипЗнч(Элемент) = Тип("ГруппировкаКомпоновкиДанных") Тогда
			Группировка = Элемент;
			Прервать;
		КонецЕсли;
	КонецЦикла;
	
	Если Группировка = Неопределено Тогда
		Группировка = Список.КомпоновщикНастроек.Настройки.Структура.Добавить(Тип("ГруппировкаКомпоновкиДанных"));
		Группировка.Выбор.Элементы.Добавить(Тип("АвтоВыбранноеПолеКомпоновкиДанных"));
	КонецЕсли;
	
	ПоляГруппировки = Группировка.ПоляГруппировки;
	
	Возврат ПоляГруппировки;
	
КонецФункции

// Определяет условное оформление динамического списка в зависимости от наличия режима совместимости.
//
// Параметры:
//  Список - ДинамическийСписок - список, для которого надо определить условное оформление.
//
// Возвращаемое значение:
//   УсловноеОформление - требуемое условное оформление.
//
Функция ПолучитьУсловноеОформлениеДинамическогоСписка(Список) Экспорт
	
	Возврат Список.КомпоновщикНастроек.ФиксированныеНастройки.УсловноеОформление;
	
КонецФункции

#КонецОбласти

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

#Область ПреобразованиеТиповДанных

Функция Массив(ЭлементИлиМассив) Экспорт
	Если Тип("Массив") <> ТипЗнч(ЭлементИлиМассив) Тогда
		Массив = Новый Массив;
		Массив.Добавить(ЭлементИлиМассив);
	Иначе
		Массив = ЭлементИлиМассив;
	КонецЕсли;
	Возврат Массив;
КонецФункции

#КонецОбласти

#КонецОбласти
