
#Область ПрограммныйИнтерфейс

#Область МетодыРаботыАвтозаполненияРеквизитовДокумента

// Служебная функция, предназначенная для получения описания типов числа, заданной разрядности.
// 
// Параметры:
//  Разрядность 			- Число - разряд числа.
//  РазрядностьДробнойЧасти - Число - разряд дробной части.
//
// Возвращаемое значение:
//  ОписаниеТипов - Объект "ОписаниеТипов" для числа указанной разрядности.
//
Функция ПолучитьОписаниеТиповЧисла(Разрядность, РазрядностьДробнойЧасти) Экспорт

	Возврат Новый ОписаниеТипов("Число", Новый КвалификаторыЧисла(Разрядность, РазрядностьДробнойЧасти));

КонецФункции // ПолучитьОписаниеТиповЧисла()

// Служебная функция, предназначенная для получения описания типов даты
// 
// Параметры:
//  ЧастиДаты - ЧастиДаты - системное перечисление ЧастиДаты.
//
// Возвращаемое значение:
//		ОписаниеТипов - описание типов даты.
Функция ПолучитьОписаниеТиповДаты(ЧастиДаты) Экспорт

	Возврат Новый ОписаниеТипов("Дата", , , Новый КвалификаторыДаты(ЧастиДаты));

КонецФункции // ПолучитьОписаниеТиповДаты()

// Дополняет одну таблицу значений строками другой таблицы значений
// Параметры:
//		Приемник - ТаблицаЗначений - в которую добавляются строки
//		Источник - ТаблицаЗначений - из которой беруться добавляемые строки.
Процедура ДобавитьСтрокиВТаблицу(Приемник, Источник) Экспорт

	Для каждого СтрокаИсточника Из Источник Цикл
		ЗаполнитьЗначенияСвойств(Приемник.Добавить(), СтрокаИсточника);
	КонецЦикла;

КонецПроцедуры

// Заполняет колонку таблицы значений последовательными номерами
// Параметры:
//		Таблица - ТаблицаЗначений - строки которой нужно пронумеровать
//		ИмяКолонкиНомераСтроки - строка - колонка таблицы значений, в которой будут указаны номера строк.
Процедура ПронумероватьТаблицуЗначений(Таблица, ИмяКолонкиНомераСтроки) Экспорт

	Таблица.Колонки.Добавить(ИмяКолонкиНомераСтроки, ПолучитьОписаниеТиповЧисла(15, 0));

	КоличествоСтрок = Таблица.Количество() - 1;
	Для НомерСтроки = 0 По КоличествоСтрок Цикл
		Таблица[НомерСтроки][ИмяКолонкиНомераСтроки] = НомерСтроки;
	КонецЦикла;

КонецПроцедуры

// Выгружает таблицу значений из ДанныеФормыКоллекция и ТабличнаяЧасть.
//
// Параметры:
// 		ТаблицаИсточник - ДанныеФормыКоллекция, ТабличнаяЧасть - Таблица источник выгрузки
// 		Строки - Массив, Структура - Массив строк для выгрузки или структура отбора
// 		Колонки - Строка - Перечисленные через запятую имена колонок для выгрузки
// 		КолонкиПоЗначению - Структура - Структура колонок для добавление в результирующую таблицу:
// 										Ключ - Имя новой колонки
// 										Значение - Значение для подстановки по все строки новой колонки
// 		НовыеИменаКолонок - Структура - Структура с данными о переименовании колонок в результирующей таблице:
// 										Ключ - Текущее имя колонки
// 										Значение - Новое имя колонки.
//
// Возвращаемое значение:
// 		ТаблицаЗначений - Таблица результат выгрузки из таблицы источника с добавленными и переименоваными колонками.
//
Функция ВыгрузитьТаблицуЗначений(ТаблицаИсточник, Строки=Неопределено, Колонки, Знач КолонкиПоЗначению=Неопределено, Знач НовыеИменаКолонок=Неопределено) Экспорт
	
	// Определение значений по умолчанию
	Если КолонкиПоЗначению = Неопределено Тогда
		КолонкиПоЗначению = Новый Структура;
	КонецЕсли;
	Если НовыеИменаКолонок = Неопределено Тогда
		НовыеИменаКолонок = Новый Структура;
	КонецЕсли;
	
	// Определить список выгружаемых колонок
	СтруктураДругихИменКолонок = Новый Структура;
	Для Каждого НовоеИмя Из НовыеИменаКолонок Цикл
		СтруктураДругихИменКолонок.Вставить(НовоеИмя.Значение, НовоеИмя.Ключ);
	КонецЦикла;
	ИменаКолонок = "";
	ИмяКолонки = "";
	СтруктураКолонок = Новый Структура(Колонки);
	Для Каждого Колонка Из СтруктураКолонок Цикл
		Если Не СтруктураДругихИменКолонок.Свойство(Колонка.Ключ, ИмяКолонки) Тогда
			ИмяКолонки = Колонка.Ключ;
		КонецЕсли;
		Если Не КолонкиПоЗначению.Свойство(ИмяКолонки) Тогда
			ИменаКолонок = ИменаКолонок + ", " + ИмяКолонки;
		КонецЕсли;
	КонецЦикла;
	
	// Выгрузить из таблицы источника
	ТаблицаРезультата = ТаблицаИсточник.Выгрузить(Строки, Сред(ИменаКолонок, 3));
	
	// Добавить новые колонки в таблицу результата
	Если КолонкиПоЗначению <> Неопределено Тогда
		Для Каждого Колонка Из КолонкиПоЗначению Цикл
			МассивТипов = Новый Массив;
			МассивТипов.Добавить(ТипЗнч(Колонка.Значение));
			ТаблицаРезультата.Колонки.Добавить(Колонка.Ключ, Новый ОписаниеТипов(МассивТипов));
			ТаблицаРезультата.ЗаполнитьЗначения(Колонка.Значение, Колонка.Ключ);
		КонецЦикла;
	КонецЕсли;
	
	// Переименовать колонки в таблице результата
	Если НовыеИменаКолонок <> Неопределено Тогда
		Для Каждого Колонка Из НовыеИменаКолонок Цикл
			ТаблицаРезультата.Колонки[Колонка.Ключ].Имя = Колонка.Значение;
		КонецЦикла;
	КонецЕсли;
	
	Возврат ТаблицаРезультата;
	
КонецФункции // ВыгрузитьТаблицуЗначений()

// Процедура делает запись в журнал регистрации и сообщает пользователю, если это сообщение об ошибке. 
// Параметры:
//   ПараметрыЖурнала - Структура - параметры записи в журнал регистрации.
//			Свойства:
//       		ГруппаСобытий - Строка - префикс для имени события журнала регистрации.
//       		Метаданные - ОбъектМетаданных - метаданные для записи в журнал регистрации.
//       		Данные - Произвольный - данные для записи в журнал регистрации.
//   ИмяСобытия - Строка  - имя события (в журнал событие записывается в формате ГруппаСобытий.ИмяСобытия).
//   УровеньЖурнала - УровеньЖурналаРегистрации  - Соответствует уровням журнала регистрации.
//   Комментарий - Строка - комментарий о событии.
//   ИнформацияОбОшибке - ИнформацияОбОшибке, Строка - Информация об ошибке,
//		которую так же необходимо задокументировать в комментарии журнала регистрации.
//
Процедура ЗаписатьВЖурналСообщитьПользователю(ПараметрыЖурнала, УровеньЖурнала, ИмяСобытия, Знач Комментарий = "", ИнформацияОбОшибке = Неопределено) Экспорт
	
	Если ТипЗнч(ИнформацияОбОшибке) = Тип("ИнформацияОбОшибке") Тогда
		Если Комментарий = "" Тогда
			ТестСообщенияПользователю = КраткоеПредставлениеОшибки(ИнформацияОбОшибке);
			Комментарий = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке);
		Иначе
			ТестСообщенияПользователю = Комментарий + Символы.ПС + КраткоеПредставлениеОшибки(ИнформацияОбОшибке);
			Комментарий = Комментарий + Символы.ПС + ПодробноеПредставлениеОшибки(ИнформацияОбОшибке);
		КонецЕсли;
	Иначе
		Если ТипЗнч(ИнформацияОбОшибке) = Тип("Строка") 
			И Не ПустаяСтрока(ИнформацияОбОшибке) Тогда
			Комментарий = Комментарий + Символы.ПС + ИнформацияОбОшибке;
		КонецЕсли;
		ТестСообщенияПользователю = Комментарий;
	КонецЕсли;
	
	// Журнал регистрации 
	УстановитьПривилегированныйРежим(Истина);
	ЗаписьЖурналаРегистрации(
		ПараметрыЖурнала.ГруппаСобытий + ?(ИмяСобытия = "", "", ". "+ ИмяСобытия), 
		УровеньЖурнала, 
		ПараметрыЖурнала.Метаданные, 
		ПараметрыЖурнала.Данные, 
		Комментарий);
	УстановитьПривилегированныйРежим(Ложь);
	
	Если УровеньЖурнала = УровеньЖурналаРегистрации.Ошибка 
		Или УровеньЖурнала = УровеньЖурналаРегистрации.Предупреждение Тогда
		
		ОбщегоНазначенияКлиентСервер.СообщитьПользователю(СокрЛП(ТестСообщенияПользователю),ПараметрыЖурнала.Данные);
	КонецЕсли;
	
КонецПроцедуры

// Возвращает ключ данных для подстановки в сообщение пользователю
// Ключ данных нужен при групповой обработке объектов - если он установлен, то при нажатии пользователем на сообщение
// будет открываться форма объекта.
//
//	Параметры:
//		Объект - Произвольный - объект, для которого нужно получить ключ данных.
//	
//	Возвращаемое значение:
//		Ссылка - ссылка на объект информационной базы.
//
Функция КлючДанныхДляСообщенияПользователю(Объект) Экспорт
	
	КлючДанных = Неопределено;
	XMLТипЗнч = XMLТипЗнч(Объект); 
	
	Если XMLТипЗнч <> Неопределено Тогда
		ТипЗначенияСтрокой = XMLТипЗнч.ИмяТипа;
		Если Найти(ТипЗначенияСтрокой, "Object.") > 0 Тогда
			КлючДанных = Объект.Ссылка;
		КонецЕсли;
	КонецЕсли;
	
	Возврат КлючДанных;
	
КонецФункции

#КонецОбласти

#Область ПроцедурыИФункцииДляПолученияПредставленияДанных

// Возвращает строковое представление документа для отображения в сообщениях
// Параметры:
// 	Ссылка - ДокументСсылка - ссылка на документ
// 	Номер - Строка - номер документа
// 	Дата - Дата - дата документа.
// Возвращаемое значение:
//		Строка - представление документа.
Функция ПолучитьПредставлениеДокумента(Ссылка, Номер, Дата) Экспорт
	
	Возврат Ссылка.Метаданные().Синоним + " " + Номер + " от " + Формат(Дата,"ДЛФ=D");
	
КонецФункции // ПолучитьПредставлениеДокумента()

#КонецОбласти

#Область ПрочиеПроцедурыИФункции

// Возвращает метаданные объекта по полному имени объекта метаданных.
//
// Не обрабатываются точки маршрутов бизнес-процессов.
//
// Параметры:
//  ПолноеИмя - Строка - полное имя объекта метаданных, например, "Справочник.Организации".
//
// Возвращаемое значение:
//  КоллекцияОбъектовМетаданных - метаданные объекта.
// 
Функция МетаданныеОбъектаПоПолномуИмени(ПолноеИмя) Экспорт
	
	ЧастиИмени = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(ПолноеИмя, ".");
	
	КлассОМ = ЧастиИмени[0];
	ИмяОМ   = ЧастиИмени[1];
	
	Если      ВРег(КлассОМ) = "ПЛАНОБМЕНА" Тогда
		Возврат Метаданные.ПланыОбмена[ИмяОМ];
		
	ИначеЕсли ВРег(КлассОМ) = "СПРАВОЧНИК" Тогда
		Возврат Метаданные.Справочники[ИмяОМ];
		
	ИначеЕсли ВРег(КлассОМ) = "ДОКУМЕНТ" Тогда
		Возврат Метаданные.Документы[ИмяОМ];
		
	ИначеЕсли ВРег(КлассОМ) = "ЖУРНАЛДОКУМЕНТОВ" Тогда
		Возврат Метаданные.ЖурналыДокументов[ИмяОМ];
		
	ИначеЕсли ВРег(КлассОМ) = "ПЕРЕЧИСЛЕНИЕ" Тогда
		Возврат Метаданные.Перечисления[ИмяОМ];
		
	ИначеЕсли ВРег(КлассОМ) = "ОТЧЕТ" Тогда
		Возврат Метаданные.Отчеты[ИмяОМ];
		
	ИначеЕсли ВРег(КлассОМ) = "ОБРАБОТКА" Тогда
		Возврат Метаданные.Обработки[ИмяОМ];
		
	ИначеЕсли ВРег(КлассОМ) = "ПЛАНВИДОВХАРАКТЕРИСТИК" Тогда
		Возврат Метаданные.ПланыВидовХарактеристик[ИмяОМ];
		
	ИначеЕсли ВРег(КлассОМ) = "ПЛАНСЧЕТОВ" Тогда
		Возврат Метаданные.ПланыСчетов[ИмяОМ];
		
	ИначеЕсли ВРег(КлассОМ) = "ПЛАНВИДОВРАСЧЕТА" Тогда
		Возврат Метаданные.ПланЫВидовРасчета[ИмяОМ];
		
	ИначеЕсли ВРег(КлассОМ) = "РЕГИСТРСВЕДЕНИЙ" Тогда
		Возврат Метаданные.РегистрыСведений[ИмяОМ];
		
	ИначеЕсли ВРег(КлассОМ) = "РЕГИСТРНАКОПЛЕНИЯ" Тогда
		Возврат Метаданные.РегистрыНакопления[ИмяОМ];
		
	ИначеЕсли ВРег(КлассОМ) = "РЕГИСТРБУХГАЛТЕРИИ" Тогда
		Возврат Метаданные.РегистрыБухгалтерии[ИмяОМ];
		
	ИначеЕсли ВРег(КлассОМ) = "РЕГИСТРРАСЧЕТА" Тогда
		Возврат Метаданные.РегистрыРасчета[ИмяОМ];
		
	ИначеЕсли ВРег(КлассОМ) = "БИЗНЕСПРОЦЕСС" Тогда
		Возврат Метаданные.БизнесПроцессы[ИмяОМ];
		
	ИначеЕсли ВРег(КлассОМ) = "ЗАДАЧА" Тогда
		Возврат Метаданные.Задачи[ИмяОМ];
		
	ИначеЕсли ВРег(КлассОМ) = "КОНСТАНТА" Тогда
		Возврат Метаданные.Константы[ИмяОМ];
		
	ИначеЕсли ВРег(КлассОМ) = "ПОСЛЕДОВАТЕЛЬНОСТЬ" Тогда
		Возврат Метаданные.Последовательности[ИмяОМ];
		
	Иначе
		ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru='Неизвестный тип объекта метаданных (%1)'"), КлассОМ);
	КонецЕсли;
	
КонецФункции

// Процедура устанавливает блокировку документа для редактирования.
//
// Параметры:
//		ДокументСсылка - ДокументСсылка - документ, на который устанавливается блокировка.
//		ОтменятьТранзакцию - Булево - Признак необходимости отмены транзакции.
//
Процедура ЗаблокироватьДокументДляРедактирования(ДокументСсылка, ОтменятьТранзакцию = Ложь) Экспорт
	
	Попытка
		ЗаблокироватьДанныеДляРедактирования(ДокументСсылка);
	Исключение
		ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru='Не удалось заблокировать %1. %2'"),
			ДокументСсылка,
			КраткоеПредставлениеОшибки(ИнформацияОбОшибке()));
		Если ОтменятьТранзакцию Тогда
			ОтменитьТранзакцию();
		КонецЕсли;
		ВызватьИсключение ТекстОшибки;
	КонецПопытки;
	
КонецПроцедуры // ЗаблокироватьДокументДляРедактирования()

// Осуществляет проверку заполненности проверяемых реквизитов.
//
// Параметры:
// 		Объект                      - ДокументОбъект, СправочникОбъект - Проверяемый объект.
// 		МассивПроверяемыхРеквизитов - Массив - массив проверяемых реквизитов.
//
// Возвращаемое значение:
// 		Булево - Истина, если значение хотя бы одного реквизита не заполнено, иначе Ложь.
//
Функция ПроверитьЗаполнениеРеквизитовОбъекта(Объект, МассивПроверяемыхРеквизитов) Экспорт
	
	Перем ПроверяемыеРеквизитыТЧ;
	Отказ = Ложь;
	
	// Получение метаданных объекта
	МетаданныеОбъекта = Объект.Ссылка.Метаданные();
	
	// Создание структуры стандартных реквизитов
	СтандартныеРеквизиты = Новый Структура;
	Для Каждого Реквизит Из МетаданныеОбъекта.СтандартныеРеквизиты Цикл
		СтандартныеРеквизиты.Вставить(Реквизит.Имя, ?(ЗначениеЗаполнено(Реквизит.Синоним), Реквизит.Синоним, Реквизит.Имя));
	КонецЦикла;
	
	// Создание структуры для хранения имен табличных частей и проверяемых реквизитов в них.
	// 		Ключ -  Имя табличной части
	// 		Значение - Массив - Массив строк, реквизитов этой табличной части для проверки.
	ТабличныеЧасти = Новый Структура;
	
	// Создание шаблонов сообщений об ошибках не заполненных реквизитов и реквизитов табличных частей.
	ШаблонОшибкиРеквизита = НСтр("ru='Поле ""%ИмяРеквизита%"" не заполнено'");
	ШаблонОшибкиТЧ = НСтр("ru='Не введено ни одной строки в список ""%ИмяРеквизита%""'");
	ШаблонОшибкиРеквизитаТЧ = НСтр("ru='Не заполнена колонка ""%ИмяРеквизита%"" в строке %НомерСтроки% списка ""%ИмяТабличнойЧасти%""'");
	
	// Проверка реквизитов объекта и заполнение структуры по реквизитам табличных частей.
	Для Каждого Реквизит Из МассивПроверяемыхРеквизитов Цикл
		
		ПозицияТочки = Найти(Реквизит,".");
		
		Если ПозицияТочки > 0 Тогда // В случае если указан реквизит табличной части
			
			ДлинаСтроки       = СтрДлина(Реквизит);
			ИмяТабличнойЧасти = Лев(Реквизит, ПозицияТочки-1);
			ИмяРеквизита      = Прав(Реквизит, ДлинаСтроки - ПозицияТочки);
			
			// Сохранение проверяемого реквизита табличной части в структуру
			Если НЕ ТабличныеЧасти.Свойство(ИмяТабличнойЧасти, ПроверяемыеРеквизитыТЧ) Тогда
				ПроверяемыеРеквизитыТЧ = Новый Массив;
				ТабличныеЧасти.Вставить(ИмяТабличнойЧасти, ПроверяемыеРеквизитыТЧ);
			КонецЕсли;
			ПроверяемыеРеквизитыТЧ.Добавить(ИмяРеквизита);
			
		Иначе // В случае если указан реквизит объекта
			
			Если Не ЗначениеЗаполнено(Объект[Реквизит]) Тогда
				
				Если МетаданныеОбъекта.Реквизиты.Найти(Реквизит) <> Неопределено Тогда // Если указано имя реквизита
					ТекстОшибки = СтрЗаменить(ШаблонОшибкиРеквизита, "%ИмяРеквизита%",
						МетаданныеОбъекта.Реквизиты[Реквизит].Синоним);
				ИначеЕсли СтандартныеРеквизиты.Свойство(Реквизит) Тогда // Если указано имя стандартного реквизита
					ТекстОшибки = СтрЗаменить(ШаблонОшибкиРеквизита, "%ИмяРеквизита%",
						СтандартныеРеквизиты[Реквизит]);
				Иначе // Если указано имя табличной части
					ТекстОшибки = СтрЗаменить(ШаблонОшибкиТЧ, "%ИмяРеквизита%",
						МетаданныеОбъекта.ТабличныеЧасти[Реквизит].Синоним);
				КонецЕсли;
				
				ОбщегоНазначенияКлиентСервер.СообщитьПользователю(
					ТекстОшибки,
					Объект,
					Реквизит,
					,
					Отказ);
				
			КонецЕсли;
			
		КонецЕсли;
		
	КонецЦикла;
	
	// Проверка реквизитов в табличных частях
	Для Каждого ТабличнаяЧасть Из ТабличныеЧасти Цикл
		
		ИмяТабличнойЧасти = ТабличнаяЧасть.Ключ;
		ТабличнаяЧастьОбъекта = Объект[ТабличнаяЧасть.Ключ];
		МассивРеквизитов = ТабличнаяЧасть.Значение;
		
		// Цикл по всем строкам табличной части.
		Для НомерСтроки=0 По ТабличнаяЧастьОбъекта.Количество()-1 Цикл
			
			// Цикл по всем проверяемым реквизитам для текущей табличной части.
			Для НомерРеквизита=0 По МассивРеквизитов.Количество()-1 Цикл
				
				ИмяРеквизита = МассивРеквизитов[НомерРеквизита];
				
				Если Не ЗначениеЗаполнено(ТабличнаяЧастьОбъекта[НомерСтроки][ИмяРеквизита]) Тогда
					
					ТекстОшибки = СтрЗаменить(ШаблонОшибкиРеквизитаТЧ, "%ИмяРеквизита%", МетаданныеОбъекта.ТабличныеЧасти[ИмяТабличнойЧасти].Реквизиты[ИмяРеквизита].Синоним);
					ТекстОшибки = СтрЗаменить(ТекстОшибки, "%НомерСтроки%", Формат(НомерСтроки+1, "ЧГ=0"));
					ТекстОшибки = СтрЗаменить(ТекстОшибки, "%ИмяТабличнойЧасти%", МетаданныеОбъекта.ТабличныеЧасти[ИмяТабличнойЧасти].Синоним);
					
					ОбщегоНазначенияКлиентСервер.СообщитьПользователю(
						ТекстОшибки,
						Объект,
						ОбщегоНазначенияКлиентСервер.ПутьКТабличнойЧасти(ИмяТабличнойЧасти, НомерСтроки+1, ИмяРеквизита),
						,
						Отказ);
					
				КонецЕсли;
				
			КонецЦикла;
			
		КонецЦикла;
		
	КонецЦикла;
	
	МассивПроверяемыхРеквизитов.Очистить();
	
	Возврат Отказ;
	
КонецФункции // ПроверитьЗаполнениеРеквизитовОбъекта()

// Осуществляет проверку заполненности проверяемых реквизитов.
//
// Параметры:
// 	Документ                            - ДокументСсылка - Документ, на основании которого осуществляется ввод
// 	ЕстьОшибкиПроведен                  - Булево - Если Истина - документ, на основании которого
//																осуществляется ввод, не проведен
// 	ЕстьОшибкиВернутьМногооборотнуюТару - Булево - Если Истина - по документу, на основании которого
//															осуществляется ввод, тара не возвратная.
//
Процедура ПроверитьВозможностьВводаНаОснованииВыкупаТары(Документ, ЕстьОшибкиПроведен, ЕстьОшибкиВернутьМногооборотнуюТару) Экспорт
	
	Если ЕстьОшибкиПроведен Тогда
		
		ТекстОшибки = НСтр("ru='Документ %Документ% не проведен. Ввод на основании непроведенного документа запрещен.'");
		ТекстОшибки = СтрЗаменить(ТекстОшибки, "%Документ%", Документ);
	
		ВызватьИсключение ТекстОшибки;
		
	ИначеЕсли ЕстьОшибкиВернутьМногооборотнуюТару Тогда
		
		ТекстОшибки = НСтр("ru='В документе %Документ% не стоит признак возврата многооборотной тары. Ввод на основании запрещен.'");
		ТекстОшибки = СтрЗаменить(ТекстОшибки, "%Документ%", Документ);
	
		ВызватьИсключение ТекстОшибки;
		
	КонецЕсли;
	
КонецПроцедуры

// Осуществляет проверку заполненности проверяемых реквизитов.
//
// Параметры:
// 	ЕстьОшибкиТиповое  - Булево - Если Истина - соглашение, на основании которого осуществляется ввод - типовое.
//
Процедура ПроверитьВозможностьВводаНаОснованииСоглашения(ЕстьОшибкиТиповое) Экспорт
	
	Если ЕстьОшибкиТиповое Тогда
		
		ТекстОшибки = НСтр("ru='Ввод на основании типового соглашения с клиентом запрещен.'");
	
		ВызватьИсключение ТекстОшибки;
		
	КонецЕсли;
	
КонецПроцедуры // ПроверитьВозможностьВводаНаОснованииСоглашения()

// Осуществляет проверку заполненности проверяемых реквизитов.
//
// Параметры:
// 	Партнер - СправочникСсылка.Партнеры - Партнер из сделки по продаже.
//
Процедура ПроверитьВозможностьВводаНаОснованииСделкиПоПродаже(Партнер) Экспорт
	
	Если Не ЗначениеЗаполнено(Партнер) Тогда
		
		ТекстОшибки = НСтр("ru='В сделке не указан партнер, ввод на основании запрещен.'");
	
		ВызватьИсключение ТекстОшибки;
		
	КонецЕсли;
	
КонецПроцедуры // ПроверитьВозможностьВводаНаОснованииСделкиПоПродаже()

// Устанавливает или сбрасывает флаг Согласован у справочника.
// Вызывается из процедуры ПередЗаписью документа.
//
// Параметры:
// 	СправочникОбъект   - СправочникОбъект - Справочник, в котором необходимо изменить флаг Согласован
// 	СтатусНеСогласован - Статус - Статус документа, в котором флаг Согласован должен быть сброшен.
//
Процедура ИзменитьПризнакСогласованностиСправочника(СправочникОбъект, Знач СтатусНеСогласован = Неопределено) Экспорт
	
	// Справочник не имеет статуса
	Если СтатусНеСогласован = Неопределено Тогда
		
		Если Не СправочникОбъект.Согласован Тогда
			СправочникОбъект.Согласован = Истина;
		КонецЕсли;
		
	// Справочник имеет статус, в котором проведенный справочник не согласован
	Иначе
		
		Если СправочникОбъект.Статус = СтатусНеСогласован И СправочникОбъект.Согласован Тогда
			СправочникОбъект.Согласован = Ложь;
		ИначеЕсли СправочникОбъект.Статус <> СтатусНеСогласован И Не СправочникОбъект.Согласован Тогда
			СправочникОбъект.Согласован = Истина;
		КонецЕсли;
		
	КонецЕсли;
	
КонецПроцедуры // ИзменитьПризнакСогласованностиСправочника()

// Устанавливает или сбрасывает флаг Согласован у документа.
// Вызывается из процедуры ПередЗаписью документа.
//
// Параметры:
// 	ДокументОбъект     - ДокументОбъект - Документ, в котором необходимо изменить флаг Согласован
// 	РежимЗаписи        - РежимЗаписиДокумента - Режим записи документа.
// 	СтатусНеСогласован - Статус - Статус документа, в котором флаг Согласован должен быть сброшен.
//
Процедура ИзменитьПризнакСогласованностиДокумента(ДокументОбъект, Знач РежимЗаписи, Знач СтатусНеСогласован = Неопределено) Экспорт
	
	Если РежимЗаписи = РежимЗаписиДокумента.Запись Или
		 РежимЗаписи = РежимЗаписиДокумента.ОтменаПроведения Тогда
		
		Если ДокументОбъект.Согласован Тогда
			ДокументОбъект.Согласован = Ложь;
		КонецЕсли;
		
	ИначеЕсли РежимЗаписи = РежимЗаписиДокумента.Проведение Тогда
		
		// Документ не имеет статуса
		Если СтатусНеСогласован = Неопределено Тогда
		
			Если Не ДокументОбъект.Согласован Тогда
				ДокументОбъект.Согласован = Истина;
			КонецЕсли;
			
		// Документ имеет статус из массива, в которых проведенный документ не согласован
		ИначеЕсли ТипЗнч(СтатусНеСогласован) = Тип("Массив") Тогда
			
			Если ДокументОбъект.Согласован Тогда
				
				Для Каждого ТекСтатус Из СтатусНеСогласован Цикл
					
					Если ДокументОбъект.Статус = ТекСтатус Тогда
						
						ДокументОбъект.Согласован = Ложь;
						Прервать;
						
					КонецЕсли;
					
				КонецЦикла;
				
			Иначе
				
				ДокументСогласован = Истина;
				
				Для Каждого ТекСтатус Из СтатусНеСогласован Цикл
					
					Если ДокументОбъект.Статус = ТекСтатус Тогда
						ДокументСогласован = Ложь;
					КонецЕсли;
					
				КонецЦикла;
				
				Если ДокументСогласован Тогда
					ДокументОбъект.Согласован = Истина;
				КонецЕсли;
				
			КонецЕсли;
			
		// Документ имеет статус, в котором проведенный документ не согласован
		Иначе
			
			Если ДокументОбъект.Статус = СтатусНеСогласован И ДокументОбъект.Согласован Тогда
				ДокументОбъект.Согласован = Ложь;
			ИначеЕсли ДокументОбъект.Статус <> СтатусНеСогласован И Не ДокументОбъект.Согласован Тогда
				ДокументОбъект.Согласован = Истина;
			КонецЕсли;
			
		КонецЕсли;

	КонецЕсли;
	
КонецПроцедуры // ИзменитьПризнакСогласованностиДокумента()


// Функция возвращает список разрешенных для чтения пользователей, принадлежащих ролям указанным в качестве параметра.
//
// Параметры:
//			МассивРолей - Массив - Массив со строковыми именами ролей.
//			ПредставлениеТекущегоПользователя - Строка - представление пользователя.
//
// Возвращаемое значение:
//		СписокЗначений - список пользователей.
Функция ПолучитьСписокПользователейПоМассивуРолей(МассивРолей, ПредставлениеТекущегоПользователя = Неопределено) Экспорт
	
	СписокПользователей = Новый СписокЗначений;
	Если ПредставлениеТекущегоПользователя = Неопределено Тогда
		ПредставлениеТекущегоПользователя = НСтр("ru='<Мои документы>'");
	КонецЕсли;
	
	// Запрос получения списка всех пользователей. Выполняется в привилегированном режиме.
	УстановитьПривилегированныйРежим(Истина);
	
	Запрос = Новый Запрос;
	Запрос.Текст =
	"ВЫБРАТЬ
	|	ПрофилиГруппДоступаРоли.Ссылка КАК Ссылка
	|ПОМЕСТИТЬ ПрофилиГруппДоступа
	|ИЗ
	|	Справочник.ПрофилиГруппДоступа.Роли КАК ПрофилиГруппДоступаРоли
	|ГДЕ
	|	ПрофилиГруппДоступаРоли.Роль.Имя В(&МассивРолей)
	|
	|СГРУППИРОВАТЬ ПО
	|	ПрофилиГруппДоступаРоли.Ссылка
	|
	|ИНДЕКСИРОВАТЬ ПО
	|	Ссылка
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	ЕСТЬNULL(ГруппыПользователейСостав.Пользователь, ГруппыДоступаПользователи.Пользователь) КАК Пользователь
	|ИЗ
	|	Справочник.ГруппыДоступа.Пользователи КАК ГруппыДоступаПользователи
	|		ЛЕВОЕ СОЕДИНЕНИЕ Справочник.ГруппыПользователей.Состав КАК ГруппыПользователейСостав
	|		ПО ГруппыДоступаПользователи.Пользователь = ГруппыПользователейСостав.Ссылка
	|ГДЕ
	|	ГруппыДоступаПользователи.Ссылка.Профиль В
	|			(ВЫБРАТЬ
	|				ПрофилиГруппДоступа.Ссылка
	|			ИЗ
	|				ПрофилиГруппДоступа КАК ПрофилиГруппДоступа)
	|
	|СГРУППИРОВАТЬ ПО
	|	ЕСТЬNULL(ГруппыПользователейСостав.Пользователь, ГруппыДоступаПользователи.Пользователь)";
	
	Запрос.УстановитьПараметр("МассивРолей", МассивРолей);
	
	МассивВсехПользователей = Запрос.Выполнить().Выгрузить().ВыгрузитьКолонку("Пользователь");
	
	УстановитьПривилегированныйРежим(Ложь);
	
	// Запрос получения списка "разрешенных" пользователей
	Запрос.Текст =
	"ВЫБРАТЬ РАЗРЕШЕННЫЕ
	|	Пользователи.Ссылка КАК Пользователь
	|ИЗ
	|	Справочник.Пользователи КАК Пользователи
	|ГДЕ
	|	Пользователи.Ссылка В(&МассивПользователей)
	|	И Пользователи.ПометкаУдаления = ЛОЖЬ
	|	И Пользователи.Недействителен = ЛОЖЬ
	|
	|УПОРЯДОЧИТЬ ПО
	|	Пользователи.Наименование";
	Запрос.УстановитьПараметр("МассивПользователей", МассивВсехПользователей);
	
	ТекущийПользователь = Пользователи.ТекущийПользователь();
	
	Выборка = Запрос.Выполнить().Выбрать();
	Пока Выборка.Следующий() Цикл
		Если ТекущийПользователь = Выборка.Пользователь Тогда
			СписокПользователей.Вставить(0, Выборка.Пользователь, ПредставлениеТекущегоПользователя);
		Иначе
			СписокПользователей.Добавить(Выборка.Пользователь);
		КонецЕсли;
	КонецЦикла;
	
	Возврат СписокПользователей;
	
КонецФункции // ПолучитьСписокПользователейПоМассивуРолей()

// Функция сворачивает копию переданной таблицы значений по реквизиту.
// Параметры:
//	 ТаблицаРеквизитыДокументов - ТаблицаЗначений - переданная таблица,
//	 ИмяРеквизита - Строка - реквизит по которому таблица будет свернута.
//
// Возвращаемое значение: 
//		ТаблицаЗначений - Таблица свернутая по реквизиту.
Функция СвернутьТаблицуЗначенийПоРеквизиту(ТаблицаРеквизитыДокументов, ИмяРеквизита) Экспорт
	
	Таблица = ТаблицаРеквизитыДокументов.Скопировать();
	Таблица.Свернуть(ИмяРеквизита);
	Возврат Таблица;
	
КонецФункции // СвернутьТаблицуЗначенийПоРеквизиту()

// Фукнция раскладывает переданный массив сслылок в соотвествие по типам этих ссылок.
//
//	Параметры:
//		МассивСсылок - Массив - массив ссылок на объекты информационной базы.
//  Возвращаемое значение:
//		Соотвествие -	Ключ - полное имя типа ссылки.
//	        				Значение - массив ссылок этого типа.
//
Функция СоответствиеМассивовПоТипамОбъектов(МассивСсылок) Экспорт
	
	СоответствиеТипов = Новый Соответствие;
	
	Для Каждого Объект Из МассивСсылок Цикл
		
		ТипОбъекта = Объект.Метаданные().ПолноеИмя();
		ТекущийТипОбъекта = СоответствиеТипов.Получить(ТипОбъекта);
		
		Если ТекущийТипОбъекта = Неопределено Тогда
			СоответствиеТипов.Вставить(ТипОбъекта, Новый Массив);
			ТекущийТипОбъекта = СоответствиеТипов.Получить(ТипОбъекта);
		КонецЕсли;
		ТекущийТипОбъекта.Добавить(Объект);
		
	КонецЦикла;
	
	Возврат СоответствиеТипов;
	
КонецФункции

// Возвращает разницу между двумя датами (в днях)
//
// Параметры:
//  ДатаНачала 	- Дата - начальная дата периода
//  ДатаОкончания	- Дата - конечная дата периода.
//  Периодичность	- ПеречислениеСсылка.Периодичность - периодичность.
//
// Возвращаемое значение:
//   Число	 - количество дней между двумя датами.
//
Функция РазностьДат(ДатаНачала, ДатаОкончания, Периодичность) Экспорт
	
	СекундВМинуте = 60;
	МинутВЧасе = 60;
	ЧасовВДне = 24;
	
	Если Периодичность = Перечисления.Периодичность.Год Тогда
		Возврат Год(ДатаОкончания) - Год(ДатаНачала);
		
	ИначеЕсли Периодичность = Перечисления.Периодичность.Полугодие Тогда
		Возврат ?(Месяц(ДатаОкончания)>6, 2, 1) - ?(Месяц(ДатаНачала)>6, 2, 1) + 2*(Год(ДатаОкончания) - Год(ДатаНачала));
		
	ИначеЕсли Периодичность = Перечисления.Периодичность.Квартал Тогда
		Возврат Цел(Месяц(НачалоКвартала(ДатаОкончания))/3) - Цел(Месяц(НачалоКвартала(ДатаНачала))/3) + 4*(Год(ДатаОкончания) - Год(ДатаНачала));
		
	ИначеЕсли Периодичность = Перечисления.Периодичность.Месяц Тогда
		Возврат Месяц(ДатаОкончания) - Месяц(ДатаНачала) + 12*(Год(ДатаОкончания) - Год(ДатаНачала));
		
	ИначеЕсли Периодичность = Перечисления.Периодичность.Декада Тогда
		Возврат Цел((ДатаОкончания - ДатаНачала)/(10 * СекундВМинуте*МинутВЧасе*ЧасовВДне));
		
	ИначеЕсли Периодичность = Перечисления.Периодичность.Неделя Тогда
		Возврат Цел((НачалоНедели(ДатаОкончания) - НачалоНедели(ДатаНачала))/(7 * СекундВМинуте*МинутВЧасе*ЧасовВДне));
		
	ИначеЕсли Периодичность = Перечисления.Периодичность.День Тогда
		Возврат (ДатаОкончания - ДатаНачала)/(СекундВМинуте*МинутВЧасе*ЧасовВДне);
		
	КонецЕсли;
	
КонецФункции

// Проверяет использование объекта
//
// Параметры:
//  Параметры		- Структура - содержит объект использование которого нужно проверить
//  АдресХранилища	- Строка - адрес хранилища в которое будут помещен результат проверки.
//
Процедура ПроверитьИспользованиеОбъекта(Параметры, АдресХранилища) Экспорт
	
	ЕстьСсылки = ОбщегоНазначенияВызовСервера.ЕстьСсылкиНаОбъект(Параметры.Объект);
	
	ПоместитьВоВременноеХранилище(ЕстьСсылки, АдресХранилища);
	
КонецПроцедуры

#КонецОбласти

#Область ПроцедурыИФункцииУстановкиСтатусовДляМассиваДокументов

// Устанавливает статус для списка документов
//
// ВАЖНО. При использования процедуры для каждого типа документа из массива должны быть объявлены функции:
// В модуле менеджера документа:
// 		Функция СформироватьЗапросПроверкиПриСменеСтатуса(МассивДокументов, НовыйСтатус, ДополнительныеПараметры) Экспорт
// 		Функция ПроверкаПередСменойСтатуса(ВыборкаПроверки, НовыйСтатус, ДополнительныеПараметры) Экспорт
// В модуле объекта документа:
// 		Функция УстановитьСтатус(НовыйСтатус, ДополнительныеПараметры) Экспорт.
//
// Параметры:
// 		МассивДокументов - Массив - Массив документов
// 		ДополнительныеПараметры - Структура - Структура дополнительных параметров.
//
// Возвращаемое значение:
// 		Число - Количество документов у которых был изменен статус.
//
Функция РассчитатьСтатусыДокументовАвтоматически(Знач МассивДокументов, Знач ДополнительныеПараметры=Неопределено) Экспорт
	
	Перем РезультатыПроверки;
	
	// Получение шаблонов сообщений стандартных ошибок
	ШаблонОшибкиСтатусСовпадает   = НСтр("ru='Документу %Документ% уже присвоен статус ""%Статус%""'");
	ШаблонОшибкиНеПроведен        = НСтр("ru='Документ %Документ% не проведен. Невозможно изменить статус'");
	ШаблонОшибкиПомеченНаУдаление = НСтр("ru='Документ %Документ% помечен на удаление. Невозможно изменить статус'");
	ШаблонОшибкиЗаблокировать     = НСтр("ru='Не удалось заблокировать %Документ%. %ОписаниеОшибки%'");
	ШаблонОшибкиЗаписать          = НСтр("ru='Не удалось записать %Документ%. %ОписаниеОшибки%'");
	
	// Получение соответствие типов документов из массива документов разных типов
	СоответствиеТипов = РазложитьМассивСсылокПоТипам(МассивДокументов);
	
	КоличествоОбработанных = 0;
	Для Каждого СоставДокументов Из СоответствиеТипов Цикл
		
		// Получение менеджера документов данного типа
		МенеджерДокументов = Документы[Метаданные.НайтиПоТипу(СоставДокументов.Ключ).Имя];
		
		// Получение массива ссылок документов данного типа
		МассивСсылок = СоставДокументов.Значение;
		
		// Формирование запроса
		Запрос = МенеджерДокументов.СформироватьЗапросПроверкиПриАвтоматическомРасчетеСтатуса(МассивСсылок, ДополнительныеПараметры);
		Результат = Запрос.Выполнить();
		Если Результат.Пустой() Тогда
			Возврат 0;
		КонецЕсли;
		
		// Цикл обхода выборки
		Выборка = Результат.Выбрать();
		Пока Выборка.Следующий() Цикл
			
			// Универсальные проверки
			Если Выборка.ПометкаУдаления Тогда
				ОбщегоНазначенияКлиентСервер.СообщитьПользователю(СтрЗаменить(ШаблонОшибкиПомеченНаУдаление, "%Документ%", Выборка.Представление), Выборка.Ссылка);
				Продолжить;
			КонецЕсли;

			Если Не Выборка.Проведен Тогда
				ОбщегоНазначенияКлиентСервер.СообщитьПользователю(СтрЗаменить(ШаблонОшибкиНеПроведен, "%Документ%", Выборка.Представление), Выборка.Ссылка);
				Продолжить;
			КонецЕсли;
			
			// Захват объекта для редактирования
			Попытка
				ЗаблокироватьДанныеДляРедактирования(Выборка.Ссылка);
			Исключение
				ТекстОшибки = СтрЗаменить(ШаблонОшибкиЗаблокировать, "%Документ%", Выборка.Представление);
				ТекстОшибки = СтрЗаменить(ТекстОшибки, "%ОписаниеОшибки%", КраткоеПредставлениеОшибки(ИнформацияОбОшибке()));
				ОбщегоНазначенияКлиентСервер.СообщитьПользователю(ТекстОшибки, Выборка.Ссылка);
				Продолжить;
			КонецПопытки;
			
			// Получение объекта документа
			Объект = Выборка.Ссылка.ПолучитьОбъект();
			
			// Авторасчет статуса
			
			Если НЕ МенеджерДокументов.РассчитатьСтатусДокументаСервер(Объект, КоличествоОбработанных) Тогда
				Продолжить;
			КонецЕсли; 
			
			// Запись документа
			Попытка
				Объект.Записать(?(Выборка.ЗаписьПроведением, РежимЗаписиДокумента.Проведение, РежимЗаписиДокумента.Запись));
			Исключение
				ТекстОшибки = СтрЗаменить(ШаблонОшибкиЗаписать, "%Документ%", Выборка.Представление);
				ТекстОшибки = СтрЗаменить(ТекстОшибки, "%ОписаниеОшибки%", КраткоеПредставлениеОшибки(ИнформацияОбОшибке()));
				ОбщегоНазначенияКлиентСервер.СообщитьПользователю(ТекстОшибки, Выборка.Ссылка);
			КонецПопытки
			
		КонецЦикла; // выборки документов данного типа
		
	КонецЦикла; // обхода соответствия типов
	
	Возврат КоличествоОбработанных;
	
КонецФункции

#КонецОбласти

#Область МетодыРаботыАвтозаполненияРеквизитовДокумента

// Заполняет реквизит "Автор" переданного по подписке незаписанного источника 
// 
// Параметры:
//	Источник - ДокументСсылка - источник с общим реквизитом "Автор".
//
Процедура УстановитьАвтораДокументаПередЗаписью(Источник) Экспорт
	
	Если Источник.ОбменДанными.Загрузка Тогда
		Возврат;
	КонецЕсли;

	Если Источник.Ссылка.Пустая() Или Источник.Автор = Неопределено Или Источник.Автор.Пустая() Тогда
		Источник.Автор = Пользователи.АвторизованныйПользователь();
	КонецЕсли;
	
КонецПроцедуры

// Получает значения автозаполнения по статистике и заполняет ими переданную структуру.
// Заполненные свойства не перезаполняются и выступают в роли отбора.
// Свойства, которые не найдены в метаданных объекта удаляются из структуры.
// 
// Параметры:
//	ОбъектСсылка - ДокументСсылка - ссылка на заполняемый документ.
//	СвойстваАвтозаполнения - Структура - свойства, которые нужно заполнить.
//
Процедура ЗаполнитьЗначенияСвойствАвтозаполнения(ОбъектСсылка, СвойстваАвтозаполнения) Экспорт
	
	// Проверим доступность свойств в объекте метаданных,
	// выделим параметры и поля запросов.
	ПараметрыЗапроса				= Новый Массив;
	ПоляЗапроса						= Новый Массив;
	
	Для Каждого СвойствоАвтозаполнения Из СвойстваАвтозаполнения Цикл
		
		КлючСвойства = СвойствоАвтозаполнения.Ключ;
		
		Если НЕ ЕстьРеквизитОбъекта(ОбъектСсылка, КлючСвойства) Тогда
			СвойстваАвтозаполнения.Удалить(КлючСвойства);
			
		Иначе
			Если ЗначениеЗаполнено(СвойствоАвтозаполнения.Значение) Тогда
				ПараметрыЗапроса.Добавить(КлючСвойства);
			Иначе
				ПоляЗапроса.Добавить(КлючСвойства);
			КонецЕсли;
			
		КонецЕсли;
		
	КонецЦикла;
	
	// Возвращаем переданную заполненную структуру
	Если ПоляЗапроса.Количество() = 0 Тогда
		Возврат
	КонецЕсли;
	
	СтруктураСвойствАвтозаполнения = Новый Структура;
	СтруктураСвойствАвтозаполнения.Вставить("ПараметрыЗапроса", ПараметрыЗапроса);
	СтруктураСвойствАвтозаполнения.Вставить("ПоляЗапроса",      ПоляЗапроса);
	
	Запрос = Новый Запрос;
	Запрос.Текст = ТекстЗапросаСвойствАвтозаполнения(ОбъектСсылка, СтруктураСвойствАвтозаполнения);
	
	Если ЕстьРеквизитОбъекта(ОбъектСсылка, "Автор") Тогда
		Запрос.УстановитьПараметр("Автор", Пользователи.АвторизованныйПользователь());
	КонецЕсли;
	
	Для Каждого ПараметрЗапроса Из ПараметрыЗапроса Цикл
		Запрос.УстановитьПараметр(ПараметрЗапроса, СвойстваАвтозаполнения[ПараметрЗапроса]);
	КонецЦикла; 
	
	РезультатыПакетаЗапросов = Запрос.ВыполнитьПакет();
	
	СчетчикПолей = 2;
	Для Каждого ПолеЗапроса Из ПоляЗапроса Цикл 
		РезультатПакета = РезультатыПакетаЗапросов[СчетчикПолей];
		
		Если НЕ РезультатПакета.Пустой() Тогда
			ВыборкаРезультата = РезультатПакета.Выбрать();
			ВыборкаРезультата.Следующий();
			
			СвойстваАвтозаполнения[ПолеЗапроса] = ВыборкаРезультата.ОбъектПоиска;
		КонецЕсли;
		
		СчетчикПолей = СчетчикПолей + 3;
		
	КонецЦикла;
	
КонецПроцедуры

// Заполняет реквизиты документа по статистике.
//
// Параметры:
//	Объект - ДокументОбъект - заполняемый документ
//	ДанныеЗаполнения - Произвольный - соответствующий параметр обработчика ОбработкаЗаполнения()
//	ИменаРеквизитовДляЗаполнения - Строка - имена заполняемых реквизитов документа
//	ИменаРеквизитовДляОтбора - Строка - имена реквизитов, по которым выполняется отбор статистики
//	ОтборПоАвтору - Строка - добавлять отбор по пользователю-автору документа.
//
Процедура ЗаполнитьПоЗначениямАвтозаполнения(Объект, ДанныеЗаполнения,
			Знач ИменаРеквизитовДляЗаполнения, Знач ИменаРеквизитовДляОтбора = "",
			ОтборПоАвтору = Истина) Экспорт
	
	ДанныеЗаполненияОпределены = (ДанныеЗаполнения <> Неопределено);
	ДанныеЗаполненияСтруктура = (ТипЗнч(ДанныеЗаполнения) = Тип("Структура"));
	
	СвойстваАвтозаполнения = Новый Структура(ИменаРеквизитовДляЗаполнения);
	
	Если НЕ ПустаяСтрока(ИменаРеквизитовДляОтбора) Тогда
		СтруктураОтбора    = Новый Структура(ИменаРеквизитовДляОтбора);
		ЕстьНепустыеОтборы = Ложь;
		
		Для Каждого КлючИЗначение Из СтруктураОтбора Цикл
			СвойстваАвтозаполнения.Вставить(КлючИЗначение.Ключ, Объект[КлючИЗначение.Ключ]);
			
			Если ЗначениеЗаполнено(Объект[КлючИЗначение.Ключ]) Тогда
				ЕстьНепустыеОтборы = Истина;
			КонецЕсли;
		КонецЦикла;
		
		Если НЕ ЕстьНепустыеОтборы Тогда
			Возврат;
		КонецЕсли;
	КонецЕсли;
	
	Если ОтборПоАвтору Тогда
		ИмяРеквизитаАвтор = "";
		
		Если ЕстьРеквизитОбъекта(Объект, "Автор") Тогда
			ИмяРеквизитаАвтор = "Автор";
			Объект.Автор = Пользователи.АвторизованныйПользователь();
		ИначеЕсли ЕстьРеквизитОбъекта(Объект, "Менеджер") Тогда
			ИмяРеквизитаАвтор = "Менеджер";
		ИначеЕсли ЕстьРеквизитОбъекта(Объект, "Ответственный") Тогда
			ИмяРеквизитаАвтор = "Ответственный";
		КонецЕсли;
		
		Если НЕ ПустаяСтрока(ИмяРеквизитаАвтор) Тогда
			Объект[ИмяРеквизитаАвтор] = Пользователи.АвторизованныйПользователь();
			СвойстваАвтозаполнения.Вставить(ИмяРеквизитаАвтор, Объект[ИмяРеквизитаАвтор]);
		КонецЕсли;
	КонецЕсли;
	
	СтрокаКлючиСтруктуры = ОбщегоНазначенияКлиентСервер.КлючиСтруктурыВСтроку(СвойстваАвтозаполнения);
	
	// Данные заполнения используются только в случае 
	// создания документа в списке с установленным отбором
	// или переданной из вне структуры.
	Если ДанныеЗаполненияОпределены И ДанныеЗаполненияСтруктура Тогда
		ЗаполнитьЗначенияСвойств(СвойстваАвтозаполнения, ДанныеЗаполнения);
	Иначе
		ЗаполнитьЗначенияСвойств(СвойстваАвтозаполнения, Объект);
	КонецЕсли;
	
	ЗаполнитьЗначенияСвойствАвтозаполнения(Объект.Ссылка, СвойстваАвтозаполнения);
	
	// Исключим перезапонение пустыми значениями
	Для Каждого СвойствоАвтозаполнения Из СвойстваАвтозаполнения Цикл 
		Если СвойствоАвтозаполнения.Значение = Неопределено
			Или Не ЗначениеЗаполнено(СвойствоАвтозаполнения.Значение) Тогда
			ИсключаемыеСвойства = ?(Не ПустаяСтрока(ИсключаемыеСвойства),",","") + ИсключаемыеСвойства + СвойствоАвтозаполнения.Ключ;
		КонецЕсли;
	КонецЦикла;
	
	ЗаполнитьЗначенияСвойств(Объект, СвойстваАвтозаполнения, СтрокаКлючиСтруктуры, ИсключаемыеСвойства);
КонецПроцедуры

#КонецОбласти

#Область НастройкиФорм

// Удаляет повторяющиеся элементы массива
//
// Параметры:
//		Массив - Массив - массив.
//		НеИспользоватьНеопределено - Булево - не использовать Неопределено.
//
// Возвращаемое значение:
//		Массив - массив без дублей.
Функция УдалитьПовторяющиесяЭлементыМассива(Массив, НеИспользоватьНеопределено = Ложь) Экспорт
	
	ОписаниеТиповСправочники  = Справочники.ТипВсеСсылки(); 
	ОписаниеТиповДокументы    = Документы.ТипВсеСсылки(); 
	ОписаниеТиповПВХ          = ПланыВидовХарактеристик.ТипВсеСсылки(); 
	ОписаниеТиповПланыСчетов  = ПланыСчетов.ТипВсеСсылки(); 
	ОписаниеТиповПланыРасчета = ПланыВидовРасчета.ТипВсеСсылки(); 
	
	Если ТипЗнч(Массив) = Тип("Массив") Тогда 
		
		УжеВМассиве 		   = Новый Соответствие; 
		БылоНеопределено 	   = Ложь;
		КолвоЭлементовВМассиве = Массив.Количество(); 
		
		Для ОбратныйИндекс = 1 По КолвоЭлементовВМассиве Цикл 
			
			ЭлементМассива = Массив[КолвоЭлементовВМассиве - ОбратныйИндекс]; 
			ТипЭлемента    = ТипЗнч(ЭлементМассива); 
			
			Если ЭлементМассива = Неопределено Тогда
				
				Если БылоНеопределено ИЛИ НеИспользоватьНеопределено Тогда
					Массив.Удалить(КолвоЭлементовВМассиве - ОбратныйИндекс); 
				Иначе
					БылоНеопределено = Истина;
				КонецЕсли;
				
				Продолжить;
				
			ИначеЕсли ОписаниеТиповСправочники.СодержитТип(ТипЭлемента) 
			 ИЛИ ОписаниеТиповДокументы.СодержитТип(ТипЭлемента) 
			 ИЛИ ОписаниеТиповПВХ.СодержитТип(ТипЭлемента) 
			 ИЛИ ОписаниеТиповПланыСчетов.СодержитТип(ТипЭлемента) 
			 ИЛИ ОписаниеТиповПланыРасчета.СодержитТип(ТипЭлемента) Тогда 
				
				ИДЭлемента = Строка(ЭлементМассива.УникальныйИдентификатор()); 
				
			Иначе 
				
				ИДЭлемента = ЭлементМассива; 
				
			КонецЕсли; 
			
			Если УжеВМассиве[ИДЭлемента] = Истина Тогда 
				Массив.Удалить(КолвоЭлементовВМассиве - ОбратныйИндекс); 
			Иначе 
				УжеВМассиве[ИДЭлемента] = Истина; 
			КонецЕсли; 
			
		КонецЦикла;      
		
	КонецЕсли;
	
	Возврат Массив;
	
КонецФункции

// Функция возвращает представление клавиши
// Параметры:
//		ЗначениеКлавиша - Клавиша - клавиша.
//
// Возвращаемое значение:
//		Строка - Представление клавиши.
//
Функция ПредставлениеКлавиши(ЗначениеКлавиша) Экспорт
	
	Если Строка(Клавиша._1) = Строка(ЗначениеКлавиша) Тогда
		Возврат "1";
	ИначеЕсли Строка(Клавиша._2) = Строка(ЗначениеКлавиша) Тогда
		Возврат "2";
	ИначеЕсли Строка(Клавиша._3) = Строка(ЗначениеКлавиша) Тогда
		Возврат "3";
	ИначеЕсли Строка(Клавиша._4) = Строка(ЗначениеКлавиша) Тогда
		Возврат "4";
	ИначеЕсли Строка(Клавиша._5) = Строка(ЗначениеКлавиша) Тогда
		Возврат "5";
	ИначеЕсли Строка(Клавиша._6) = Строка(ЗначениеКлавиша) Тогда
		Возврат "6";
	ИначеЕсли Строка(Клавиша._7) = Строка(ЗначениеКлавиша) Тогда
		Возврат "7";
	ИначеЕсли Строка(Клавиша._8) = Строка(ЗначениеКлавиша) Тогда
		Возврат "8";
	ИначеЕсли Строка(Клавиша._9) = Строка(ЗначениеКлавиша) Тогда
		Возврат "9";
	ИначеЕсли Строка(Клавиша.Num0) = Строка(ЗначениеКлавиша) Тогда
		Возврат "Num 0";
	ИначеЕсли Строка(Клавиша.Num1) = Строка(ЗначениеКлавиша) Тогда
		Возврат "Num 1";
	ИначеЕсли Строка(Клавиша.Num2) = Строка(ЗначениеКлавиша) Тогда
		Возврат "Num 2";
	ИначеЕсли Строка(Клавиша.Num3) = Строка(ЗначениеКлавиша) Тогда
		Возврат "Num 3";
	ИначеЕсли Строка(Клавиша.Num4) = Строка(ЗначениеКлавиша) Тогда
		Возврат "Num 4";
	ИначеЕсли Строка(Клавиша.Num5) = Строка(ЗначениеКлавиша) Тогда
		Возврат "Num 5";
	ИначеЕсли Строка(Клавиша.Num6) = Строка(ЗначениеКлавиша) Тогда
		Возврат "Num 6";
	ИначеЕсли Строка(Клавиша.Num7) = Строка(ЗначениеКлавиша) Тогда
		Возврат "Num 7";
	ИначеЕсли Строка(Клавиша.Num8) = Строка(ЗначениеКлавиша) Тогда
		Возврат "Num 8";
	ИначеЕсли Строка(Клавиша.Num9) = Строка(ЗначениеКлавиша) Тогда
		Возврат "Num 9";
	ИначеЕсли Строка(Клавиша.NumAdd) = Строка(ЗначениеКлавиша) Тогда
		Возврат "Num +";
	ИначеЕсли Строка(Клавиша.NumDecimal) = Строка(ЗначениеКлавиша) Тогда
		Возврат "Num .";
	ИначеЕсли Строка(Клавиша.NumDivide) = Строка(ЗначениеКлавиша) Тогда
		Возврат "Num /";
	ИначеЕсли Строка(Клавиша.NumMultiply) = Строка(ЗначениеКлавиша) Тогда
		Возврат "Num *";
	ИначеЕсли Строка(Клавиша.NumSubtract) = Строка(ЗначениеКлавиша) Тогда
		Возврат "Num -";
	Иначе
		Возврат Строка(ЗначениеКлавиша);
	КонецЕсли;
	
КонецФункции

// Функция возвращает представление клавиши
// Параметры:
//		СочетаниеКлавиш - СочетаниеКлавиш - Сочетание клавиш для которого нужно сформировать представление
//		БезСкобок - Булево - Флаг, указывающий, что представление должно быть сформировано без скобок.
//
// Возвращаемое значение:
//		Строка - Представление сочетания клавиш.
//
Функция ПредставлениеСочетанияКлавиш(СочетаниеКлавиш, БезСкобок = Ложь) Экспорт
	
	Если СочетаниеКлавиш.Клавиша = Клавиша.Нет Тогда
		Возврат "";
	КонецЕсли;
	
	Наименование = ?(БезСкобок, "", "(");
	Если СочетаниеКлавиш.Ctrl Тогда
		Наименование = Наименование + "Ctrl+"
	КонецЕсли;
	Если СочетаниеКлавиш.Alt Тогда
		Наименование = Наименование + "Alt+"
	КонецЕсли;
	Если СочетаниеКлавиш.Shift Тогда
		Наименование = Наименование + "Shift+"
	КонецЕсли;
	Наименование = Наименование + ПредставлениеКлавиши(СочетаниеКлавиш.Клавиша) + ?(БезСкобок, "", ")");
	
	Возврат Наименование;
	
КонецФункции

// Инициализирует параметры формф для полнотекствого поиска.
// Параметры:
//		Форма - УправляемаяФорма - форма.
//		ИмяФОИспользованияППД - Строка - имя функциональной опции.
Процедура ИнициализироватьРеквизитыФормыДляПолнотекстовогоПоиска(Форма, ИмяФОИспользованияППД) Экспорт
	
	Форма.ИнформационнаяБазаФайловая      = ОбщегоНазначения.ИнформационнаяБазаФайловая();
	Форма.ИспользоватьПолнотекстовыйПоиск = ОбщегоНазначенияУТВызовСервера.ИспользуетсяПолнотекстовыйПоиск(ИмяФОИспользованияППД);
	
	Если Форма.ИспользоватьПолнотекстовыйПоиск Тогда
			
		Форма.ИндексПолнотекстовогоПоискаАктуален = ПолнотекстовыйПоискСервер.ИндексПоискаАктуален();
		
	КонецЕсли;
	
КонецПроцедуры

#КонецОбласти

#Область ЗаполненияТабличныхЧастейДокумента

// Функция возвращает параметры проверки заполнения количества
//
//	Возвращаемое значение:
//		Структура - с полями:
//			*ИмяТЧ - Строка - значение по умолчанию "Товары"
//			*СуффиксДопРеквизита - Строка - значение по умолчанию "" - если в ТЧ два реквизита
//											"Количество", то второй назван с суффиком. 
//											если суффикс передан, то проверяются оба реквизита.
//
Функция ПараметрыПроверкиЗаполненияКоличества() Экспорт
	
	ПараметрыПроверки = Новый Структура;
	ПараметрыПроверки.Вставить("ИмяТЧ",                 "Товары");	
	ПараметрыПроверки.Вставить("СуффиксДопРеквизита",   "");
	
	Возврат ПараметрыПроверки;
	
КонецФункции

// Процедуры проверки заполнения реквизита Количество и КоличествоУпаковок в документах.
// Параметры:
//		Объект - ДокументОбъект - проверяемый ДокументОбъект
//		ПроверяемыеРеквизиты - Массив - массив проверяемых реквизитов
//		Отказ - Булево - отказ продолжения операции.
//		ПараметрыПроверки - Структура - структура параметров.
Процедура ПроверитьЗаполнениеКоличества(Объект, ПроверяемыеРеквизиты, Отказ,ПараметрыПроверки = Неопределено) Экспорт
	
	Перем ИмяТЧ;
	Перем ЗаполнятьРеквизитОбязательно;
	
	Если ПараметрыПроверки <> Неопределено Тогда
		ПараметрыПроверки.Свойство("ИмяТЧ",ИмяТЧ);
	КонецЕсли;
		
	Если Не ЗначениеЗаполнено(ИмяТЧ) Тогда
		ИмяТЧ = "Товары";	
	КонецЕсли;
	
	КлючДанных = КлючДанныхДляСообщенияПользователю(Объект);
	
	МетаданныеОбъекта = Объект.Метаданные();
	
	РеквизитПроверки =  ПроверяемыеРеквизиты.Найти(ИмяТЧ + ".КоличествоУпаковок");
	ЗаполнятьРеквизитОбязательно = РеквизитПроверки <> Неопределено;
	Если РеквизитПроверки <> Неопределено Тогда
		ПроверяемыеРеквизиты.Удалить(РеквизитПроверки);
		ПроверяемыеРеквизиты.Удалить(ПроверяемыеРеквизиты.Найти(ИмяТЧ + ".Количество"));
	КонецЕсли;
	
	ПредставлениеТЧ                          = МетаданныеОбъекта.ТабличныеЧасти[ИмяТЧ].Синоним;
	ПредставлениеРеквизитаКоличествоУпаковок = МетаданныеОбъекта.ТабличныеЧасти[ИмяТЧ].Реквизиты.КоличествоУпаковок.Синоним;
	
	ШаблонОшибкаКоличества = НСтр("ru = 'Не заполнена колонка ""%ПредставлениеКолонки%"" в строке %НомерСтроки% списка ""%ПредставлениеТЧ%""'");
	ШаблонОшибкаПересчета = НСтр("ru = 'Обнаружено нулевое количество при пересчете в единицу хранения в строке %НомерСтроки% списка ""%ПредставлениеТЧ%""'");
	
	Для Каждого СтрокаТаб Из Объект[ИмяТЧ] Цикл
		
		Если СтрокаТаб.Количество = 0 
			И СтрокаТаб.КоличествоУпаковок <> 0 Тогда
			
			ТекстСообщения = СтрЗаменить(ШаблонОшибкаПересчета, "%НомерСтроки%", Строка(СтрокаТаб.НомерСтроки));
			ТекстСообщения = СтрЗаменить(ТекстСообщения, "%ПредставлениеТЧ%", ПредставлениеТЧ);
			
			Поле = ОбщегоНазначенияКлиентСервер.ПутьКТабличнойЧасти(ИмяТЧ, СтрокаТаб.НомерСтроки, "КоличествоУпаковок");
			
			ОбщегоНазначенияКлиентСервер.СообщитьПользователю(ТекстСообщения,КлючДанных,Поле,"Объект",Отказ);
			
		ИначеЕсли ЗаполнятьРеквизитОбязательно
			И (СтрокаТаб.Количество = 0
			Или СтрокаТаб.КоличествоУпаковок = 0) Тогда
			
			ТекстСообщения = СтрЗаменить(ШаблонОшибкаКоличества, "%НомерСтроки%", Строка(СтрокаТаб.НомерСтроки));
			ТекстСообщения = СтрЗаменить(ТекстСообщения, "%ПредставлениеТЧ%", ПредставлениеТЧ);
			ТекстСообщения = СтрЗаменить(ТекстСообщения, "%ПредставлениеКолонки%", ПредставлениеРеквизитаКоличествоУпаковок);
			
			Поле = ОбщегоНазначенияКлиентСервер.ПутьКТабличнойЧасти(ИмяТЧ, СтрокаТаб.НомерСтроки, "КоличествоУпаковок");
			
			ОбщегоНазначенияКлиентСервер.СообщитьПользователю(ТекстСообщения,КлючДанных,Поле,"Объект",Отказ);
					
		КонецЕсли;
				
	КонецЦикла;
	
КонецПроцедуры

// Процедура проверяет дубли строк в табличной части
// Параметры:
//		Объект - ДокументОбъект - проверяемый ДокументОбъект
//		ИмяТЧ - Строка - имя проверяемой табличной части
//		КлючевыеРеквизиты - Массив - массив имен реквизитов, по которым определяется уникальность строки.
//		Отказ - Булево - отказ продолжения операции.
//		ПредставлениеТЧ - Строка - представление ТЧ.
Процедура ПроверитьНаличиеДублейСтрокТЧ(Объект,ИмяТЧ,КлючевыеРеквизиты,Отказ, ПредставлениеТЧ = "") Экспорт
	
	КлючДанных = КлючДанныхДляСообщенияПользователю(Объект);
	
	МетаданныеОбъекта = Объект.Метаданные();
	Если ПустаяСтрока(ПредставлениеТЧ) Тогда
		ПредставлениеТЧ   = МетаданныеОбъекта.ТабличныеЧасти[ИмяТЧ].Синоним;
	КонецЕсли;
	
	ТекстПоляВыборки = "";
	ТекстПоляСоединения = "";	
    ТекстПоляВыгрузки = "";
	ТекстДляСообщенияОДублях = "";
	Для Каждого СтрМас из КлючевыеРеквизиты Цикл
		ТекстПоляВыборки = ТекстПоляВыборки + "
	|	ТаблицаПроверки." + СтрМас + ",";
		ТекстПоляСоединения = ТекстПоляСоединения + "
	|	И ТаблицаПроверки." + СтрМас + " = ДублирующиесяСтроки."+ СтрМас;
		ТекстПоляВыгрузки = ТекстПоляВыгрузки + СтрМас + ",";
		
		ПредставлениеРеквизита = МетаданныеОбъекта.ТабличныеЧасти[ИмяТЧ].Реквизиты[СтрМас].Синоним;
		
		ТекстДляСообщенияОДублях = ТекстДляСообщенияОДублях + """"  + ПредставлениеРеквизита  + """, "
	КонецЦикла;	
	
	ТекстДляСообщенияОДублях = Лев(ТекстДляСообщенияОДублях, СтрДлина(ТекстДляСообщенияОДублях) - 2);
	
	СтроковыеФункцииКлиентСервер.УдалитьПоследнийСимволВСтроке(ТекстПоляВыборки,1);
	СтроковыеФункцииКлиентСервер.УдалитьПоследнийСимволВСтроке(ТекстПоляВыгрузки,1);
	
	Запрос = Новый Запрос;
	Запрос.Текст =
	"ВЫБРАТЬ 
	|	ТаблицаПроверки.НомерСтроки, " +
		ТекстПоляВыборки + "
	|ПОМЕСТИТЬ ТаблицаПроверки
	|ИЗ
	|	&ТаблицаПроверки КАК ТаблицаПроверки
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	МИНИМУМ(ТаблицаПроверки.НомерСтроки) КАК НомерСтроки,
	|	СУММА(1) КАК КоличествоДублей,"+
		ТекстПоляВыборки + "
	|ПОМЕСТИТЬ ДублирующиесяСтроки
	|ИЗ
	|	ТаблицаПроверки КАК ТаблицаПроверки
	|
	|СГРУППИРОВАТЬ ПО " +
		ТекстПоляВыборки + "
	|
	|ИМЕЮЩИЕ
	|	СУММА(1) > 1
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	ТаблицаПроверки.НомерСтроки,
	|	ДублирующиесяСтроки.НомерСтроки КАК ПерваяСтрока
	|ИЗ
	|	ТаблицаПроверки КАК ТаблицаПроверки
	|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ ДублирующиесяСтроки КАК ДублирующиесяСтроки
	|		ПО ТаблицаПроверки.НомерСтроки <> ДублирующиесяСтроки.НомерСтроки " +
	     		ТекстПоляСоединения;
	Запрос.УстановитьПараметр("ТаблицаПроверки",Объект[ИмяТЧ].Выгрузить(,"НомерСтроки," + ТекстПоляВыгрузки));
	
	Выборка = Запрос.Выполнить().Выбрать();
	
	Если КлючевыеРеквизиты.Количество() = 1 Тогда
		ШаблонСообщения = НСтр("ru = 'Данные в строке %НомерСтроки% списка ""%ПредставлениеТЧ%"" совпадают с данными в строке %ПерваяСтрока% по значению поля %НазванияПолей%.'");
	Иначе
		ШаблонСообщения = НСтр("ru = 'Данные в строке %НомерСтроки% списка ""%ПредставлениеТЧ%"" совпадают с данными в строке %ПерваяСтрока% по сочетанию значений полей %НазванияПолей%.'");
	КонецЕсли;	
	
	Пока Выборка.Следующий() Цикл
		
		ТекстСообщения =  СтрЗаменить(ШаблонСообщения, "%ПредставлениеТЧ%", ПредставлениеТЧ);
		ТекстСообщения =  СтрЗаменить(ТекстСообщения, "%НомерСтроки%", Выборка.НомерСтроки);
		ТекстСообщения =  СтрЗаменить(ТекстСообщения, "%ПерваяСтрока%", Выборка.ПерваяСтрока);
		ТекстСообщения =  СтрЗаменить(ТекстСообщения, "%НазванияПолей%", ТекстДляСообщенияОДублях);
		
		Поле = ОбщегоНазначенияКлиентСервер.ПутьКТабличнойЧасти(ИмяТЧ, Выборка.НомерСтроки, "НомерСтроки");
		
		ОбщегоНазначенияКлиентСервер.СообщитьПользователю(ТекстСообщения,КлючДанных,Поле,"Объект",Отказ);
		
	КонецЦикла;
КонецПроцедуры

// Процедура заполняет значения реквизитов табличной части по структуре
//
// Параметры:
// 		КоллекцияДанных - ДанныеФормыКоллекция - Табличная часть
// 		СтруктураРеквизитов - Структура - Структура. Ключ - имя реквизита флага активности.
//										Значение - строка перечисления зависимых реквизитов.
//
Процедура ЗаполнитьДубликатыЗависимыхРеквизитовВКоллекции(КоллекцияДанных, СтруктураРеквизитов) Экспорт
	
	// Получение шаблона поля выборки для значения дубликата реквизита
	// 		Если флаг активности ИСТИНА - скопировать значение из реквизита
	// 		Иначе - заполнить пустым значением.
	ШаблонПоляВыборки = ",
	|	ВЫБОР КОГДА Коллекция.%ИмяФлага% = ИСТИНА
	|		ТОГДА Коллекция.%ИмяРеквизита%
	|		ИНАЧЕ 0
	|	КОНЕЦ КАК %ИмяРеквизита%%ИмяФлага%";
	
	ПоляВыборки = ""; // Поля выборки для запроса получения данных
	ПоляВыгрузки = "НомерСтроки"; // Перечисление через запятую полей, выгружаемых из коллекции
	Для Каждого РеквизитФлага Из СтруктураРеквизитов Цикл
		ПоляВыгрузки = ПоляВыгрузки + ", " + РеквизитФлага.Ключ;
		ЗависимыеРеквизиты = Новый Структура(РеквизитФлага.Значение);
		Для Каждого ЗависимыйРеквизит Из ЗависимыеРеквизиты Цикл
			ПоляВыборки = ПоляВыборки + СтрЗаменить(СтрЗаменить(ШаблонПоляВыборки, "%ИмяФлага%", РеквизитФлага.Ключ), "%ИмяРеквизита%", ЗависимыйРеквизит.Ключ);
			ПоляВыгрузки = ПоляВыгрузки + ", " + ЗависимыйРеквизит.Ключ + ", " + ЗависимыйРеквизит.Ключ + РеквизитФлага.Ключ;
		КонецЦикла;
	КонецЦикла;
	
	Запрос = Новый Запрос(
	"ВЫБРАТЬ
	|	Коллекция.НомерСтроки" + ПоляВыборки + "
	|ПОМЕСТИТЬ втКоллекция
	|ИЗ &КоллекцияДанных КАК Коллекция;
	|
	|ВЫБРАТЬ *
	|ИЗ втКоллекция КАК втКоллекция
	|УПОРЯДОЧИТЬ ПО НомерСтроки");
	Запрос.УстановитьПараметр("КоллекцияДанных", КоллекцияДанных.Выгрузить( , ПоляВыгрузки));
	
	Выборка = Запрос.Выполнить().Выбрать();
	Пока Выборка.Следующий() Цикл
		ЗаполнитьЗначенияСвойств(КоллекцияДанных[Выборка.НомерСтроки-1], Выборка, , "НомерСтроки");
	КонецЦикла;
	
КонецПроцедуры // ЗаполнитьДубликатыЗависимыхРеквизитовВКоллекции()

// Процедура проверяет отмену строк в табличной части документа
// Параметры:
//		Объект - ДокументОбъект - проверяемый ДокументОбъект
//		ИмяТЧ - Строка - имя проверяемой табличной части
//		ИмяРеквизитаОтменыСтрок - Строка - имя проверяемого булевого реквизита ТЧ.
//
// Возвращаемое значение:
//		Булево - все строки отменены.
Функция ВсеСтрокиОтменены(Объект, ИмяТЧ, ИмяРеквизитаОтменыСтрок) Экспорт
	
	СтруктураОтбора = Новый Структура(ИмяРеквизитаОтменыСтрок, Ложь);
	НеОтмененныеСтроки = Объект[ИмяТЧ].НайтиСтроки(СтруктураОтбора);
	
	Возврат (НеОтмененныеСтроки.Количество() = 0);
	
КонецФункции

#КонецОбласти

#Область КонтрольНесогласованныхИзменений

// Осуществляет установку подписки на события изменения элементов формы.
//
// Параметры:
// 		Форма                    - ДокументОбъект, СправочникОбъект - Проверяемый объект.
// 		ИменаЭлементов          - Массив - массив элементов формы.
// 		Установить - Булево - необходимость установки или снятия предупреждения.
//
Процедура УстановитьПодпискуНаСобытияИзмененияЭлементовФормы(Форма, ИменаЭлементов, Установить) Экспорт
	
	СтруктураТ = Новый Структура;
	
	ОбработчикиСобытийТабличныхЧастей = Новый Структура();
	МассивЭлементов = Новый Массив;
	Для Каждого ИмяЭлементаПолное Из ИменаЭлементов Цикл
		
		Массив = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(ИмяЭлементаПолное, ";");
		ИмяЭлемента = Массив[0];
		
		Если МассивЭлементов.Найти(ИмяЭлемента) <> Неопределено Тогда
			Продолжить;
		КонецЕсли;
		
		Если Форма.Элементы.Найти(ИмяЭлемента) = Неопределено Тогда
			Продолжить;
		КонецЕсли;
		
		МассивЭлементов.Добавить(ИмяЭлемента);
		
		Если Массив.Количество() > 1 Тогда
			ОбработчикиСобытийТабличныхЧастей.Вставить(ИмяЭлемента, СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(Массив[1], ","))
		КонецЕсли;
		
		ОбработатьВложенныеПоля(Форма, ИмяЭлемента, МассивЭлементов, СтруктураТ);
		
	КонецЦикла;
	
	ИмяОбработчикаПустой = "Подключаемый_ПустойОбработчик_УстановитьДоступностьЭлементовПоСтатусуСервер";
	Если 
		// Установить И 
		Форма.СтруктураДействийКонтрольНеСогласованныхИзменений = Неопределено Тогда
		
		Форма.СтруктураДействийКонтрольНеСогласованныхИзменений = Новый Структура;
		Форма.СтруктураДействийКонтрольНеСогласованныхИзменений.Вставить("Команды", Новый Структура);
		Форма.СтруктураДействийКонтрольНеСогласованныхИзменений.Вставить("ПриИзменении", Новый Структура);
		Форма.СтруктураДействийКонтрольНеСогласованныхИзменений.Вставить("Нажатие", Новый Структура);
		Форма.СтруктураДействийКонтрольНеСогласованныхИзменений.Вставить("ПередНачаломИзменения", Новый Структура);
		Форма.СтруктураДействийКонтрольНеСогласованныхИзменений.Вставить("ПередНачаломДобавления", Новый Структура);
		Форма.СтруктураДействийКонтрольНеСогласованныхИзменений.Вставить("ПередУдалением", Новый Структура);
		
		Форма.СтруктураДействийКонтрольНеСогласованныхИзменений.Вставить("ОжидаетсяОповещение", Ложь);
		Форма.СтруктураДействийКонтрольНеСогласованныхИзменений.Вставить("ЗначенияРеквизитов", Новый Структура);
		Форма.СтруктураДействийКонтрольНеСогласованныхИзменений.Вставить("ПутьКДанным", Новый Структура);
		
		Для Каждого ИмяТаблицы Из СтруктураТ Цикл
			
			Имена = Новый Массив;
			Форма.СтруктураДействийКонтрольНеСогласованныхИзменений.ЗначенияРеквизитов.Вставить(ИмяТаблицы.Ключ, Новый Структура);
			
			Для Каждого ИмяЭлемента Из СтруктураТ[ИмяТаблицы.Ключ] Цикл
				
				Данные = Неопределено;
				ПутьКДанным = Форма.Элементы[ИмяЭлемента].ПутьКДанным;
				Если ЗначениеЗаполнено(ПутьКДанным) Тогда
					Массив = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(ПутьКДанным, ".");
					Данные = Форма;
					Для Каждого СтрокаМассива Из Массив Цикл
						Если ТипЗнч(Данные) = Тип("УправляемаяФорма")
							ИЛИ ТипЗнч(Данные) = Тип("ДанныеФормыСтруктура") Тогда
							Данные = Данные[СтрокаМассива];
						ИначеЕсли ТипЗнч(Данные) = Тип("ДанныеФормыКоллекция") Тогда
							Имена.Добавить(СтрокаМассива);
							Прервать;
						Иначе
							Данные = Неопределено;
							Прервать;
						КонецЕсли;
					КонецЦикла;
				КонецЕсли;
				
			КонецЦикла;
			
			Для Каждого Имя Из Имена Цикл
				Форма.СтруктураДействийКонтрольНеСогласованныхИзменений.ЗначенияРеквизитов[ИмяТаблицы.Ключ].Вставить(Имя);
			КонецЦикла;
			
		КонецЦикла;
		
		ИмяОбработчикаПриИзменении            = "Подключаемый_ПриИзменении_УстановитьДоступностьЭлементовПоСтатусуСервер";
		ИмяОбработчикаНажатие                 = "Подключаемый_Нажатие_УстановитьДоступностьЭлементовПоСтатусуСервер";
		ИмяОбработчикаКоманды                 = "Подключаемый_Команда_УстановитьДоступностьЭлементовПоСтатусуСервер";
		ИмяОбработчикаПередНачаломИзменения   = "Подключаемый_ПередНачаломИзменения_УстановитьДоступностьЭлементовПоСтатусуСервер";
		ИмяОбработчикаПередНачаломДобавления  = "Подключаемый_ПередНачаломДобавления_УстановитьДоступностьЭлементовПоСтатусуСервер";
		ИмяОбработчикаПередУдалением          = "Подключаемый_ПередУдалением_УстановитьДоступностьЭлементовПоСтатусуСервер";
		
		Для Каждого ИмяЭлементаПолное Из МассивЭлементов Цикл
			
			Массив = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(ИмяЭлементаПолное, ";");
			ИмяЭлемента = Массив[0];
			Действия = Неопределено;
			Если Массив.Количество() > 1 Тогда
				Действия = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(Массив[1], ",");
			КонецЕсли;
			
			Если Форма.Элементы.Найти(ИмяЭлемента) = Неопределено Тогда
				Продолжить;
			КонецЕсли;
			
			Если ТипЗнч(Форма.Элементы[ИмяЭлемента]) = Тип("ПолеФормы") Тогда
				
				Действие = Форма.Элементы[ИмяЭлемента].ПолучитьДействие("ПриИзменении");
				Если ЗначениеЗаполнено(Действие) И Действие <> ИмяОбработчикаПустой Тогда
					Форма.СтруктураДействийКонтрольНеСогласованныхИзменений.ПриИзменении.Вставить(ИмяЭлемента, Действие);
				КонецЕсли;
				
				Данные = Неопределено;
				ПутьКДанным = Форма.Элементы[ИмяЭлемента].ПутьКДанным;
				Если ЗначениеЗаполнено(ПутьКДанным) Тогда
					Массив = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(ПутьКДанным, ".");
					Данные = Форма;
					Для Каждого СтрокаМассива Из Массив Цикл
						Если ТипЗнч(Данные) = Тип("УправляемаяФорма")
							ИЛИ ТипЗнч(Данные) = Тип("ДанныеФормыСтруктура") Тогда
							Данные = Данные[СтрокаМассива];
						Иначе
							Данные = Неопределено;
							Прервать;
						КонецЕсли;
					КонецЦикла;
				КонецЕсли;
				
				Если Данные <> Неопределено Тогда
					Форма.СтруктураДействийКонтрольНеСогласованныхИзменений.ЗначенияРеквизитов.Вставить(ИмяЭлемента, Данные);
				КонецЕсли;
				Форма.СтруктураДействийКонтрольНеСогласованныхИзменений.ПутьКДанным.Вставить(ИмяЭлемента, ПутьКДанным);
				Форма.Элементы[ИмяЭлемента].УстановитьДействие("ПриИзменении", ИмяОбработчикаПриИзменении);
				
			ИначеЕсли ТипЗнч(Форма.Элементы[ИмяЭлемента]) = Тип("ТаблицаФормы") Тогда
				
				Действия = Неопределено;
				ОбработчикиСобытийТабличныхЧастей.Свойство(ИмяЭлемента, Действия);
				
				Если Действия = Неопределено Или Действия.Найти("ПередНачаломДобавления") <> Неопределено Тогда
					Действие = Форма.Элементы[ИмяЭлемента].ПолучитьДействие("ПередНачаломДобавления");
					Если ЗначениеЗаполнено(Действие) И Действие <> ИмяОбработчикаПустой Тогда
						Форма.СтруктураДействийКонтрольНеСогласованныхИзменений.ПередНачаломДобавления.Вставить(ИмяЭлемента, Действие);
					КонецЕсли;
					Форма.Элементы[ИмяЭлемента].УстановитьДействие("ПередНачаломДобавления", ИмяОбработчикаПередНачаломДобавления);
				КонецЕсли;
				
				Если Действия = Неопределено Или Действия.Найти("ПередУдалением") <> Неопределено Тогда
					Действие = Форма.Элементы[ИмяЭлемента].ПолучитьДействие("ПередУдалением");
					Если ЗначениеЗаполнено(Действие) И Действие <> ИмяОбработчикаПустой Тогда
						Форма.СтруктураДействийКонтрольНеСогласованныхИзменений.ПередУдалением.Вставить(ИмяЭлемента, Действие);
					КонецЕсли;
					Форма.Элементы[ИмяЭлемента].УстановитьДействие("ПередУдалением", ИмяОбработчикаПередУдалением);
				КонецЕсли;
				
				Если Действия = Неопределено Или Действия.Найти("ПередНачаломИзменения") <> Неопределено Тогда
					Действие = Форма.Элементы[ИмяЭлемента].ПолучитьДействие("ПередНачаломИзменения");
					Если ЗначениеЗаполнено(Действие) И Действие <> ИмяОбработчикаПустой Тогда
						Форма.СтруктураДействийКонтрольНеСогласованныхИзменений.ПередНачаломИзменения.Вставить(ИмяЭлемента, Действие);
					КонецЕсли;
					Форма.Элементы[ИмяЭлемента].УстановитьДействие("ПередНачаломИзменения", ИмяОбработчикаПередНачаломИзменения);
				КонецЕсли;
				
			ИначеЕсли ТипЗнч(Форма.Элементы[ИмяЭлемента]) = Тип("КнопкаФормы") Тогда
				
				ИмяКоманды = Форма.Элементы[ИмяЭлемента].ИмяКоманды;
				
				Если Не ЗначениеЗаполнено(ИмяКоманды) Тогда
					Продолжить;
				КонецЕсли;
				
				Если Форма.СтруктураДействийКонтрольНеСогласованныхИзменений.Команды.Свойство(ИмяКоманды) Тогда
					Продолжить;
				КонецЕсли;
				
				Действие = Форма.Команды[ИмяКоманды].Действие;
				Если ЗначениеЗаполнено(Действие) Тогда
					Форма.СтруктураДействийКонтрольНеСогласованныхИзменений.Команды.Вставить(ИмяКоманды, Действие);
				КонецЕсли;
				
				Форма.Команды[ИмяКоманды].Действие = ИмяОбработчикаКоманды;
				
			ИначеЕсли ТипЗнч(Форма.Элементы[ИмяЭлемента]) = Тип("ДекорацияФормы") Тогда
				
				Действие = Форма.Элементы[ИмяЭлемента].ПолучитьДействие("Нажатие");
				Если ЗначениеЗаполнено(Действие) И Действие <> ИмяОбработчикаПустой Тогда
					Форма.СтруктураДействийКонтрольНеСогласованныхИзменений.Нажатие.Вставить(ИмяЭлемента, Действие);
				КонецЕсли;
				
				Форма.Элементы[ИмяЭлемента].УстановитьДействие("Нажатие", ИмяОбработчикаНажатие);
				
			Иначе
				ВызватьИсключение НСтр("ru = 'Внутренняя ошибка'");
			КонецЕсли;
		КонецЦикла;
		
	Иначе
		
		Если Форма.СтруктураДействийКонтрольНеСогласованныхИзменений <> Неопределено Тогда
			Форма.СтруктураДействийКонтрольНеСогласованныхИзменений.ОжидаетсяОповещение = Ложь;
		КонецЕсли;
		
	КонецЕсли;
	
КонецПроцедуры

#КонецОбласти

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

#Область ПроцедурыИФункцииУстановкиСтатусовДляМассиваДокументов

// Возвращает соответствие массивов документов по типам.
//
// Параметры:
// 		МассивСсылок - Массив - Массив ссылок.
//
// Возвращаемое значение:
// 		Соответствие - Ключ: Тип; значение: Массив ссылок на документы.
//
Функция РазложитьМассивСсылокПоТипам(МассивСсылок) Экспорт
	
	СоответствиеТипов = Новый Соответствие;
	
	Для Сч = 0 По МассивСсылок.Количество() -1 Цикл
		
		ТипСсылки = ТипЗнч(МассивСсылок[Сч]);
		Массив = СоответствиеТипов[ТипСсылки];
		Если Массив = Неопределено Тогда
			Массив = Новый Массив;
			СоответствиеТипов.Вставить(ТипСсылки, Массив);
		КонецЕсли;
		Массив.Добавить(МассивСсылок[Сч]);
		
	КонецЦикла;
	
	Возврат СоответствиеТипов;
	
КонецФункции // РазложитьМассивСсылокПоТипам

#КонецОбласти

#Область МетодыРаботыАвтозаполненияРеквизитовДокумента

Функция ИмяВидаОбъекта(ОбъектСсылка)
	
	ИмяВидаОбъекта = "";
	
	ТипЗначенияОбъекта = ТипЗнч(ОбъектСсылка);
	МетаданныеОбъекта = Метаданные.НайтиПоТипу(ТипЗначенияОбъекта);
	
	Если НЕ МетаданныеОбъекта = Неопределено Тогда
		ИмяВидаОбъекта = МетаданныеОбъекта.Имя;
		
	КонецЕсли;
	
	Возврат ИмяВидаОбъекта;
	
КонецФункции

Функция ЕстьРеквизитОбъекта(Объект, ИмяРеквизита) Экспорт
	
	КлючУникальности   = Новый УникальныйИдентификатор;
	СтруктураРеквизита = Новый Структура(ИмяРеквизита, КлючУникальности);

	ЗаполнитьЗначенияСвойств(СтруктураРеквизита, Объект);
	
	Возврат СтруктураРеквизита[ИмяРеквизита] <> КлючУникальности;
	
КонецФункции

Функция ШаблонЗапросаСвойствАвтозаполнения(ИмяВидаОбъекта, ОграничитьПоАвтору = Истина)
	
	ТекстЗапроса = "
	|ВЫБРАТЬ РАЗРЕШЕННЫЕ ПЕРВЫЕ 5
	|	СтатистикаСДатами.ОбъектПоиска КАК ОбъектПоиска,
	|	СУММА(СтатистикаСДатами.Использование) КАК ОбщийВес
	|ПОМЕСТИТЬ Статистика_%ИмяОбъектаПоиска%
	|ИЗ
	|	(ВЫБРАТЬ ПЕРВЫЕ 5
	|		ВидДокумента.%ИмяОбъектаПоиска% КАК ОбъектПоиска,
	|		1 КАК Использование
	|	ИЗ
	|		Документ." + ИмяВидаОбъекта + " КАК ВидДокумента
	|	ГДЕ
	|		НЕ ВидДокумента.ПометкаУдаления
	|		" + ?(ОграничитьПоАвтору,"И (ВидДокумента.Автор = &Автор)","") + "
	|			%ДополнительныеУсловия%
	|	
	|	УПОРЯДОЧИТЬ ПО
	|		ВидДокумента.Дата УБЫВ) КАК СтатистикаСДатами
	|
	|СГРУППИРОВАТЬ ПО
	|	СтатистикаСДатами.ОбъектПоиска
	|
	|УПОРЯДОЧИТЬ ПО
	|	ОбщийВес УБЫВ
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	СУММА(Статистика.ОбщийВес) КАК ОбщийВес
	|ПОМЕСТИТЬ ОбщееКоличество_%ИмяОбъектаПоиска%
	|ИЗ
	|	Статистика_%ИмяОбъектаПоиска% КАК Статистика
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	ВложенныйЗапрос.ОбъектПоиска
	|ИЗ
	|	(ВЫБРАТЬ
	|		Статистика.ОбъектПоиска КАК ОбъектПоиска,
	|		100 * Статистика.ОбщийВес / ОбщееКоличество.ОбщийВес КАК ВесПоСтатистике
	|	ИЗ
	|		Статистика_%ИмяОбъектаПоиска% КАК Статистика
	|			ЛЕВОЕ СОЕДИНЕНИЕ ОбщееКоличество_%ИмяОбъектаПоиска% КАК ОбщееКоличество
	|			ПО ИСТИНА) КАК ВложенныйЗапрос
	|ГДЕ
	|	ВложенныйЗапрос.ВесПоСтатистике > 50";
	
	Возврат ТекстЗапроса;
	
КонецФункции

Функция ТекстЗапросаСвойствАвтозаполнения(ОбъектСсылка, СтруктураСвойствАвтозаполнения)
	
	ТекстЗапроса			= "";
	ДополнительныеУсловия	= "";
	
	ИмяВидаОбъекта					= ИмяВидаОбъекта(ОбъектСсылка);
	ПараметрыЗапроса				= СтруктураСвойствАвтозаполнения.ПараметрыЗапроса;
	ПоляЗапроса						= СтруктураСвойствАвтозаполнения.ПоляЗапроса;
	
	// Сформируем текст дополнительных условий
	Для Каждого ПараметрЗапроса Из ПараметрыЗапроса Цикл 
		ДополнительныеУсловия = ДополнительныеУсловия + "И" + " " + ПараметрЗапроса + " " + "=" + " " + "&" + ПараметрЗапроса + Символы.ПС;
		
	КонецЦикла;
	
	ШаблонТекстаЗапроса = ШаблонЗапросаСвойствАвтозаполнения(ИмяВидаОбъекта,
												ЕстьРеквизитОбъекта(ОбъектСсылка, "Автор"));
	
	// Сформируем текст пакета запросов
	Для Каждого ПолеЗапроса Из ПоляЗапроса Цикл 
		ТекстЗапросаПустой = ПустаяСтрока(ТекстЗапроса);
		
		Если НЕ ТекстЗапросаПустой Тогда
			ТекстЗапроса = ТекстЗапроса + Символы.ПС + ";" + Символы.ПС + "////////////////////////////////////////////////////////////////////////////////" + Символы.ПС;
			
		КонецЕсли;
		
		ТекстЗапросаСОбъектомПоиска				= СтрЗаменить(ШаблонТекстаЗапроса, "%ИмяОбъектаПоиска%", ПолеЗапроса);
		ТекстЗапросаСОбъектомПоискаИПараметрами	= СтрЗаменить(ТекстЗапросаСОбъектомПоиска, "%ДополнительныеУсловия%", ДополнительныеУсловия);
		
		ТекстЗапроса = ТекстЗапроса + ТекстЗапросаСОбъектомПоискаИПараметрами;
		
	КонецЦикла;
	
	Возврат ТекстЗапроса;
	
КонецФункции

#КонецОбласти

#Область ЗаменаСсылокПоИнформационнойБазе

// Заменяет ссылки по информационной базе
// Параметры:
//	ПарыЗамены - Соответствие - ключи содержат замещаемых, значения содержат заменители
//	Исключения - Массив - необязателен, значения типа ОбъектМетаданных, в экземплярах которых замены проводить нельзя.
Процедура ЗаменитьСсылки(ПарыЗамен, Исключения = Неопределено) Экспорт
	Английский = Метаданные.СвойстваОбъектов.ВариантВстроенногоЯзыка.Английский;
	ДвиженияССубконтоИмя = ?(Метаданные.ВариантВстроенногоЯзыка = Английский, ".RecordsWithExtDimensions", ".ДвиженияССубконто");
	
	Если Исключения = Неопределено Тогда
		Исключения = Новый Массив;
	КонецЕсли;
	
	// [ссылающийся объект](.Метаданные, .Замены[(.Замещаемое, .Заменитель)], .ТипыЗамещаемых[]).
	ИндексЗамены = ИндексЗамены(ПарыЗамен);
	КешПолей = Новый Соответствие;
	// Обходим индекс и в каждом ключе-объекта полностью замещаем все ссылки, подлежащие замене.
	Для Каждого УзелЗамены Из ИндексЗамены Цикл
		Ссылка = УзелЗамены.Ключ;
		МетаданныеУзла = УзелЗамены.Значение.Метаданные;
		Замены = УзелЗамены.Значение.Замены;
		ТипыЗамещаемых = УзелЗамены.Значение.ТипыЗамещаемых;
		
		Если Исключения.Найти(МетаданныеУзла) <> Неопределено Тогда
			Продолжить;
		КонецЕсли;
		
		Если ЭтоСсылочныйОбъектМетаданных(МетаданныеУзла) Тогда
			// любой ссылочный объект
			ПолноеИмя = МетаданныеУзла.ПолноеИмя();
			ОбъектДанных = Ссылка.ПолучитьОбъект();
			ИменаПолей = ИменаПолейСТипами(КешПолей, ПолноеИмя, ТипыЗамещаемых, "Ссылка, Ref");
			ЗаменитьЗначения(ОбъектДанных, ИменаПолей, Замены);
			// табчасти объекта
			ЗаменитьВТабчастях(
				КешПолей, МетаданныеУзла.ТабличныеЧасти, ОбъектДанных, ПолноеИмя, Замены, ТипыЗамещаемых, Исключения);
			// стандартные табчасти планов
			Если Метаданные.ПланыСчетов.Содержит(МетаданныеУзла) Или Метаданные.ПланыВидовРасчета.Содержит(МетаданныеУзла) Тогда
				ЗаменитьВТабчастях(
					КешПолей, МетаданныеУзла.СтандартныеТабличныеЧасти, ОбъектДанных, ПолноеИмя, Замены, ТипыЗамещаемых, Исключения);
			КонецЕсли;
			// пишем сам объект
			ЗаписатьДанные(ОбъектДанных);
			ОбъектДанных = Неопределено;
		ИначеЕсли Метаданные.Константы.Содержит(МетаданныеУзла) Тогда
			// значения в константах
			Константа = Константы[МетаданныеУзла.Имя];
			Константа.Установить(НовоеЗначение(Константа.Получить(), Замены));
		ИначеЕсли Метаданные.РегистрыСведений.Содержит(МетаданныеУзла) Тогда
			// необъектные таблицы
			ИменаПолей = ИменаПолейСТипами(КешПолей, МетаданныеУзла.ПолноеИмя(), ТипыЗамещаемых);
			Отборы = ОтборыРегистраСведений(МетаданныеУзла, Ссылка);
			Набор = НаборЗаписей(РегистрыСведений[МетаданныеУзла.Имя], Отборы);
			
			Таблица = Набор.Выгрузить();
			Набор.Очистить();
			ЗаписатьДанные(Набор);

			ЗаменитьЗначения(Таблица[0], ИменаПолей, Замены);
			Для Каждого ИмяПоля Из ИменаПолей Цикл
				Если Не Отборы.Свойство(ИмяПоля) Тогда
					Продолжить;
				КонецЕсли;
				Набор.Отбор[ИмяПоля].Установить(НовоеЗначение(Отборы[ИмяПоля], Замены));
			КонецЦикла;
			Набор.Загрузить(Таблица);
			ЗаписатьДанные(Набор);
		КонецЕсли;
		// обработка движений документа
		Если Метаданные.Документы.Содержит(МетаданныеУзла) Тогда
			Для Каждого Движение Из МетаданныеУзла.Движения Цикл
				ДопТаблица = "";
				Если Исключения.Найти(Движение) <> Неопределено Тогда
					Продолжить;
				КонецЕсли;
				Если Метаданные.РегистрыНакопления.Содержит(Движение) Тогда
					Регистр = РегистрыНакопления[Движение.Имя];
				ИначеЕсли Метаданные.РегистрыСведений.Содержит(Движение) Тогда
					Регистр = РегистрыСведений[Движение.Имя];
				ИначеЕсли Метаданные.РегистрыБухгалтерии.Содержит(Движение) Тогда
					ДопТаблица = ДвиженияССубконтоИмя;
					Регистр = РегистрыБухгалтерии[Движение.Имя];
				ИначеЕсли Метаданные.РегистрыРасчета.Содержит(Движение) Тогда
					Регистр = РегистрыРасчета[Движение.Имя];
				КонецЕсли;
				ЗаменитьВПодчиненномРегистре(КешПолей, Регистр, Ссылка, Движение.ПолноеИмя() + ДопТаблица, Замены, ТипыЗамещаемых);
			КонецЦикла;
			// обработка последовательностей, включающих документ
			Для Каждого Движение Из Метаданные.Последовательности Цикл
				Если Исключения.Найти(Движение) <> Неопределено Тогда
					Продолжить;
				КонецЕсли;
				Если Движение.Документы.Содержит(МетаданныеУзла) Тогда
					ЗаменитьВПодчиненномРегистре(
						КешПолей, Последовательности[Движение.Имя], Ссылка, Движение.ПолноеИмя(), Замены, ТипыЗамещаемых);
				КонецЕсли;
			КонецЦикла;
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

// Строим соответствие вида [ссылающийся объект](.Метаданные, .Замены[(.Замещаемое, .Заменитель)], .ТипыЗамещаемых[])
// в итоге представляем результаты поиска по ссылкам в индексе с ключом-объектом, содержащим замещаемые ссылки.
Функция ИндексЗамены(ПарыЗамен)
	
	СписокСсылок = Новый Массив;
	Для Каждого Пара Из ПарыЗамен Цикл
		СписокСсылок.Добавить(Пара.Ключ);
	КонецЦикла;
	РезультатыПоиска = НайтиПоСсылкам(СписокСсылок);
	// (.Ссылка: исходная ссылка; .Данные: ссылающийся объект; .Метаданные: метаданные ссылающегося объекта).
	
	ИндексЗамены = Новый Соответствие;
	Для Каждого Результат Из РезультатыПоиска Цикл
		УзелЗамены = ИндексЗамены[Результат.Данные];
		Если Неопределено = УзелЗамены Тогда
			УзелЗамены =
				Новый Структура("Метаданные, Замены, ТипыЗамещаемых", Результат.Метаданные, Новый Массив, Новый Массив);
			ИндексЗамены.Вставить(Результат.Данные, УзелЗамены);
		КонецЕсли;

		УзелЗамены.Замены.Добавить(
			Новый Структура("Замещаемое, Заменитель", Результат.Ссылка, ПарыЗамен[Результат.Ссылка]));

		ТипЗамещаемого = ТипЗнч(Результат.Ссылка);
		Если Неопределено = УзелЗамены.ТипыЗамещаемых.Найти(ТипЗамещаемого) Тогда
			УзелЗамены.ТипыЗамещаемых.Добавить(ТипЗамещаемого);
		КонецЕсли;
	КонецЦикла;
	
	Возврат ИндексЗамены;
КонецФункции

Процедура ЗаменитьВТабчастях(КешПолей, ОписанияТабчастей, Объект, ИмяОсновнойТаблицы, Замены, ТипыЗамещаемых, Исключения)
	Для Каждого Описание Из ОписанияТабчастей Цикл
		Если Исключения.Найти(Описание) <> Неопределено Тогда
			Продолжить;
		КонецЕсли;
		ИменаПолей = ИменаПолейСТипами(КешПолей, ИмяОсновнойТаблицы + "." + Описание.Имя, ТипыЗамещаемых, "Ссылка, Ref");
		Для Каждого Табстрока Из Объект[Описание.Имя] Цикл
			ЗаменитьЗначения(Табстрока, ИменаПолей, Замены);
		КонецЦикла;
	КонецЦикла;
КонецПроцедуры

Процедура ЗаменитьВПодчиненномРегистре(КешПолей, МенеджерРегистра, Ссылка, ИмяТаблицыРегистра, Замены, ТипыЗамещаемых)
	ИменаПолей = ИменаПолейСТипами(КешПолей, ИмяТаблицыРегистра, ТипыЗамещаемых, "Регистратор, Recorder");
	Набор = НаборЗаписей(МенеджерРегистра, Новый Структура("Регистратор", Ссылка));
	ЗначениеЗаменено = Ложь;
	Для Каждого Запись Из Набор Цикл
		ЗаменитьЗначения(Запись, ИменаПолей, Замены, ЗначениеЗаменено);
	КонецЦикла;
	ЗаписатьДанные(Набор, ЗначениеЗаменено);
КонецПроцедуры

Функция ИменаПолейСТипами(КешПолейТаблиц, ИмяТаблицы, ТипыДанных, ИменаИсключений = "")
	ИменаПолей = Новый Массив;
	
	ТекстЗапроса = СтрЗаменить("ВЫБРАТЬ * ИЗ ТаблицаВыборки КАК Т ГДЕ ЛОЖЬ", "ТаблицаВыборки", ИмяТаблицы);
	ПоляТаблицы = КешПолейТаблиц.Получить(ИмяТаблицы);
	Если Неопределено = ПоляТаблицы Тогда
		Запрос = Новый Запрос(ТекстЗапроса);
		ПоляТаблицы = Запрос.Выполнить().Колонки;
		КешПолейТаблиц.Вставить(ИмяТаблицы, ПоляТаблицы);
	КонецЕсли;
	
	Исключения = Новый Структура(ИменаИсключений);
	Для Каждого Поле Из ПоляТаблицы Цикл
		Если Исключения.Свойство(Поле.Имя) Тогда
			Продолжить;
		КонецЕсли;
		
		Для Каждого ТипДанных Из ТипыДанных Цикл
			Если Поле.ТипЗначения.СодержитТип(ТипДанных) И Неопределено = ИменаПолей.Найти(Поле.Имя) Тогда
				ИменаПолей.Добавить(Поле.Имя);
			КонецЕсли;
		КонецЦикла;
	КонецЦикла;
	
    Возврат ИменаПолей;
КонецФункции

Процедура ЗаменитьЗначения(Данные, ИменаПолей, Замены, Заменено = Ложь)
	Для Каждого ИмяПоля Из ИменаПолей Цикл
		НовоеЗначение = НовоеЗначение(Данные[ИмяПоля], Замены);
		Если НовоеЗначение <> Данные[ИмяПоля] Тогда;
			Заменено = Истина;
			Данные[ИмяПоля] = НовоеЗначение;
		КонецЕсли;
	КонецЦикла;
КонецПроцедуры

Функция НовоеЗначение(СтароеЗначение, Замены)
	Для Каждого Замена Из Замены Цикл
		Если СтароеЗначение = Замена.Замещаемое Тогда
			Возврат Замена.Заменитель;
		КонецЕсли;
	КонецЦикла;
	Возврат СтароеЗначение;
КонецФункции

Процедура ЗаписатьДанные(Данные, Принудительно = Ложь)
	Если Данные.Модифицированность() Или Принудительно Тогда
		Данные.ОбменДанными.Загрузка = Истина;
		Данные.Записать();
	КонецЕсли;
КонецПроцедуры

Функция ОтборыРегистраСведений(МетаданныеРегистра, Запись)
	Отборы = Новый Структура;
	Если МетаданныеРегистра.ПериодичностьРегистраСведений <> Метаданные.СвойстваОбъектов.ПериодичностьРегистраСведений.Непериодический Тогда
		Отборы.Вставить("Период", Запись.Период);
	КонецЕсли;
	Для Каждого Измерение Из МетаданныеРегистра.Измерения Цикл
		Отборы.Вставить(Измерение.Имя, Запись[Измерение.Имя]);
	КонецЦикла;
	Возврат Отборы;
КонецФункции

Функция НаборЗаписей(МенеджерРегистра, Отборы)
	Набор = МенеджерРегистра.СоздатьНаборЗаписей();
	Для Каждого Отбор Из Отборы Цикл
		Набор.Отбор[Отбор.Ключ].Установить(Отбор.Значение);
	КонецЦикла;
	Набор.Прочитать();
	Возврат Набор;
КонецФункции

Функция ЭтоСсылочныйОбъектМетаданных(ОбъектМетаданных)
	Возврат Метаданные.Справочники.Содержит(ОбъектМетаданных)
		ИЛИ Метаданные.Документы.Содержит(ОбъектМетаданных)
		ИЛИ Метаданные.Перечисления.Содержит(ОбъектМетаданных)
		ИЛИ Метаданные.ПланыВидовХарактеристик.Содержит(ОбъектМетаданных)
		ИЛИ Метаданные.ПланыСчетов.Содержит(ОбъектМетаданных)
		ИЛИ Метаданные.ПланыВидовРасчета.Содержит(ОбъектМетаданных)
		ИЛИ Метаданные.БизнесПроцессы.Содержит(ОбъектМетаданных)
		ИЛИ Метаданные.Задачи.Содержит(ОбъектМетаданных)
		ИЛИ Метаданные.ПланыОбмена.Содержит(ОбъектМетаданных);
КонецФункции

#КонецОбласти

#Область ОтладочныеМетоды

// Показать произвольную выборку данных в отладчике
// Пример:
//	ОбщегоНазначенияУТ.ЗапросВыполнитьВыгрузить("выбрать * 
//		из Справочник.Валюты где Валюты.Код = &Код", Новый Структура("Код", "810"))
//
Функция ЗапросВыполнитьВыгрузить(ТекстЗапроса, ПараметрыЗапроса = Неопределено, МенеджерВременныхТаблиц = Неопределено) Экспорт
	
	Запрос = Новый Запрос(ТекстЗапроса);
	
	Если МенеджерВременныхТаблиц <> Неопределено Тогда
		Запрос.МенеджерВременныхТаблиц = МенеджерВременныхТаблиц;
	КонецЕсли;
	
	Если ЗначениеЗаполнено(ПараметрыЗапроса) Тогда
		Для Каждого Параметр Из ПараметрыЗапроса Цикл
			Запрос.УстановитьПараметр(Параметр.Ключ, Параметр.Значение);
		КонецЦикла;
	КонецЕсли;
	
	Возврат Запрос.Выполнить().Выгрузить();
	
КонецФункции

// Показать временную таблицу из менеджера временных таблиц.
// Используется для просмотра временных таблиц в отладчике.
// Пример вызова функции:
//	ОбщегоНазначенияУТ.ПоказатьВременнуюТаблицу(МенеджерВременныхТаблиц, "ТаблицаТоваров")
//
Функция ПоказатьВременнуюТаблицу(МенеджерВременныхТаблиц, ИмяВременнойТаблицы) Экспорт
	
	Возврат ЗапросВыполнитьВыгрузить("ВЫБРАТЬ * ИЗ " + ИмяВременнойТаблицы,, МенеджерВременныхТаблиц);
	
КонецФункции

#КонецОбласти

#Область СистемныеОпределяютПоведениеКонфигурации

// Проверяет соблюдение условий открытия базовой версии конфигурации в режиме Предприятие.
//
// Возвращаемое значение:
// 	- если текущая версия конфигурации не является базовой, то возвращается значение Истина.
//  - если текущая версия конфигурации является базовой, то возвращается значение Истина
//	  в случае, если ИБ развернута в файловом варианте и запускается в однопользовательском режиме.
//
Функция ВозможенЗапускБазовойВерсии() Экспорт
	
	Если НЕ СтандартныеПодсистемыСервер.ЭтоБазоваяВерсияКонфигурации() Тогда
		Возврат Истина; // ОК: это не базовая версия
	КонецЕсли;
	
	Если НЕ ОбщегоНазначения.ИнформационнаяБазаФайловая(СтрокаСоединенияИнформационнойБазы()) Тогда
		Возврат Ложь; // не файловая ИБ
	КонецЕсли;
	
	СеансыИнформационнойБазы = ПолучитьСеансыИнформационнойБазы();
	НомерТекущегоСеанса		 = НомерСеансаИнформационнойБазы();
	ЗапрещенныеПриложения	 = ",1CV8,1CV8C,WebClient,WSConnection,COMConnection,";
	
	Для Каждого СеансИБ Из СеансыИнформационнойБазы Цикл
		
		Если СеансИБ.НомерСеанса = НомерТекущегоСеанса Тогда
			Продолжить;
		ИначеЕсли Найти(ЗапрещенныеПриложения, "," + СеансИБ.ИмяПриложения + ",") > 0 Тогда
			Возврат Ложь; // открыты другие сеансы 1С:Предприятия
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат Истина; // ОК: это файловая ИБ в однопользовательском режиме
	
КонецФункции

#КонецОбласти

#Область Версионирование

// Возвращает признак использования версионирования для указанного объекта метаданных.
//
// Параметры:
//  ПолноеИмяОбъекта - Строка - полный путь к объекту метаданных. Например, "Справочник.Номенклатура".
//
// Возвращаемое значение:
//  Булево - зеначение признака.
//
Функция ИспользоватьВерсионированиеОбъекта(ПолноеИмяОбъекта) Экспорт
	
	Возврат ПолучитьФункциональнуюОпцию("ИспользоватьВерсионированиеОбъекта",
		Новый Структура("ТипВерсионируемогоОбъекта", ПолноеИмяОбъекта));
		
КонецФункции	

// Включает версионирования для указанного объекта метаданных.
//
// Параметры:
//  ПолноеИмяОбъекта - Строка - полный путь к объекту метаданных. Например, "Справочник.Номенклатура".
//	ВариантВерсионирования - Строка - имя значения перечисления ВариантыВерсионированияОбъектов.
//
// Возвращаемое значение:
//  Булево - Истина, если для указанного объекта было включено версионирование.
//
Функция ВключитьВерсионированиеОбъекта(ПолноеИмяОбъекта, ВариантВерсионирования = "ВерсионироватьПриЗаписи") Экспорт
	
	ВерсионированиеВключено = Ложь;
	
	ПеречислениеВариантВерсионирования = Перечисления.ВариантыВерсионированияОбъектов[ВариантВерсионирования];
	
	Если НЕ ИспользоватьВерсионированиеОбъекта(ПолноеИмяОбъекта) Тогда
		
		ВерсионированиеОбъектов.ЗаписатьНастройкуВерсионированияПоОбъекту(ПолноеИмяОбъекта, ПеречислениеВариантВерсионирования);
		ВерсионированиеВключено = Истина;
		
	КонецЕсли;
	
	Возврат ВерсионированиеВключено;
	
КонецФункции

// Включает версионирования для указанных объектов метаданных.
//
// Параметры:
//	Объекты - Соответствие
//  	Ключ 	 - Строка - полный путь к объекту метаданных. Например, "Справочник.Номенклатура".
//		Значение - Строка - имя значения перечисления ВариантыВерсионированияОбъектов.
//
// Возвращаемое значение:
//  Булево - Истина, если хотя бы для одного из указанных объектов было включено версионирование.
//
Функция ВключитьВерсионированиеОбъектов(Объекты) Экспорт
	
	ВерсионированиеВключено = Ложь;
	
	Для Каждого КлючИЗначение Из Объекты Цикл
		ВерсионированиеВключено =
			ВключитьВерсионированиеОбъекта(КлючИЗначение.Ключ, КлючИЗначение.Значение)
			ИЛИ ВерсионированиеВключено;
	КонецЦикла;
	
	Возврат ВерсионированиеВключено;
	
КонецФункции

#КонецОбласти

#Область Константы

// Возвращает состав набор констант.
//
// Параметры:
//	Набор - КонстантыНабор - набор констант.
//
// Возвращаемое значение:
//  Структура - Ключ - имя константы из набора.
//
Функция ПолучитьСтруктуруНабораКонстант(Набор) Экспорт
	
	Результат = Новый Структура;
	
	Для Каждого МетаКонстанта Из Метаданные.Константы Цикл
		Если ЕстьРеквизитОбъекта(Набор, МетаКонстанта.Имя) Тогда
			Результат.Вставить(МетаКонстанта.Имя);
		КонецЕсли;
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

#КонецОбласти

#Область Перечисления

// Получает список выбора для указанного перечисления.
//
// Параметры:
//	ИмяПеречисления 	- Строка - имя перечисления как оно задано в конфигураторе.
//	ДанныеВыбора 		- Список значений - сформированный список выбора перечисления.
//	Параметры 			- Структура - подробнее см. ОбработкаПолученияДанныхВыбора
//	ИсключаемыеЗначения - Массив - значения перечисления, не включаемые в список выбора.
//
Процедура ПолучитьСписокВыбораПеречисления(ИмяПеречисления, ДанныеВыбора, Параметры, ИсключаемыеЗначения) Экспорт
	
	ДанныеВыбора = Новый СписокЗначений; // результат
	
	Запрос = Новый Запрос;
	ТекстЗапроса =
	"ВЫБРАТЬ
	|	ЗначенияПеречисления.Ссылка КАК Ссылка,
	|	ПРЕДСТАВЛЕНИЕ(ЗначенияПеречисления.Ссылка) КАК Представление
	|ИЗ
	|	Перечисление.%ИмяПеречисления% КАК ЗначенияПеречисления
	|ГДЕ
	|	НЕ ЗначенияПеречисления.Ссылка В (&ИсключаемыеЗначения)
	|	//%ТекстОтборПоПараметрам%
	|
	|УПОРЯДОЧИТЬ ПО
	|	ЗначенияПеречисления.Порядок";
	
	Запрос.УстановитьПараметр("ИсключаемыеЗначения", ИсключаемыеЗначения);
	
	Если Параметры.Отбор.Свойство("Ссылка") Тогда
		ТекстОтборПоПараметрам = "ЗначенияПеречисления.Ссылка В (&ОтборПоСсылке)";
		ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "//%ТекстОтборПоПараметрам%", ТекстОтборПоПараметрам);
		
		Запрос.УстановитьПараметр("ОтборПоСсылке", Параметры.Отбор.Ссылка);
	КонецЕсли;
	
	Запрос.Текст = СтрЗаменить(ТекстЗапроса, "%ИмяПеречисления%", ИмяПеречисления);
	
	Выборка = Запрос.Выполнить().Выбрать();
	
	Пока Выборка.Следующий() Цикл
		
		Если НЕ ЗначениеЗаполнено(Параметры.СтрокаПоиска)
		 ИЛИ Найти(НРег(Выборка.Представление), НРег(Параметры.СтрокаПоиска)) = 1 Тогда
			ДанныеВыбора.Добавить(Выборка.Ссылка);
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

#КонецОбласти

#Область КонтактнаяИнформация

// Актуализирует значения полей КИ из ее представления.
//
//  Параметры:
//		АдресПредставление - представление КИ
//		АдресЗначенияПолей - служебная информация, значения полей КИ
//		ТипКИ			   - тип контактной информации (Перечисления.ТипыКонтактнойИнформации).
//
Процедура ЗаполнитьЗначенияПолейКИПоПредставлению(Представление, ЗначенияПолей, ТипКИ = Неопределено) Экспорт
	
	Если ТипКИ = Неопределено Тогда
		ТипКИ = Перечисления.ТипыКонтактнойИнформации.Адрес;
	КонецЕсли;
	
	// Сохраним комментарий из старых значений полей.
	Комментарий = СокрЛП(УправлениеКонтактнойИнформацией.КомментарийКонтактнойИнформации(ЗначенияПолей));
	
	// Сформируем значения полей КИ по представлению.
	ЗначенияПолей = УправлениеКонтактнойИнформациейСлужебныйВызовСервера.КонтактнаяИнформацияXMLПоПредставлению(Представление,	ТипКИ);;
	
	Если ЗначениеЗаполнено(Комментарий) Тогда
		// Вернем комментарий обратно.
		УправлениеКонтактнойИнформацией.УстановитьКомментарийКонтактнойИнформации(ЗначенияПолей, Комментарий);
	КонецЕсли;
	
КонецПроцедуры

#КонецОбласти

#Область Прочее

Процедура ОбработатьВложенныеПоля(Форма, ИмяЭлемента, МассивЭлементов, Структура)
	
	Если ТипЗнч(Форма.Элементы[ИмяЭлемента]) = Тип("ТаблицаФормы")
		ИЛИ ТипЗнч(Форма.Элементы[ИмяЭлемента]) = Тип("ГруппаФормы") Тогда
		Если ТипЗнч(Форма.Элементы[ИмяЭлемента]) = Тип("ТаблицаФормы") Тогда
			Структура.Вставить(ИмяЭлемента, Новый Массив);
			ОбработатьПоляТаблицыФормы(Форма, ИмяЭлемента, Структура[ИмяЭлемента]);
		КонецЕсли;
		Для Каждого Элемент Из Форма.Элементы[ИмяЭлемента].ПодчиненныеЭлементы Цикл
			Если ТипЗнч(Форма.Элементы[Элемент.Имя]) = Тип("ПолеФормы") Тогда
				Если МассивЭлементов.Найти(Элемент.Имя) <> Неопределено Тогда
					Продолжить;
				КонецЕсли;
				МассивЭлементов.Добавить(Элемент.Имя);
			ИначеЕсли ТипЗнч(Форма.Элементы[Элемент.Имя]) = Тип("ГруппаФормы") Тогда
				ОбработатьВложенныеПоля(Форма, Элемент.Имя, МассивЭлементов, Структура);
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	
КонецПроцедуры

Процедура ОбработатьПоляТаблицыФормы(Форма, ИмяЭлемента, МассивЭлементов)
	
	Если ТипЗнч(Форма.Элементы[ИмяЭлемента]) = Тип("ТаблицаФормы")
		ИЛИ ТипЗнч(Форма.Элементы[ИмяЭлемента]) = Тип("ГруппаФормы") Тогда
		Для Каждого Элемент Из Форма.Элементы[ИмяЭлемента].ПодчиненныеЭлементы Цикл
			Если ТипЗнч(Форма.Элементы[Элемент.Имя]) = Тип("ПолеФормы") Тогда
				Если МассивЭлементов.Найти(Элемент.Имя) <> Неопределено Тогда
					Продолжить;
				КонецЕсли;
				МассивЭлементов.Добавить(Элемент.Имя);
			ИначеЕсли ТипЗнч(Форма.Элементы[Элемент.Имя]) = Тип("ГруппаФормы") Тогда
				ОбработатьПоляТаблицыФормы(Форма, Элемент.Имя, МассивЭлементов);
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	
КонецПроцедуры

// Функция возвращает идентификатор конфигурации.
// Длина идентификатора не должна превышать 8 символов.
//
Функция ИДКонфигурации() Экспорт
	
	// {УП}
	Возврат "УП2"; // в конфигурации 1С:ERP
	// {/УП}
	Возврат "УТ11"; // в конфигурации УТ11
	
КонецФункции

#КонецОбласти

#КонецОбласти
