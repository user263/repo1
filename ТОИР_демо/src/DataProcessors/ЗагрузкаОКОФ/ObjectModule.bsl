#Если Сервер Или ТолстыйКлиентОбычноеПриложение Или ВнешнееСоединение Тогда


#Область ОписаниеПеременных

Перем ВременныеФайлы;

// Пространства имен (xmlns)
Перем xmlnsXML;
перем xmlnsV8XDTO;
Перем xmlnsОписанияТиповКлассификаторов;
Перем xmlnsКлассификатор;

Перем ФабрикаXDTOКлассификаторов;
Перем МассивОбщихПакетовXDTO;
Перем xdtoТипыКлассификаторов;

Перем МетаданныеКонфигурации;
Перем СвойстваОбъектовМетаданных;

#КонецОбласти

#Область ПрограммныйИнтерфейс

// Загружает классификатор из файла или временного хранилища.
//
// Параметры:
//  ИмяФайла - Строка - путь к файлу классификатора.
//  Хранение - Строка - адрес временного хранилища
//  УникальныйИдентификатор - УникальныйИдентификатор - 
//   уникальный идентификатор экземпляра формы,
//   из которой инициирована загрузка.
//
Процедура ДобавитьНовыйКлассификатор(ИмяФайла, Хранение, УникальныйИдентификатор) Экспорт
	
	Файл = Новый Файл(ИмяФайла);
	
	Если ЭтоАдресВременногоХранилища(Хранение) Тогда
		
		ИмяВременногоФайла = ПолучитьИмяВременногоФайла(Файл.Расширение);
		ДвоичныеДанные = ПолучитьИзВременногоХранилища(Хранение);
		ДвоичныеДанные.Записать(ИмяВременногоФайла);
		РабФайл = Новый Файл(ИмяВременногоФайла);
		ВременныеФайлы.Добавить(ИмяВременногоФайла);
		
	Иначе
		РабФайл = Файл;
	КонецЕсли;
	
    ДобавитьКлассификатор(РабФайл, РабФайл.ПолноеИмя, ,УникальныйИдентификатор);
	
КонецПроцедуры

// Записывает в базу загруженные классификаторы.
//
// Параметры:
//  Прогресс - Число - значение индикатора формы прогресса.
//
Процедура ЗаписатьКлассификаторы(Прогресс = 0) Экспорт
	
	xdtoТипКлассификатора = xdtoТипКлассификатора(ИдентификаторКлассификатора);
		
	ОбъектЗагрузки = ПолучитьСодержаниеКлассификатора(Истина);
		
	СохранитьКлассификатор(ОбъектЗагрузки,
		xdtoТипКлассификатора.ИмяСправочника,
		УдалятьНеактуальные,
		Неопределено,
		xdtoТипКлассификатора.ИмяРеквизитаПолнНаименование,
		Прогресс);
	
КонецПроцедуры

#КонецОбласти

#Область СлужебныйПрограммныйИнтерфейс

// Функция возвращает объект-описатель типа классификатора.
//
// Параметры:
//  Идентификатор - Строка; идентификатор типа.
//
// Возвращаемое значение:
//  ОбъектXDTO типа {xmlnsОписанияТиповКлассификаторов}ClassifierTypeType.
// Содержит свойства: xmlid - идентификатор (атрибут
// {http://www.w3.org/XML/1998/namespace}id), ИмяСправочника - строка
// (<catalog-name>), ИмяРеквизитаПолнНаименование - строка
// (<full-name-property>). 
//  Неопределено, если тип не найден.
//
Функция xdtoТипКлассификатора(Идентификатор) Экспорт
	Попытка
		МакетТипов ="<?xml version=""1.0"" encoding=""Windows-1251""?>
					|<classifier-type-list xmlns=""urn:uuid:101fa9a0-ea86-11dc-afc4-0002a5d5c51b"">
					|	<classifier-type xml:id=""ОКОФ"">
					|		<catalog-name>ОбщероссийскийКлассификаторОсновныхФондов</catalog-name>
					|		<full-name-property>НаименованиеГруппировки</full-name-property>
					|		<filename-mask>okof.xml</filename-mask>
					|		<filename-mask>okof.aml</filename-mask>
					|		<filename-mask>okof.finf</filename-mask>
					|		<filename-mask>okof.zip</filename-mask>
					|	</classifier-type>
			   		|</classifier-type-list>";

		xdtoТипыКлассификаторов = xdtoПрочитать(МакетТипов,
			ФабрикаXDTOКлассификаторов(),
			xmlnsОписанияТиповКлассификаторов, "ClassifierTypeListType");

		Возврат xdtoТипыКлассификаторов().Получить("ТипыКлассификаторов[xmlid='" + Идентификатор + "']");
	Исключение
		Возврат Неопределено
	КонецПопытки;
КонецФункции  

Функция ПолучитьСодержаниеКлассификатора(ЧитатьПринудительно = Ложь) Экспорт
	
	Если ЭтоАдресВременногоХранилища(АдресВХранилище) Тогда
		Данные = ПолучитьИзВременногоХранилища(АдресВХранилище);
	КонецЕсли;
	
	Если Данные = Неопределено Тогда
		Возврат Неопределено // не может такого быть
	КонецЕсли;
	
	Если Данные.Содержание = Неопределено Тогда
		Если Не ЧитатьПринудительно Тогда
			Возврат Неопределено;
		КонецЕсли;
		
		ТекущееСостояние = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Чтение содержимого классификатора %1…'"),
			НаименованиеКлассификатора);
		Если ТипЗнч(Данные.СтрокаXMLИлиФайл) = Тип("Строка") Тогда
			ЧтениеXML = Новый ЧтениеXML;
			ЧтениеXML.УстановитьСтроку(Данные.СтрокаXMLИлиФайл)
		Иначе
			ЧтениеXML = Новый(Данные.ТипЧитателя);
			ЧтениеXML.ОткрытьФайл(Данные.СтрокаXMLИлиФайл.ПолноеИмя);
		КонецЕсли; 
		ЧтениеXML.ПерейтиКСодержимому();
		ЧтениеXML.Прочитать(); //classifier
		Пока ЧтениеXML.ТипУзла = ТипУзлаXML.НачалоЭлемента
		 Или ЧтениеXML.Прочитать() Цикл
			Если ЧтениеXML.ТипУзла = ТипУзлаXML.НачалоЭлемента Тогда
				Если ЧтениеXML.URIПространстваИмен = xmlnsКлассификатор
				   И ЧтениеXML.ЛокальноеИмя = "data" Тогда
					
					Данные.Содержание = xdtoПрочитать(ЧтениеXML,
						Данные.ФабрикаXDTO,
						xmlnsКлассификатор, "ClassifierDataType");
					
				Иначе
					ЧтениеXML.Пропустить();
				КонецЕсли;
			КонецЕсли;
		КонецЦикла;
		ТекущееСостояние = "";
	КонецЕсли;
	Возврат Данные.Содержание
КонецФункции // ПолучитьСодержаниеКлассификатора() 

// Процедура, инициирующая сохранение классификатора из дерева значений
// или объекта XDTO в справочник. Вызывается из процедуры
// ЗаписатьКлассификаторыВФорме формы помощника.
//
// Параметры:
//  Источник     - ДеревоЗначений, ОбъектXDTO; объект-источник, содержащий
//                 классификатор;
//  ИмяСправочника - Строка; идентификатор справочника, в который нужно
//                 записать классификатор;
//  УдалятьНеактуальные - Булево; означает, что после загрузки справочника
//                 нужно пометить на удаление оставшиеся элементы. Эффективно
//                 только если загружается классификатор целиком;
//  Владелец     - Ссылка; ссылка на элемент справочника-владельца, который
//                 будет применен для всего классификатора; //!!!
//  ИмяРеквизитаПолнНаименование - Строка; идентификатор реквизита справочника-
//                 приемника, в который дополнительно к Наименованию будет
//                 записываться наименование позиции классификатора;
//  Прогресс     - Число; переменная-реквизит формы, служащий источником
//                 данных для элемента управления Индикатор (свойство
//                 максимальное значение уже должно быть установлено).
//
Процедура СохранитьКлассификатор(Источник, ИмяСправочника, УдалятьНеактуальные, Владелец, ИмяРеквизитаПолнНаименование, Прогресс) Экспорт
	
	Перем МассивСсылок;
		
	МД               = МетаданныеКонфигурации.Справочники.Найти(ИмяСправочника);
	БываютГруппы     = МД.Иерархический И МД.ВидИерархии = СвойстваОбъектовМетаданных.ВидИерархии.ИерархияГруппИЭлементов;
	Менеджер         = Справочники[ИмяСправочника];
	
	ПараметрыЗаписиСправочника = Новый Структура;
	ПараметрыЗаписиСправочника.Вставить("ИскатьПоКоду", 	МД.СерииКодов);
	ПараметрыЗаписиСправочника.Вставить("ПолнНаимен", 		ИмяРеквизитаПолнНаименование);
	ПараметрыЗаписиСправочника.Вставить("Родитель",   		?(МД.Иерархический, Менеджер.ПустаяСсылка(), Неопределено));
	ПараметрыЗаписиСправочника.Вставить("Владелец", 		Владелец);
	ПараметрыЗаписиСправочника.Вставить("Менеджер", 		Менеджер);
		
	Прогресс = 0;
	
	Если УдалятьНеактуальные Тогда
		МассивСсылок = Новый Массив
	КонецЕсли;
	
	НачатьТранзакцию();
	
	Попытка
		
		ТекущееСостояние = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Сохранение классификатора в справочник «%1»…'"),
			МД.Синоним);
		
		БылиНепомеченные = Ложь;
		
		Если ТипЗнч(Источник) = Тип("ДеревоЗначений") Тогда
			
			ПараметрыЗаписиСправочника.Вставить("ЕстьПометка", 		Истина);
			ПараметрыЗаписиСправочника.Вставить("ЕстьСтроки",  		Истина);
			ПараметрыЗаписиСправочника.Вставить("ЕстьЭлементы", 	Источник.Колонки.Найти("Элементы") <> Неопределено);
			ПараметрыЗаписиСправочника.Вставить("ЭтоОбъектXDTO", 	Ложь);
			ПараметрыЗаписиСправочника.Вставить("ЭтоГруппа", 		?(БываютГруппы, Неопределено, Ложь));
			
			
			ЗаписатьКоллекциюВСправочник(Источник.Строки, ПараметрыЗаписиСправочника, Прогресс, МассивСсылок, БылиНепомеченные);
			
		ИначеЕсли ТипЗнч(Источник) = Тип("ОбъектXDTO")
		        И Источник.Тип().Имя = "ClassifierDataType"
		        И Источник.Тип().URIПространстваИмен = xmlnsКлассификатор Тогда
				
			ПараметрыЗаписиСправочника.Вставить("ЕстьПометка", 		Ложь);
			ПараметрыЗаписиСправочника.Вставить("ЕстьСтроки",  		Истина);
			ПараметрыЗаписиСправочника.Вставить("ЕстьЭлементы", 	Истина);
			ПараметрыЗаписиСправочника.Вставить("ЭтоОбъектXDTO", 	Истина);
			ПараметрыЗаписиСправочника.Вставить("ЭтоГруппа",		БываютГруппы);

			// <classifier>/<data>/<group>
			ЗаписатьКоллекциюВСправочник(Источник.Строки, ПараметрыЗаписиСправочника, Прогресс, МассивСсылок, БылиНепомеченные);
			
			Если БылиНепомеченные Тогда
				// Все равно уже не будем помечать на удаление, так освободим память.
				МассивСсылок = Неопределено;
			КонецЕсли;
			
			ПараметрыЗаписиСправочника.Вставить("ЕстьСтроки",  	Ложь);
			ПараметрыЗаписиСправочника.Вставить("ЕстьЭлементы", Ложь);
			ПараметрыЗаписиСправочника.Вставить("ЭтоГруппа",	Ложь);
						
			// <classifier>/<data>/<item>
			ЗаписатьКоллекциюВСправочник(Источник.Элементы, ПараметрыЗаписиСправочника, Прогресс, МассивСсылок, БылиНепомеченные);
			
		Иначе
			ВызватьИсключение НСтр("ru = 'Источник не может быть сохранен в справочник.'");
		КонецЕсли;
		
		ЗафиксироватьТранзакцию();
		ТекущееСостояние = "";
		
	Исключение
		
		ОтменитьТранзакцию();
		
		ЗаписьЖурналаРегистрации(НСтр("ru = 'Загрузка ОКОФ'", Метаданные.ОсновнойЯзык.КодЯзыка),
			УровеньЖурналаРегистрации.Ошибка,,, ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
		
		ТекущееСостояние = "";
		
		ВызватьИсключение;
		
	КонецПопытки;
	
	ТекущееСостояние = "";
	
КонецПроцедуры // СохранитьКлассификатор()

Функция ДобавитьКлассификатор(СтрокаXMLИлиФайл, ПервичныйИсточник = "", MIMEТип = "", УникальныйИдентификатор = Неопределено) Экспорт
	
	Перем ТипЧитателя, Идентификатор, Наименование, НормАкт, Строка;
	
	Классификаторы.Очистить();
	
	Данные = Новый Структура("Содержание,
	|ФабрикаXDTO,
	|СтрокаXMLИлиФайл,
	|ТипЧитателя,
	|ДатаМодификации,
	|КоличествоЭлементов,
	|МаксимальноеЗначениеПрогрессора");
	
	Файл = ПроверитьРазархивироватьФайл(СтрокаXMLИлиФайл, ТипЧитателя,
	ПервичныйИсточник, MIMEТип,УникальныйИдентификатор);
	
	Если Файл = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли; 
	
	Данные.ДатаМодификации = Файл.ПолучитьВремяИзменения();
	Данные.ТипЧитателя = ТипЧитателя;
	
	ЧтениеXML = Новый(ТипЧитателя);
	Попытка
		ЧтениеXML.ОткрытьФайл(Файл.ПолноеИмя)
	Исключение
		#Если Не ВнешнееСоединение Тогда
			ОбщегоНазначенияКлиентСервер.СообщитьПользователю(
				СтрШаблон(НСтр("ru = 'Файл (%1) поврежден или имеет неверный формат.'"), СтрокаXMLИлиФайл.Имя));
		#КонецЕсли
		ЗаписьЖурналаРегистрации(
			СтрШаблон(НСтр("ru = 'Файл (%1) поврежден или имеет неверный формат.'", Метаданные.ОсновнойЯзык.КодЯзыка),
			СтрокаXMLИлиФайл.Имя), УровеньЖурналаРегистрации.Ошибка,,,ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
		Возврат Неопределено;
	КонецПопытки;
		
	Попытка
		ЧтениеXML.ПерейтиКСодержимому();
		Если ЧтениеXML.ТипУзла = ТипУзлаXML.НачалоЭлемента
		   И ЧтениеXML.URIПространстваИмен = xmlnsКлассификатор
		   И ЧтениеXML.ЛокальноеИмя = "classifier" Тогда
			
			Идентификатор = ЧтениеXML.ЗначениеАтрибута("classifier-type-id");
			ПозицияМаркераФрагмента = СтрНайти(Идентификатор, "#");
			
			Если ПозицияМаркераФрагмента = 0 Тогда
				Возврат Неопределено;
			КонецЕсли;
			Идентификатор = Сред(Идентификатор, ПозицияМаркераФрагмента + 1);
			
			// Узнали, что за классификатор - тут же выясняем, нужен ли он нам.
			Тип = xdtoТипКлассификатора(Идентификатор);
			
			// Неизвестного или незапрашиваемого типа.
			Если Тип = Неопределено Тогда
				Возврат Неопределено;
			КонецЕсли;
			
			ЗагружатьПолностью  = ЧтениеXML.ЗначениеАтрибута("allow-partial-load") = "false";
			УдалятьНеактуальные = ЧтениеXML.ЗначениеАтрибута("remove-obsolete") = "true";
			НеЧитать = Ложь;
			Пока НеЧитать Или ЧтениеXML.Прочитать() Цикл
				НеЧитать = Ложь;
				Если ЧтениеXML.ТипУзла = ТипУзлаXML.НачалоЭлемента Тогда
					Если ЧтениеXML.ЛокальноеИмя = "additional-packages"
					   И ЧтениеXML.URIПространстваИмен = xmlnsКлассификатор Тогда
						xdtoДопМодель = xdtoПрочитать(ЧтениеXML,
							ФабрикаXDTOКлассификаторов(),
							xmlnsV8XDTO, "Model");
						Для Каждого xdtoПакет Из МассивОбщихПакетовXDTO Цикл
							xdtoДопМодель.Package.Добавить(xdtoПакет);
						КонецЦикла;
						Данные.ФабрикаXDTO = Новый ФабрикаXDTO(xdtoДопМодель);
						НеЧитать = Истина; // мы уже на начале элемента, вызывать Прочитать() не надо
						
					ИначеЕсли ЧтениеXML.ЛокальноеИмя = "desc"
					        И ЧтениеXML.URIПространстваИмен = xmlnsКлассификатор Тогда
						ЧтениеXML.Прочитать();
						Если ЧтениеXML.ТипУзла = ТипУзлаXML.Текст Тогда
							Наименование = ЧтениеXML.Значение;
						КонецЕсли; 
						
					ИначеЕсли ЧтениеXML.ЛокальноеИмя = "data"
					   И ЧтениеXML.URIПространстваИмен = xmlnsКлассификатор Тогда
						Попытка
							Данные.КоличествоЭлементов = Число(ЧтениеXML.ЗначениеАтрибута("item-count"));
						Исключение
							Данные.КоличествоЭлементов = 0;
						КонецПопытки;
						Попытка
							Данные.МаксимальноеЗначениеПрогрессора = Число(ЧтениеXML.ЗначениеАтрибута("custom-progress-max-value"));
						Исключение
							Данные.МаксимальноеЗначениеПрогрессора = 0;
						КонецПопытки;
						// Если в файле не указано количество элементов, пытаемся определить его сами
						// посредством XPath. Очень долго…
						Если Данные.КоличествоЭлементов = 0 И Данные.МаксимальноеЗначениеПрогрессора = 0 Тогда
							ТекущееСостояние = НСтр("ru = 'Подсчет позиций классификатора…'");
							Попытка
								ПостроительDOM = Новый ПостроительDOM;
								ВремЧтениеXML  = Новый(ТипЧитателя);
								ВремЧтениеXML.ОткрытьФайл(Файл.ПолноеИмя);
								ДокументDOM = ПостроительDOM.Прочитать(ВремЧтениеXML);
								Разыменователь = Новый РазыменовательПространствИменDOM("csf", xmlnsКлассификатор);
								Результат = ДокументDOM.ВычислитьВыражениеXPath(
									"count(/csf:classifier/csf:data//csf:*[local-name()='group' or local-name()='item'])",
									ДокументDOM.ЭлементДокумента,
									Разыменователь,
									ТипРезультатаDOMXPath.Число);
								Данные.КоличествоЭлементов = Результат.ЧисловоеЗначение;
								// Освободим память.
								ДокументDOM   = Неопределено;
								ВремЧтениеXML = Неопределено;
							Исключение
								#Если Клиент Тогда
								ПоказатьИнформациюОбОшибке(ИнформацияОбОшибке());
								#КонецЕсли
								ЗаписьЖурналаРегистрации(НСтр("ru = 'Загрузка ОКОФ'", Метаданные.ОсновнойЯзык.КодЯзыка),
									УровеньЖурналаРегистрации.Ошибка,,,ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
							КонецПопытки;
							ТекущееСостояние = "";
						КонецЕсли; 
						Прервать;
					КонецЕсли;
				КонецЕсли;
			КонецЦикла;
		КонецЕсли;
	Исключение
		#Если Клиент Тогда
		ПоказатьИнформациюОбОшибке(ИнформацияОбОшибке());
		#КонецЕсли
		ЗаписьЖурналаРегистрации(НСтр("ru = 'Загрузка ОКОФ'", Метаданные.ОсновнойЯзык.КодЯзыка),
			УровеньЖурналаРегистрации.Ошибка,,,ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
		Возврат Неопределено;
	КонецПопытки;
	
	Если Не ЗначениеЗаполнено(Идентификатор) Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Если Данные.ФабрикаXDTO = Неопределено Тогда
		Данные.ФабрикаXDTO = ФабрикаXDTOКлассификаторов()
	КонецЕсли;
	
	ИдентификаторКлассификатора  	= Идентификатор;
	Загружать               		= Истина;
	ПерезаписыватьОбъекты   		= Истина;
	ПерезаписыватьЭтоГруппа 		= Истина;
	Источник                		= СтрокаXMLИлиФайл;
	НаименованиеКлассификатора      = ?(ПустаяСтрока(Наименование),
	                                 	МетаданныеКонфигурации.Справочники.Найти(Тип.ИмяСправочника).Синоним,
	                                 	Наименование);
	
										
	Если НормАкт = Неопределено Тогда
		Редакция = НСтр("ru = '<не указана>'");
	Иначе
		Редакция = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = '%1 %2%3 от %4'"),
			НормАкт.Вид,
			НормАкт.ВыпустившийОрган,
			?(ПустаяСтрока(НормАкт.Название), "", " " + НормАкт.Название),
			Формат(НормАкт.ДатаОпубликования, "ДЛФ=D"));
	КонецЕсли;
	
	Данные.СтрокаXMLИлиФайл = Файл;
	АдресВХранилище  = ПоместитьВоВременноеХранилище(Данные, УникальныйИдентификатор);
		
	Возврат Загружать;
	
КонецФункции // ДобавитьКлассификатор()

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

// Функция создает объект XDTO из XML.
//
// Параметры:
//  XML          - Строка, ЧтениеXML, ЧтениеFastInfoset, ЧтениеУзловDOM;
//                 источник - строка XML или уже созданный читатель;
//  Фабрика      - ФабрикаXDTO; фабрика, содержащая пакеты типов, которые
//                 будем читать;
//  ТипURI       - Строка; URI пространства имен типа, объект которого мы
//                 собрались читать;
//  ТипИмя       - Строка; локальное имя типа считываемого объекта.
//
// Возвращаемое значение:
//  ОбъектXDTO.
//
Функция xdtoПрочитать(Знач XML, 
					  Знач Фабрика,
                      Знач ТипURI = "",
                      Знач ТипИмя = "")
					  
	Если Не ПустаяСтрока(ТипИмя) Тогда
		Тип = Фабрика.Тип(ТипURI, ТипИмя)
	Иначе
		Тип = Неопределено
	КонецЕсли;
	
	Если ТипЗнч(XML) = Тип("Строка") Тогда
		ЧтениеXML = Новый ЧтениеXML;
		ЧтениеXML.УстановитьСтроку(XML)
	Иначе
		ЧтениеXML = XML;
	КонецЕсли;
	
	Возврат Фабрика.ПрочитатьXML(ЧтениеXML, Тип);
	
КонецФункции // ПрочитатьXDTO() 

// Функция формирует, если нужно, и возвращает фабрику XDTO, содержащую пакеты
// типов пространства имен {xmlnsКлассификатор}. Объект XDTO типа
// {http://v8.1c.ru/8.1/xdto}Model - модель типов - считывается из макета.
//
// Возвращаемое значение:
//  ФабрикаXDTO.
//
Функция ФабрикаXDTOКлассификаторов()
	Если ФабрикаXDTOКлассификаторов = Неопределено Тогда
		Если МассивОбщихПакетовXDTO = Неопределено Тогда
			МассивОбщихПакетовXDTO = Новый Массив;
			xdtoМодельXDTOТипов = xdtoПрочитать(ПолучитьМакет("МодельXDTO").ПолучитьТекст(),
				ФабрикаXDTO,
				xmlnsV8XDTO, "Model");
			Для Каждого xdtoПакет Из xdtoМодельXDTOТипов.Package Цикл
				МассивОбщихПакетовXDTO.Добавить(xdtoПакет);
			КонецЦикла;
		Иначе
			xdtoМодельXDTOТипов = ФабрикаXDTO.Создать(ФабрикаXDTO.Тип(xmlnsV8XDTO, "Model"));
			Для Каждого xdtoПакет Из МассивОбщихПакетовXDTO Цикл
				xdtoМодельXDTOТипов.Package.Добавить(xdtoПакет);
			КонецЦикла;
		КонецЕсли;
		ФабрикаXDTOКлассификаторов = Новый ФабрикаXDTO(xdtoМодельXDTOТипов);
	КонецЕсли;
	Возврат ФабрикаXDTOКлассификаторов
КонецФункции // ФабрикаXDTOКлассификаторов()

// Функция получает объект-список поддерживаемых конфигурацией типов
// классификаторов.
//
// Возвращаемое значение:
//  ОбъектXDTO типа {xmlnsОписанияТиповКлассификаторов}ClassifierTypeListType.
// Содержит свойства: ТипыКлассификаторов - список (<classifier-type>).
//
Функция xdtoТипыКлассификаторов()
	Если xdtoТипыКлассификаторов = Неопределено Тогда
		МакетТипов ="<?xml version=""1.0"" encoding=""Windows-1251""?>
					|<classifier-type-list xmlns=""urn:uuid:101fa9a0-ea86-11dc-afc4-0002a5d5c51b"">
					|	<classifier-type xml:id=""ОКОФ"">
					|		<catalog-name>ОбщероссийскийКлассификаторОсновныхФондов</catalog-name>
					|		<full-name-property>НаименованиеГруппировки</full-name-property>
					|		<filename-mask>okof.xml</filename-mask>
					|		<filename-mask>okof.aml</filename-mask>
					|		<filename-mask>okof.finf</filename-mask>
					|		<filename-mask>okof.zip</filename-mask>
					|	</classifier-type>
			   		|</classifier-type-list>";

		xdtoТипыКлассификаторов = xdtoПрочитать(МакетТипов,
			ФабрикаXDTOКлассификаторов(),
			xmlnsОписанияТиповКлассификаторов, "ClassifierTypeListType");
	КонецЕсли;
	Возврат xdtoТипыКлассификаторов;
КонецФункции // xdtoТипыКлассификаторов() 

// Процедура записи иерархической коллекции в справочник (рекурсивная).
//
// Параметры:
//  Коллекция    - КоллекцияСтрокДереваЗначений, ТаблицаЗначений, СписокXDTO;
//                 коллекция, элементы которой содержат свойства позиции
//                 классификатора;
//
//  ПараметрыЗаписи   - Структура с ключами:
//  	ЕстьПометка   - Булево; означает, что у эл. колл. есть свойство Пометка,
//                 	    которое нужно проверять, иначе - безусловно;
//  	ЕстьСтроки    - Булево; означает, что у эл. колл. есть свойство-коллекция
//                 	    Строки, и нужен рекурсивный вызов для него;
//  	ЕстьЭлементы  - Булево; означает, что у эл. колл. есть свойство-коллекция
//                 	    Элементы, и нужен рекурсивный вызов для него (коллекция не
//                      иерархическая);
//  	ЭтоОбъектXDTO - Булево; если Истина, то Коллекция есть СписокXDTO;
//  	ЭтоГруппа     - Булево, Неопределено; если Неопределено, значит у эл. колл.
//                 	    есть свойство ЭтоГруппа, его надо проверять;
//  	ИскатьПоКоду  - ПСОМД.СерииКодовСправочника; если ЕстьСсылка = Ложь,
//                 	    пытаться найти соответствующий эл. справочника по коду;
//  	ПолнНаимен    - Строка; имя реквизита справочника, хранящего полное
//                 	    наименование; если пустая - не устанавливать;
//  	Родитель      - Ссылка, Неопределено; ссылка на элемент справочника -
//                 	    родителя элементов, создаваемых на основе коллекции;
//                 	    для неиерархического справочника - Неопределено,
//                 	    для корневых элементов - пустая ссылка;
//  	Владелец      - Ссылка, Неопределено; ссылка на элемент справочника -
//                 	    владельца, для неподчиненного - Неопределено;
//  	Менеджер      - соответствующий СправочникМенеджер;
//
//  РазмерТранзакции - 0 или кол-во элементов, после обработки которого
//                     нужно фиксировать транзакцию;
//
//  Прогресс     - Число; инкрементируемая переменная (реквизит формы,
//                 для обновления прогресс-бара).
//
Процедура ЗаписатьКоллекциюВСправочник(Коллекция, ПараметрыЗаписи, Прогресс, МассивСсылок, БылиНепомеченные)
	
	// Константы
	Пробелы = "                                                  "; // 50 пробелов (для «добивки» до длины кода)
	// Определить, поддерживает ли данный справочник группы
	МетаданныеСправочника 	= ПараметрыЗаписи.Менеджер.ПустаяСсылка().Метаданные();
	ПоддерживаетГруппы 		= (МетаданныеСправочника.ВидИерархии = СвойстваОбъектовМетаданных.ВидИерархии.ИерархияГруппИЭлементов);
		
	ЗаписыватьСправочник = Ложь;
		
	Для Каждого Строка Из Коллекция Цикл
		
		// ЕстьПометка
		Если ПараметрыЗаписи.ЕстьПометка И Не Строка.Пометка Тогда
			БылиНепомеченные = Истина;
			Продолжить;
		КонецЕсли;
		
		// РазмерТранзакции, Прогресс
		Прогресс = Прогресс + 1;
				
		#Если Клиент Тогда
		ОбработкаПрерыванияПользователя();
		#КонецЕсли
		
		// ЭтоГруппа
		СоздаватьГруппу = ПоддерживаетГруппы
		                И ПараметрыЗаписи.Родитель <> Неопределено
		                И ?(ПараметрыЗаписи.ЭтоГруппа = Неопределено, Строка.ЭтоГруппа, ПараметрыЗаписи.ЭтоГруппа);
		
		
		ПоставщикЗначенийРеквизитов = ?(ПараметрыЗаписи.ЭтоОбъектXDTO, Строка, Строка.xdtoОбъект);
		
		// ИскатьПоКоду
		Если Не ПараметрыЗаписи.ЭтоОбъектXDTO Тогда
			ТекСсылка = Строка.Ссылка;
		Иначе
			СК = СвойстваОбъектовМетаданных.СерииКодовСправочника;
			ТекСсылка = ПараметрыЗаписи.Менеджер.НайтиПоКоду(ПоставщикЗначенийРеквизитов.Код, Ложь,
				?(ПараметрыЗаписи.ИскатьПоКоду = СК.ВПределахПодчинения,
					ПараметрыЗаписи.Родитель, Неопределено),
				?(ПараметрыЗаписи.ИскатьПоКоду = СК.ВПределахПодчиненияВладельцу,
					ПараметрыЗаписи.Владелец, Неопределено));
		КонецЕсли;
		
		Если ТекСсылка = Неопределено Тогда
			ТекСсылка = ПараметрыЗаписи.Менеджер.ПустаяСсылка();
		КонецЕсли;
		
		// Создание элемента
		Если ТекСсылка.Пустая() Тогда
			Объект = ?(СоздаватьГруппу, ПараметрыЗаписи.Менеджер.СоздатьГруппу(), ПараметрыЗаписи.Менеджер.СоздатьЭлемент());
		Иначе
			Если ПараметрыЗаписи.Родитель <> Неопределено
				И (Не ПараметрыЗаписи.ЭтоОбъектXDTO
					И Строка.ТекЭтоГруппа <> СоздаватьГруппу
					Или ПараметрыЗаписи.ЭтоОбъектXDTO
						И ТекСсылка.ЭтоГруппа <> СоздаватьГруппу) Тогда
				Объект = ?(СоздаватьГруппу, ПараметрыЗаписи.Менеджер.СоздатьГруппу(), ПараметрыЗаписи.Менеджер.СоздатьЭлемент());
				// В случае, если не все свойства устанавливаются классификатором,
				// попытаемся сохранить имеющиеся.
				ЗаполнитьЗначенияСвойств(Объект, ТекСсылка, , "Владелец");
				ТекСсылка.ПолучитьОбъект().Удалить();
				Объект.УстановитьСсылкуНового(ТекСсылка)
			Иначе
				Объект = ТекСсылка.ПолучитьОбъект();
				// Если элемент справочника удалили, пока ссылка на него хранилась в дереве.
				Если Объект = Неопределено Тогда
					Объект = ?(СоздаватьГруппу, ПараметрыЗаписи.Менеджер.СоздатьГруппу(), ПараметрыЗаписи.Менеджер.СоздатьЭлемент());
					Объект.УстановитьСсылкуНового(ТекСсылка);
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;

		Попытка
			Объект.Заблокировать();
		Исключение
			ЗаписьЖурналаРегистрации(НСтр("ru = 'Загрузка ОКОФ'", Метаданные.ОсновнойЯзык.КодЯзыка),
				УровеньЖурналаРегистрации.Ошибка,,,ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
				
			ВызватьИсключение;
		КонецПопытки;
		
		Если Объект.Заблокирован() Тогда
			
			// Заполнение элемента
			Если ПараметрыЗаписи.Родитель <> Неопределено Тогда
				УстановитьНовоеЗначение(Объект.Родитель, ПараметрыЗаписи.Родитель)
			КонецЕсли;
			Если ПараметрыЗаписи.Владелец <> Неопределено Тогда
				УстановитьНовоеЗначение(Объект.Владелец, ПараметрыЗаписи.Владелец)
			КонецЕсли;
			УстановитьНовоеЗначение(Объект.ПометкаУдаления, Ложь);
			Если Не ПустаяСтрока(ПараметрыЗаписи.ПолнНаимен) Тогда
				УстановитьНовоеЗначение(Объект[ПараметрыЗаписи.ПолнНаимен], ПоставщикЗначенийРеквизитов.Наименование);
			КонецЕсли;
			
			Если Объект.Модифицированность() Или Объект.ЭтоНовый() Тогда // уже бессмысленно проверять, изменились ли значения свойств
				
				ЗаполнитьЗначенияСвойств(Объект, ПоставщикЗначенийРеквизитов);
				
			Иначе
				
				Реквизиты = МетаданныеСправочника.Реквизиты;
				Для Каждого Свойство Из ПоставщикЗначенийРеквизитов.Свойства() Цикл
					
					Если ТипЗнч(Свойство.Тип) = Тип("ТипЗначенияXDTO") Тогда
						ИмяСвойства = Свойство.Имя;
						
						Если НРег(ИмяСвойства) = "код" Или НРег(ИмяСвойства) = "code" Тогда
							Если МетаданныеСправочника.ДлинаКода > 0 Тогда
								Если МетаданныеСправочника.ТипКода = СвойстваОбъектовМетаданных.ТипКодаСправочника.Строка Тогда
									УстановитьНовоеЗначение(
										Объект.Код,
										Лев(Строка(ПоставщикЗначенийРеквизитов[ИмяСвойства]) + Пробелы, МетаданныеСправочника.ДлинаКода));
								Иначе
									УстановитьНовоеЗначение(Объект.Код, ПоставщикЗначенийРеквизитов[ИмяСвойства]);
								КонецЕсли;
							КонецЕсли;
						ИначеЕсли НРег(ИмяСвойства) = "наименование" Или НРег(ИмяСвойства) = "description" Тогда
							Если МетаданныеСправочника.ДлинаНаименования > 0 Тогда
								УстановитьНовоеЗначение(Объект.Наименование, ПоставщикЗначенийРеквизитов[ИмяСвойства]);
							КонецЕсли;
						ИначеЕсли Реквизиты.Найти(ИмяСвойства) <> Неопределено Тогда
							УстановитьНовоеЗначение(Объект[ИмяСвойства], ПоставщикЗначенийРеквизитов[ИмяСвойства]);
						КонецЕсли;
						
					КонецЕсли;
					
				КонецЦикла;
				
			КонецЕсли;
			
			Объект.ОбменДанными.Загрузка = Истина;
			Объект.ДополнительныеСвойства.Вставить("ОбъектXDTO", ПоставщикЗначенийРеквизитов);
			Объект.ДополнительныеСвойства.Вставить("ЗагрузкаКлассификаторов", Истина);
			
			Если Объект.Модифицированность() Или Объект.ЭтоНовый() Тогда
				Объект.Записать();
			КонецЕсли;
			
			Если МассивСсылок <> Неопределено Тогда
				МассивСсылок.Добавить(Объект.Ссылка)
			КонецЕсли;
			
		КонецЕсли; // Объект.Заблокирован()

        Основание = ПоставщикЗначенийРеквизитов;
			
		Попытка
			xdtoАмортизационныеГруппы = Основание.amort_group;
			Если ТипЗнч(xdtoАмортизационныеГруппы) = Тип("ОбъектXDTO") Тогда // а не СписокXDTO
				ПодставнойМассив = Новый Массив;
				ПодставнойМассив.Добавить(xdtoАмортизационныеГруппы);
				xdtoАмортизационныеГруппы = ПодставнойМассив;
			КонецЕсли; 
		Исключение
			ПодставнойМассив = Новый Массив;
			xdtoАмортизационныеГруппы = ПодставнойМассив;
		КонецПопытки;
			
		НаборЗаписей = РегистрыСведений.АмортизационныеГруппыОКОФ.СоздатьНаборЗаписей();
		НаборЗаписей.Отбор.ОКОФ.Установить(Объект.Ссылка);
		
		Для Каждого xdtoСсылкаНаАмортизационнуюГруппу Из xdtoАмортизационныеГруппы Цикл
			
			НомерГруппы = Число(xdtoСсылкаНаАмортизационнуюГруппу.АмортизационнаяГруппа);
			Если НомерГруппы = 0 Тогда //отдельная группа
				НомерГруппы = 11
			КонецЕсли;
			АмортизационнаяГруппа = Перечисления.АмортизационныеГруппы[НомерГруппы - 1];
			
			Запись = НаборЗаписей.Добавить();
			Запись.Активность            = Истина;
			Запись.ОКОФ                  = Объект.Ссылка;
			Запись.АмортизационнаяГруппа = АмортизационнаяГруппа;
			Запись.Примечание            = xdtoСсылкаНаАмортизационнуюГруппу.Примечание;
			
		КонецЦикла;
		
		НаборЗаписей.Записать(Истина);
	
		// ЕстьСтроки
		Если ПараметрыЗаписи.ЕстьСтроки Тогда
			
			ПараметрыЗаписиСправочника = Новый Структура;
			ПараметрыЗаписиСправочника.Вставить("ЕстьПометка", 		ПараметрыЗаписи.ЕстьПометка); 
			ПараметрыЗаписиСправочника.Вставить("ЕстьСтроки", 		Истина); 
			ПараметрыЗаписиСправочника.Вставить("ЕстьЭлементы", 	ПараметрыЗаписи.ЕстьЭлементы);
			ПараметрыЗаписиСправочника.Вставить("ЭтоОбъектXDTO", 	ПараметрыЗаписи.ЭтоОбъектXDTO);
			ПараметрыЗаписиСправочника.Вставить("ЭтоГруппа",  		?(ПараметрыЗаписи.ЭтоГруппа = Неопределено, Неопределено, Истина));
			ПараметрыЗаписиСправочника.Вставить("ИскатьПоКоду", 	ПараметрыЗаписи.ИскатьПоКоду);
			ПараметрыЗаписиСправочника.Вставить("ПолнНаимен",   	ПараметрыЗаписи.ПолнНаимен);
			ПараметрыЗаписиСправочника.Вставить("Родитель",   		?(ПараметрыЗаписи.Родитель = Неопределено, Неопределено, Объект.Ссылка));
			ПараметрыЗаписиСправочника.Вставить("Владелец", 		ПараметрыЗаписи.Владелец);
			ПараметрыЗаписиСправочника.Вставить("Менеджер", 		ПараметрыЗаписи.Менеджер);

			ЗаписатьКоллекциюВСправочник(Строка.Строки,	ПараметрыЗаписиСправочника, Прогресс, МассивСсылок, БылиНепомеченные);
			
		КонецЕсли;
		
		// ЕстьЭлементы
		Если ПараметрыЗаписи.ЕстьЭлементы И Строка.Элементы <> Неопределено Тогда //убрать комментарий
			
			ПараметрыЗаписиСправочника = Новый Структура;
			ПараметрыЗаписиСправочника.Вставить("ЕстьПометка", 		Ложь); 
			ПараметрыЗаписиСправочника.Вставить("ЕстьСтроки", 		Ложь); 
			ПараметрыЗаписиСправочника.Вставить("ЕстьЭлементы", 	Ложь);
			ПараметрыЗаписиСправочника.Вставить("ЭтоОбъектXDTO", 	ПараметрыЗаписи.ЭтоОбъектXDTO);
			ПараметрыЗаписиСправочника.Вставить("ЭтоГруппа",  		Ложь);
			ПараметрыЗаписиСправочника.Вставить("ИскатьПоКоду", 	ПараметрыЗаписи.ИскатьПоКоду);
			ПараметрыЗаписиСправочника.Вставить("ПолнНаимен",   	ПараметрыЗаписи.ПолнНаимен);
			ПараметрыЗаписиСправочника.Вставить("Родитель",   		?(ПараметрыЗаписи.Родитель = Неопределено, Неопределено, Объект.Ссылка));
			ПараметрыЗаписиСправочника.Вставить("Владелец", 		ПараметрыЗаписи.Владелец);
			ПараметрыЗаписиСправочника.Вставить("Менеджер", 		ПараметрыЗаписи.Менеджер);
			
			ЗаписатьКоллекциюВСправочник(Строка.Элементы, ПараметрыЗаписиСправочника, Прогресс, МассивСсылок, БылиНепомеченные);
			
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры // ЗаписатьКоллекциюВСправочник()

// Процедура обрабатывает файл и решает, похож ли он на файл классификатора.
//
// Параметры:
//  Файл         - Файл; файл-источник;
//  ТипЧитателя  - Тип; переменная, принимающая тип объекта, который нужно
//                 создать, чтобы прочесть файл (ЧтениеXML или
//                 ЧтениеFastInfoset);
//  ПервичныйИсточник - Строка; первичное имя файла (Файл может быть
//                 временным) или URL для отображения в сообщениях об ошибках;
//  MIMEТип      - Строка; MIME-тип файла (в случае, если принят по протоколу
//                 HTTP), также используется для определения типа файла.
Функция ПроверитьРазархивироватьФайл(Файл, ТипЧитателя, ПервичныйИсточник, MIMEТип = "",УникальныйИдентификатор = Неопределено)
	
	Если НРег(Файл.Расширение) = ".aml" Тогда
		
		ИмяРаспакованногоФайла = ПолучитьИмяВременногоФайла("xml");
		ТекущееСостояние = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Распаковка файла (%1)…'"),
			Файл.Имя);
		РаспаковкаФайла        = Новый ЧтениеТекста(Файл.Имя, КодировкаТекста.UTF8);
		Попытка
			Хранилище              = XMLЗначение(Тип("ХранилищеЗначения"), РаспаковкаФайла.Прочитать());
			ДвоичныеДанные         = Хранилище.Получить();
			ДвоичныеДанные.Записать(ИмяРаспакованногоФайла);
		Исключение
			#Если Не ВнешнееСоединение Тогда
			ОбщегоНазначенияКлиентСервер.СообщитьПользователю(СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Файл (%1) не удалось распаковать: файл поврежден, имеет неверный формат, или не достаточно места на диске.'"),
			Файл.Имя));
			#КонецЕсли
			Возврат Неопределено
		КонецПопытки;
		ВременныеФайлы.Добавить(ИмяРаспакованногоФайла);
		Результат = Новый Файл(ИмяРаспакованногоФайла);
		Результат.УстановитьВремяИзменения(Файл.ПолучитьВремяИзменения());
		ТипЧитателя = Тип("ЧтениеXML");
		
	ИначеЕсли НРег(Файл.Расширение) = ".zip"
	      Или MIMEТип = "application/zip"
	      Или MIMEТип = "multipart/x-zip" Тогда
		
		ТекущееСостояние = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Распаковка файла (%1)…'"),
			Файл.Имя);
		Zip = Новый ЧтениеZipФайла;
		Zip.Открыть(Файл.ПолноеИмя);
		Для Каждого Элемент Из Zip.Элементы Цикл
			Если СтрНайти(".aml.xml.fin.finf.zip", НРег(Элемент.Расширение)) = 0
			 Или Элемент.Зашифрован Тогда
				Продолжить;
			КонецЕсли;
			ТемпКаталог = ПолучитьИмяВременногоФайла();
			Попытка
				Zip.Извлечь(Элемент, ТемпКаталог, РежимВосстановленияПутейФайловZIP.НеВосстанавливать);
			Исключение
				#Если Не ВнешнееСоединение Тогда
				ОбщегоНазначенияКлиентСервер.СообщитьПользователю(СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				НСтр("ru = 'Файл (%1) не удалось извлечь из (%2): архив поврежден, имеет неверный формат, или не достаточно места на диске.'"),
				Элемент.Имя,Файл.Имя));
				#КонецЕсли
				Продолжить
			КонецПопытки;
			НовоеИмя = ТемпКаталог + "\" + Элемент.Имя;
			ВременныеФайлы.Добавить(НовоеИмя);
			ВременныеФайлы.Добавить(ТемпКаталог);
			НовыйФайл = Новый Файл(НовоеИмя);
			ДобавитьКлассификатор(НовыйФайл, ПервичныйИсточник, "",УникальныйИдентификатор);
		КонецЦикла;
		Результат = Неопределено;
		
	ИначеЕсли НРег(Файл.Расширение) = ".finf"
	      Или НРег(Файл.Расширение) = ".fin"
	      Или MIMEТип = "application/fastinfoset" Тогда
		
		Результат = Файл;
		ТипЧитателя = Тип("ЧтениеFastInfoset");
		
	ИначеЕсли НРег(Файл.Расширение) = ".xml"
	      Или MIMEТип = "text/xml"
	      Или MIMEТип = "text/plain"
	      Или MIMEТип = "application/xml"
	      Или MIMEТип = "" Тогда
		
		Результат = Файл;
		ТипЧитателя = Тип("ЧтениеXML");
		
	Иначе
		ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Файл (%1) не является файлом классификатора.'"),
			Файл.Имя);
		Результат = Неопределено;
		
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции // ПроверитьРазархивироватьФайл()

// Процедура проверяет переданный параметр, если он не соответствует значению, 
// то присваивает ему указанное значение.
//
// Параметры:
//  Параметр - параметр, значение которого проверяется и заполняется.
//  Значение - значение для заполнения пустого параметра.
//
Процедура УстановитьНовоеЗначение(Параметр, Значение)
	
	Если Параметр <> Значение Тогда
		Параметр = Значение;
	КонецЕсли;
	
КонецПроцедуры // УстановитьНовоеЗначение()

#КонецОбласти

#Область ОператорыОсновнойПрограммы

xmlnsXML                			= "http://www.w3.org/XML/1998/namespace";
xmlnsV8XDTO             			= "http://v8.1c.ru/8.1/xdto";
xmlnsОписанияТиповКлассификаторов 	= "urn:uuid:101fa9a0-ea86-11dc-afc4-0002a5d5c51b";
xmlnsКлассификатор      			= "urn:uuid:be515360-d4a7-11dc-8abf-0002a5d5c51b";

ДопДанные = Новый Соответствие;

// Запоминаем временные файлы, чтобы стереть по окончании работы.
ВременныеФайлы = Новый Массив;

МетаданныеКонфигурации = Метаданные;

СвойстваОбъектовМетаданных = МетаданныеКонфигурации.СвойстваОбъектов;

#КонецОбласти


#КонецЕсли